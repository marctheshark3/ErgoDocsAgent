{
  "title": "Evaluation - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/dev/scs/ergotree/evaluation/",
  "summary": "Evaluation of \\(\\langname\\) is specified by its translation to \\(\\corelang\\), whose terms form a subset of \\(\\langname\\) terms. Thus, typing rules of \\(\\corelang\\) form a subset of typing rules of \\(\\langname\\). Here we specify evaluation semantics of \\(\\corelang\\), which is based on call-by-value (CBV) lambda calculus. Evaluation of \\(\\corelang\\) is specified using denotational semantics. To do that, we first specify denotations of types, then typed terms and then equations of denotational semantics.",
  "keywords": [
    "evaluation",
    "\\(\\langname\\",
    "translation",
    "\\(\\corelang\\",
    "term",
    "subset",
    "rule",
    "semantic",
    "call",
    "value",
    "lambda",
    "calculus",
    "denotation",
    "type",
    "equation",
    "producer",
    "language",
    "principle",
    "\\(a\\",
    "\\(\\denot{a}\\",
    "element",
    "\\(\\lst{boolean}\\",
    "\\(\\{\\lst{true},\\lst{false}\\}\\",
    "t_n)\\",
    "\\((t_1,\\dots",
    "form",
    "\\((v_1,\\dots",
    "v_n)\\",
    "\\(v_i\\",
    "\\(t_i\\",
    "\\(\\denot{v}\\",
    "\\(\\denot{m}\\",
    "\\(\\lam{x}{m}\\",
    "\\(\\denot{a",
    "\\denot{b}\\",
    "syntax",
    "\\(n\\",
    "context",
    "\\(\\gamma\\",
    "sequence",
    "identifier",
    "valuetype",
    "\\(x_1",
    "\\dot",
    "list",
    "summary",
    "function",
    "\\denot{\\gamma",
    "\\denot{t}\\"
  ],
  "sections": [
    {
      "heading": "ErgoTree Evaluation#",
      "content": "\\[\n\\newcommand{\\TEnv}{\\Gamma}\n\\newcommand{\\Der}[2]{#1~\\vdash~#2}\n\\newcommand{\\DerV}[2]{#1~\\vdash^{\\text{\\lst{v}}}~#2}\n\\newcommand{\\DerC}[2]{#1~\\vdash^{\\text{\\lst{c}}}~#2}\n\\newcommand{\\DerEnv}[1]{\\Der{\\TEnv}{#1}}\n\\newcommand{\\DerEnvV}[1]{\\DerV{\\TEnv}{#1}}\n\\newcommand{\\DerEnvC}[1]{\\DerC{\\TEnv}{#1}}\n\\newcommand{\\lst}[1]{#1}\n\\newcommand{\\Tup}[1]{(#1)}\n\\newcommand{\\Apply}[2]{#1\\langle#2\\rangle}\n\\newcommand{\\MSig}[3]{\\text{def}~#1(#2): #3}\n\\newcommand{\\Ov}[1]{\\overline{#1}}\n\\newcommand{\\TyLam}[3]{\\lambda(\\Ov{#1:#2}).#3}\n\\newcommand{\\Trait}[2]{\\text{trait}~#1~\\{ #2 \\}}\n\\newcommand{\\To}{\\mapsto}\n\\newcommand{\\Low}[1]{\\mathcal{L}{[\\![#1]\\!]}}\n\\newcommand{\\Lam}[2]{\\lambda#1.#2}\n\\newcommand{\\IfThenElse}[3]{\\text{if}~(#1)~#2~\\text{else}~#3}\n\\newcommand{\\False}{\\text{false}}\n\\newcommand{\\True}{\\text{true}}\n\\newcommand{\\langname}{ErgoTree}\n\\newcommand{\\corelang}{Core-\\lambda}\n\\newcommand{\\Denot}[1]{[\\![#1]\\!]}  \n\\]\nEvaluation of \\(\\langname\\) is specified by its translation to \\(\\corelang\\), whose terms form a subset of \\(\\langname\\) terms. Thus, typing rules of \\(\\corelang\\) form a subset of typing rules of \\(\\langname\\).\nHere we specify evaluation semantics of \\(\\corelang\\), which is based on call-by-value (CBV) lambda calculus. Evaluation of \\(\\corelang\\) is specified using denotational semantics. To do that, we first specify denotations of types, then typed terms and then equations of denotational semantics.\nDefinition 1\nThe following \\(\\corelang\\) terms are called values:\n\\[V :== x \\mid C(d, T) \\mid \\Lam{x}{M}\\]\nAll \\(\\corelang\\) terms are called producers. (This is because, when evaluated, they produce a value.)\nWe now describe and explain a denotational semantics for the \\(\\corelang\\) language. The key principle is that each type \\(A\\) denotes a set \\(\\Denot{A}\\) whose elements are the denotations of values of the type \\(A\\).\nThus the type \\(\\lst{Boolean}\\) denotes the 2-element set \\(\\{\\lst{true},\\lst{false}\\}\\), because there are two values of type \\(\\lst{Boolean}\\). Like..."
    }
  ],
  "qa_pairs": []
}