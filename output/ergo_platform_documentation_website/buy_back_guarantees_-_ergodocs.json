{
  "title": "Buy Back Guarantees - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/uses/dex-buyback/",
  "summary": "In this example, we will explore a decentralized token sale scenario where the seller provides buyback guarantees. The guarantee works as follows: the seller requires the buyer to create a buy order at a specific price for a certain amount of tokens. The remaining amount goes to the seller. Each order can have unique buyback properties, such as forming a bonding curve. We begin with a buyback contract.",
  "keywords": [
    "example",
    "sale",
    "scenario",
    "seller",
    "buyback",
    "guarantee",
    "buyer",
    "order",
    "price",
    "amount",
    "token",
    "property",
    "bonding",
    "curve",
    "contract",
    "expiration",
    "condition",
    "buyerpk",
    "sigmaprop(height",
    "number",
    "sell",
    "sigmaprop(allof(coll",
    "blake2b256(outputs(0).propositionbytes",
    "outputs(0).value",
    "buybackamount",
    "outputs(1).value",
    "towithdraw",
    "sellerpk.propbyte",
    "outputs(1).r4[coll[byte]].get",
    "self.id",
    "case",
    "script",
    "hash",
    "version",
    "code",
    "scastie",
    "functionality",
    "logic",
    "liquidity",
    "providing",
    "concept",
    "challenge",
    "user",
    "interface",
    "dexes"
  ],
  "sections": [
    {
      "heading": "Buy Back Guarantees#",
      "content": "In this example, we will explore a decentralized token sale scenario where the seller provides buyback guarantees.\nThe guarantee works as follows: the seller requires the buyer to create a buy order at a specific price for a certain amount of tokens. The remaining amount goes to the seller.\nEach order can have unique buyback properties, such as forming a bonding curve.\nWe begin with a buyback contract. It has an expiration condition (buyerPk && sigmaProp(HEIGHT > 100)); otherwise, the box has been spent if the original seller requests the number of tokens sent back.\n{\n        val defined = OUTPUTS(0).R2[Coll[(Coll[Byte], Long)]].isDefined &&  OUTPUTS(0).R4[Coll[Byte]].isDefined\n        (buyerPk && sigmaProp(HEIGHT > 100)) || sigmaProp (if (defined) {\n          allOf(Coll(\n              OUTPUTS(0).tokens(0)._1 == tokenId, \n              OUTPUTS(0).tokens(0)._2 >= tokenAmount,\n              OUTPUTS(0).propositionBytes == sellerPk.propBytes,\n              OUTPUTS(0).R4[Coll[Byte]].get == SELF.id)\n             )\n        } else { false } )\n    }\nThe sell contract is then defined as follows:\n{\n        sigmaProp(allOf(Coll(\n                    blake2b256(OUTPUTS(0).propositionBytes) == bbh,\n                    OUTPUTS(0).value == buyBackAmount,\n                    OUTPUTS(1).value >= toWithdraw,\n                    OUTPUTS(1).propositionBytes == sellerPk.propBytes,\n                    OUTPUTS(1).R4[Coll[Byte]].get == SELF.id\n                  ))\n                 )\n      }\n\nIn this case, bbh represents the buyback script hash.\nYou can experiment with a playground version of this code on scastie\nJust like the buyback, we can enhance orders with various conditions, thereby achieving DEX functionality. This makes simple DEX orders composable with complex logic such as token-sale, liquidity providing, etc. This concept is referred to as smart orders. However, the challenge lies in developing front-end apps and user interfaces for smart order-based DEXes."
    }
  ],
  "qa_pairs": []
}