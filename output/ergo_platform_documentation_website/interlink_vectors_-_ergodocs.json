{
  "title": "Interlink Vectors - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/dev/data-model/structures/interlink-vectors/",
  "summary": "Interlink vectors are a fundamental component of the Proof-of-Proof-of-Work (PoPow) protocol in the Ergo blockchain. These vectors allow lightweight clients to verify the correctness of the blockchain without needing to download and validate the entire chain. By storing references to previous block headers at varying heights, interlink vectors create a hierarchical structure that supports efficient validation and compression of blockchain data, making them particularly useful for devices with limited resources such as mobile phones or IoT devices. Interlink vectors work in conjunction with Merkle trees and PoPow proofs to ensure that the blockchain follows the longest chain rule, which is critical for maintaining the security and integrity of the network. In traditional blockchains, each block references its immediate predecessor, forming a simple linear chain.",
  "keywords": [
    "interlink",
    "vector",
    "component",
    "proof",
    "work",
    "popow",
    "protocol",
    "ergo",
    "blockchain",
    "client",
    "correctness",
    "chain",
    "reference",
    "block",
    "header",
    "height",
    "structure",
    "validation",
    "compression",
    "datum",
    "device",
    "resource",
    "phone",
    "conjunction",
    "merkle",
    "tree",
    "rule",
    "security",
    "integrity",
    "network",
    "predecessor",
    "linear",
    "constraint",
    "problem",
    "manner",
    "subset",
    "amount",
    "scenario",
    "node",
    "part",
    "range",
    "participant",
    "computing",
    "power",
    "array",
    "element",
    "level",
    "number",
    "zero",
    "block\u00e2\u0080\u0099s",
    "hash",
    "difficulty",
    "instance",
    "implementation",
    "genesis",
    "code",
    "logic",
    "scorex",
    "repository",
    "blockheader.scala",
    "file",
    "update",
    "mechanism",
    "construction",
    "process",
    "verification",
    "codebase",
    "ergohistory.scala",
    "batch",
    "efficiency",
    "sigma",
    "rust",
    "library",
    "batchmerkleproof.rs",
    "example",
    "practice",
    "root",
    "understanding",
    "developer",
    "application",
    "standard",
    "environment"
  ],
  "sections": [
    {
      "heading": "Overview#",
      "content": "Interlink vectors are a fundamental component of the Proof-of-Proof-of-Work (PoPow) protocol in the Ergo blockchain. These vectors allow lightweight clients to verify the correctness of the blockchain without needing to download and validate the entire chain. By storing references to previous block headers at varying heights, interlink vectors create a hierarchical structure that supports efficient validation and compression of blockchain data, making them particularly useful for devices with limited resources such as mobile phones or IoT devices.\nInterlink vectors work in conjunction with Merkle trees and PoPow proofs to ensure that the blockchain follows the longest chain rule, which is critical for maintaining the security and integrity of the network."
    },
    {
      "heading": "Purpose of Interlink Vectors#",
      "content": "In traditional blockchains, each block references its immediate predecessor, forming a simple linear chain. For lightweight clients, downloading and validating every block in this chain is impractical due to resource constraints. Interlink vectors solve this problem by storing references to previous blocks in a hierarchical manner. This allows clients to verify the chain's integrity by checking only a subset of blocks, drastically reducing the amount of data they need to process.\nInterlink vectors are essential for enabling efficient and secure blockchain validation in scenarios where full nodes are impractical. They are a key part of ensuring that the network remains decentralized and accessible to a wide range of participants, including those with limited computing power."
    },
    {
      "heading": "Structure of Interlink Vectors#",
      "content": "An interlink vector is essentially an array of block headers, where each element points to a previous block header at a certain level of the chain. The levels in the interlink vector are determined by the number of leading zeros in the block\u00e2\u0080\u0099s hash, which corresponds to the difficulty level of the block."
    },
    {
      "heading": "Key Properties:#",
      "content": "Efficiency: Interlink vectors allow clients to verify the longest chain without needing to download the entire blockchain, making the process more efficient.\nScalability: They support the participation of lightweight clients by minimizing the data required for verification.\nSecurity: By adhering to the longest chain rule, interlink vectors help ensure that the blockchain remains secure and that all participants can trust its integrity."
    },
    {
      "heading": "Example Structure:#",
      "content": "For instance, if a block has two leading zeros in its hash, it might be placed at the second level of the interlink vector. Higher levels correspond to blocks with more leading zeros, indicating higher difficulty.\ngraph TD\n    A[Block Header at Level 0] --> B[Block Header at Level 1]\n    B --> C[Block Header at Level 2]\n    C --> D[Block Header at Level 3]\n    D --> E[Latest Block Header]\nThis hierarchical structure allows clients to verify the blockchain's integrity by checking only the relevant levels in the interlink vector."
    },
    {
      "heading": "Implementation in Ergo#",
      "content": "Interlink vectors are implemented in the Ergo blockchain as part of the PoPow protocol and are stored in the block headers. The implementation involves recursively hashing previous block headers, starting from the genesis block, and updating the interlink vector with each new block."
    },
    {
      "heading": "1. Creating the Interlink Vector:#",
      "content": "When a new block is mined:\nThe block\u00e2\u0080\u0099s hash is computed.\nThe number of leading zeros in the hash determines the block's level in the interlink vector.\nThe block header is added to the vector at the corresponding level.\nCode Reference: The logic for creating and managing interlink vectors is implemented within the Scorex repository used by the Ergo blockchain. Specifically, you can find the relevant code in the BlockHeader.scala file."
    },
    {
      "heading": "2. Updating the Interlink Vector:#",
      "content": "As new blocks are added:\nThe interlink vector is updated by adding references to new block headers.\nIf a block with more leading zeros (indicating a higher level) is found, it replaces the previous block at that level.\nCode Reference: The interlink vector update mechanism is handled within the Ergo block header construction process."
    },
    {
      "heading": "3. Verifying the Chain with Interlink Vectors:#",
      "content": "To verify the blockchain:\nA client checks the blocks referenced in the interlink vector.\nBy verifying that each block in the vector adheres to the required difficulty level, the client confirms that the chain follows the longest chain rule.\nCode Reference: Chain verification using interlink vectors is integrated into the block validation logic in the Ergo codebase, particularly within the ErgoHistory.scala file."
    },
    {
      "heading": "4. Batch Merkle Proofs and Interlink Vectors:#",
      "content": "Interlink vectors are often combined with batch Merkle proofs to enhance efficiency:\nA batch Merkle proof allows the simultaneous verification of multiple elements in the interlink vector.\nThis reduces the computational overhead and ensures secure validation.\nCode Reference: Batch Merkle proof logic is implemented in the sigma-rust library, specifically in the batchmerkleproof.rs file."
    },
    {
      "heading": "Example Usage#",
      "content": "Consider a scenario where a lightweight client wants to verify the blockchain up to a certain height. The client can download the interlink vector from the latest block and check the references to previous blocks at each level. By verifying the Merkle proofs for these references, the client can confirm that the chain is valid without downloading the entire chain.\nHere\u00e2\u0080\u0099s an example of how the interlink vector might be used in practice:\nuse sigma_merkle_tree::batchmerkleproof::BatchMerkleProof;\nuse sigma_merkle_tree::merkletree::MerkleTree;\nuse sigma_merkle_tree::MerkleNode;\n\nfn verify_interlink_vector(tree: &MerkleTree, proof: &BatchMerkleProof) {\n    // Verify the Merkle proof for the interlink vector\n    assert!(proof.valid(tree.root_hash().as_ref()));\n    println!(\"Interlink vector is valid.\");\n}\nCode Reference: The example demonstrates the use of batch Merkle proofs from the sigma-rust library to verify the interlink vector against the blockchain's Merkle root."
    },
    {
      "heading": "Conclusion#",
      "content": "Interlink vectors are a key component of Ergo's PoPow protocol, enabling efficient and secure blockchain validation for lightweight clients. By understanding and utilizing interlink vectors, developers can ensure that their applications and clients maintain the highest standards of security and efficiency, even in resource-constrained environments."
    }
  ],
  "qa_pairs": []
}