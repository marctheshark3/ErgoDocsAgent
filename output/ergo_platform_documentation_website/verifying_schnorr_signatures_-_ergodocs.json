{
  "title": "Verifying Schnorr Signatures - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/dev/scs/sigma/verifying/",
  "summary": "The Schnorr signature scheme is a key cryptographic primitive in Ergo, allowing for efficient, simple, and secure signatures. Whether verifying a transaction or proving the ownership of a private key on-chain, Schnorr signatures play a central role. This page explains how to verify a Schnorr signature in ErgoScript, starting from basic signing and verification steps to advanced on-chain validation. Ergo uses the Secp256k1 elliptic curve (the same curve used in Bitcoin), denoted as G, for its Schnorr signature scheme. The Schnorr signature allows a user to prove knowledge of a private key without revealing the key itself.",
  "keywords": [
    "schnorr",
    "signature",
    "scheme",
    "primitive",
    "ergo",
    "transaction",
    "ownership",
    "chain",
    "role",
    "page",
    "ergoscript",
    "signing",
    "verification",
    "step",
    "validation",
    "curve",
    "bitcoin",
    "user",
    "knowledge",
    "message",
    "hash",
    "pair",
    "verifier",
    "diving",
    "identification",
    "process",
    "variant",
    "\\cdot",
    "check",
    "hash(u",
    "holder",
    "corresponding",
    "challenge",
    "interaction",
    "generation",
    "test",
    "case",
    "method",
    "approach",
    "logic",
    "code",
    "part",
    "proof",
    "bigint",
    "response",
    "limit",
    "nonce",
    "example",
    "chaincash",
    "repository",
    "authentication",
    "multi",
    "privacy",
    "mechanism",
    "ergoscript\u00e2\u0080\u0099s",
    "support",
    "detail",
    "variety",
    "application",
    "protocol",
    "swap",
    "ring",
    "threshold"
  ],
  "sections": [
    {
      "heading": "Schnorr Signatures#",
      "content": "The Schnorr signature scheme is a key cryptographic primitive in Ergo, allowing for efficient, simple, and secure signatures. Whether verifying a transaction or proving the ownership of a private key on-chain, Schnorr signatures play a central role. This page explains how to verify a Schnorr signature in ErgoScript, starting from basic signing and verification steps to advanced on-chain validation."
    },
    {
      "heading": "Overview#",
      "content": "Ergo uses the Secp256k1 elliptic curve (the same curve used in Bitcoin), denoted as G, for its Schnorr signature scheme. The Schnorr signature allows a user to prove knowledge of a private key without revealing the key itself."
    },
    {
      "heading": "Key Setup:#",
      "content": "The secret key is an integer x.\nThe corresponding public key is Y = g^x, where g is the generator of the elliptic curve group G."
    },
    {
      "heading": "Schnorr Signing Process#",
      "content": "To sign a message M (the hash of the message), follow these steps:\nGenerate a random integer r and compute U = g^r.\nCompute the challenge c = Hash(U || M).\nCompute the response s = r - cx.\nThe signature is the pair (c, s), which is sent to the verifier."
    },
    {
      "heading": "Schnorr Identification#",
      "content": "Before diving into signature verification, it's helpful to understand the Schnorr identification process, a variant of Schnorr signatures:\nInstead of sending (c, s), the prover sends (U, s) (a group element and an integer).\nThe verifier computes c = Hash(U || M) and checks if:\n  [\n  g^s = U / Y^c\n  ]\n  This works because:\n  [\n  g^s = g^{r - cx} = g^r / (gx)c = U / Y^c\n  ]"
    },
    {
      "heading": "Schnorr Signature Verification#",
      "content": "For Schnorr signatures, the signature (c, s) is verified differently. The verifier computes U = g^s \\cdot Y^c and checks if:\n  [\n  c = Hash(U || M)\n  ]\nThis process ensures that the signature is valid and was produced by the holder of the secret key corresponding to the public key Y."
    },
    {
      "heading": "On-Chain Verification in ErgoScript#",
      "content": "In ErgoScript, verifying a Schnorr signature involves reconstructing U on-chain and checking the challenge."
    },
    {
      "heading": "ErgoScript Example:#",
      "content": "{ \n  // Getting the generator of the elliptic curve group \n  val g: GroupElement = groupGenerator\n\n  // Getting the public key Y from R4\n  val Y = SELF.R4[GroupElement].get\n\n  // Getting the message M from R5\n  val M = SELF.R5[Coll[Byte]].get\n\n  // Retrieving the c value (challenge) from context variable 0\n  val cBytes = getVar .get\n  val c = byteArrayToBigInt(cBytes)\n\n  // Retrieving the s value (response) from context variable 1\n  val s = getVar .get\n\n  // Calculating U = g^s * Y^c\n  val U = g.exp(s).multiply(Y.exp(c)).getEncoded // as a byte array\n\n  // Checking if the Schnorr signature is valid\n  sigmaProp(cBytes == sha256(U ++ M))\n}"
    },
    {
      "heading": "Script Explanation:#",
      "content": "The generator of the elliptic curve group (g) is retrieved using the global value groupGenerator.\nThe public key (Y) is retrieved from register R4 of the box being spent (SELF).\nThe message hash (M) is retrieved from register R5 of the box being spent.\nThe signature components, challenge (cBytes) and response (s), are provided as context variables by the prover during transaction creation.\nThe script reconstructs the commitment U using the formula g^s * Y^c.\nFinally, it verifies the signature by hashing the reconstructed U concatenated with the message M (sha256(U ++ M)) and comparing the result with the original challenge cBytes. If they match, the signature is valid, and the sigmaProp evaluates to true."
    },
    {
      "heading": "Reference Test:#",
      "content": "The complete off-chain and on-chain interaction, including signature generation and verification, can be seen in this test case."
    },
    {
      "heading": "Alternative On-Chain Verification (Using Identification Scheme Logic):#",
      "content": "While the above method directly verifies the Schnorr signature (c, s), an alternative approach based on the Schnorr identification scheme logic can sometimes be simpler, though it requires providing U (or a in the code below) instead of c as part of the proof.\nNote: The primary challenge with on-chain verification is that ErgoScript's BigInt is limited to 256 bits. Off-chain signature generation must ensure the response s (or z below) fits within this limit.\n{\n    val message = ...\n    // Compute challenge\n    val e: Coll[Byte] = blake2b256(message)\n    val eInt = byteArrayToBigInt(e) // Challenge as big integer\n\n    // Retrieve a of signature (a, z)\n    val a = getVar .get\n    val aBytes = a.getEncoded\n\n    // Retrieve z of signature (a, z)\n    val zBytes = getVar .get\n    val z = byteArrayToBigInt(zBytes)\n\n    // Verify signature by checking if g^z = a * Y^e\n    val properSignature = g.exp(z) == a.multiply(holder.exp(eInt))\n\n    sigmaProp(properSignature)\n}"
    },
    {
      "heading": "Off-Chain Signature Generation (Ensuring Size Limit):#",
      "content": "To ensure the response z fits within 255 bits (required for ErgoScript's BigInt), the off-chain signing code might need to iterate until a suitable random nonce r is found:\ndef randBigInt: BigInt = {\n    val random = new SecureRandom()\n    val values = new Array \n    random.nextBytes(values)\n    BigInt(values).mod(SecP256K1.q)\n  }\n\n  @tailrec // Scala annotation for tail recursion optimization\n  def sign(msg: Array[Byte], secretKey: BigInt): (GroupElement, BigInt) = {\n    val r = randBigInt // Generate random nonce\n    val g: GroupElement = CryptoConstants.dlogGroup.generator\n    val a: GroupElement = g.exp(r.bigInteger) // Calculate U = g^r\n    // Calculate challenge e = H(a || msg) - using Blake2b256 here\n    val e = BigInt(scorex.crypto.hash.Blake2b256(a.getEncoded ++ msg)) \n    // Calculate response z = r + x*e (mod q) - Note: Schnorr formula is typically r - x*e or r + x*e depending on convention\n    val z = (r + secretKey * e) % CryptoConstants.groupOrder \n\n    // Check if z fits within 255 bits for ErgoScript compatibility\n    if(z.bigInteger.bitLength <= 255) { \n      (a, z) // Return signature (a, z)\n    } else {\n      sign(msg, secretKey) // Retry with a new random nonce r\n    }\n  }\nFor further examples of constructing off-chain transactions and verifying them on-chain, refer to the ChainCash repository."
    },
    {
      "heading": "Considerations and Limitations#",
      "content": "Weak Fiat-Shamir Transformation: The standard Schnorr signature verification shown (c = H(U || M)) uses a basic form of the Fiat-Shamir transformation. This is generally secure when the public key Y is fixed and known. However, be aware of potential security implications in more complex protocols where public keys might be dynamic or interact in unexpected ways. Stronger transformations might be needed in such advanced scenarios."
    },
    {
      "heading": "Conclusion#",
      "content": "Schnorr signatures in Ergo provide a powerful, efficient, and flexible way to handle cryptographic authentication both on-chain and off-chain. Whether it's a simple transaction signature or a complex proof involving multi-signatures or privacy-preserving mechanisms, ErgoScript\u00e2\u0080\u0099s built-in support for Schnorr signatures makes it easy to implement.\nFor more details, explore:\nThe SchnorrSpec test case, which demonstrates both on-chain verification of Schnorr signatures and off-chain signature generation in ErgoScript.\nThe ChainCash repository for further examples of Schnorr-based signature transactions and how to integrate them in more complex use cases.\nBy understanding and leveraging Schnorr signatures in Ergo, you can implement secure, efficient, and scalable cryptographic proofs for a variety of applications, ranging from simple transactions to privacy-preserving protocols like atomic swaps, ring signatures, and threshold signatures."
    },
    {
      "heading": "Resources#",
      "content": "Schnorr Signature Paper: MuSig: A New Multi-Signature Standard \u00e2\u0080\u0093 A foundational paper on Schnorr multi-signatures.\nAdaptor Signatures: Adaptor Signatures for Cross-Chain Protocols \u00e2\u0080\u0093 A deep dive into the use of Schnorr signatures for atomic swaps and privacy-preserving transactions.\nElliptic Curve Cryptography: SecP256K1 Curve Information \u00e2\u0080\u0093 Detailed information on the elliptic curve used in both Bitcoin and Ergo.\nSigmaBoolean Documentation: SigmaBoolean in Ergo \u00e2\u0080\u0093 Documentation on how to use SigmaBoolean and generalized Schnorr proofs in Ergo smart contracts."
    }
  ],
  "qa_pairs": []
}