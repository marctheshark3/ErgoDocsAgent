{
  "title": "FlowCards - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/dev/scs/flowcards/",
  "summary": "FlowCards aim to radically simplify dApp development on Ergo by providing a high-level declarative language, execution runtime, storage format and a graphical notation. See also, flowcardLib: Ergo FlowCard library for diagrams.net ErgoScript is the smart contract language used by the Ergo blockchain. While it has concise syntax adopted from Scala/Kotlin, it may still seem confusing at first because conceptually, ErgoScript is quite different from conventional languages. This is because Ergo is a UTXO-based blockchain, whereas smart contracts are traditionally associated with account-based systems like Ethereum. However, Ergo's transaction model has many advantages over the account-based model, and with the right approach, developing Ergo contracts can even be significantly easier than writing and debugging Solidity code.",
  "keywords": [
    "flowcards",
    "dapp",
    "development",
    "ergo",
    "level",
    "language",
    "execution",
    "runtime",
    "storage",
    "format",
    "notation",
    "flowcardlib",
    "flowcard",
    "library",
    "diagrams.net",
    "ergoscript",
    "contract",
    "blockchain",
    "syntax",
    "scala",
    "kotlin",
    "utxo",
    "account",
    "system",
    "ethereum",
    "transaction",
    "model",
    "advantage",
    "approach",
    "solidity",
    "code",
    "aspect",
    "task",
    "coin",
    "alice",
    "balance",
    "series",
    "operation",
    "programming",
    "hand",
    "condition",
    "change",
    "state",
    "validity",
    "check",
    "chain",
    "contrast",
    "validation",
    "number",
    "node",
    "network",
    "addition",
    "immutability",
    "graph",
    "optimization",
    "strategy",
    "throughput",
    "second",
    "light",
    "verifying",
    "scalability",
    "accessibility",
    "semantic",
    "dollar",
    "context",
    "computation",
    "bitcoin",
    "concurrent",
    "nature",
    "trustless",
    "client",
    "turing",
    "potential",
    "practice",
    "limitation",
    "bloat",
    "cost",
    "complexity",
    "problem",
    "side",
    "completeness",
    "power",
    "point",
    "benefit",
    "rest",
    "article",
    "concept",
    "developer",
    "component",
    "sequence",
    "function",
    "transfer",
    "token",
    "sender",
    "receiver",
    "instance",
    "return",
    "precondition",
    "post",
    "sent",
    "event",
    "miner",
    "reward",
    "data",
    "structure",
    "list",
    "input",
    "output",
    "example",
    "figure",
    "picture",
    "step",
    "user",
    "total",
    "amount",
    "txfee",
    "minerg",
    "target",
    "minerfee",
    "appkit",
    "application",
    "creation",
    "process",
    "spending",
    "recipient",
    "command",
    "result",
    "effect",
    "boxes",
    "parlance",
    "signature",
    "scenario",
    "course",
    "send",
    "require(amount",
    "block",
    "spend",
    "value",
    "parameter",
    "script",
    "thing",
    "order",
    "proposition",
    "predicate",
    "formula",
    "part",
    "capability",
    "range",
    "defi",
    "apps",
    "lets",
    "section",
    "diagrams",
    "representation",
    "diagram",
    "specification",
    "idea",
    "observation",
    "flow",
    "perspective",
    "transformer",
    "element",
    "name",
    "meaning",
    "view",
    "piece",
    "card",
    "template",
    "guarding",
    "pk(pubkey",
    "address",
    "pubkey",
    "type",
    "pk(sender",
    "wallet",
    "pk(receiver",
    "property",
    "note",
    "instantiation",
    "readability",
    "synonym",
    "access",
    "outputs(2",
    "darker",
    "rectangle",
    "arrow",
    "line",
    "text",
    "form",
    "register",
    "boxname",
    "ascription",
    "variable",
    "sell",
    "swap",
    "tamt",
    "tooling",
    "time",
    "building",
    "expression",
    "design",
    "contracts",
    "label",
    "name@index",
    "index",
    "fee@0",
    "endpoint",
    "position",
    "collection",
    "action",
    "source",
    "path",
    "case",
    "orange",
    "error",
    "outputs",
    "feature",
    "participant",
    "buyer",
    "seller",
    "ergamt",
    "tokens",
    "vice",
    "matching",
    "service",
    "exchange",
    "logic",
    "detail",
    "pk(buyer",
    "buyorder",
    "tool",
    "designer",
    "cancelbuy",
    "cancel",
    "alternative",
    "pk(seller",
    "convention",
    "usability",
    "buyerout@0",
    "buyerout",
    "sellerout",
    "prefix",
    "play",
    "ergotree",
    "support",
    "choice",
    "information",
    "argument",
    "cancelcondition",
    "swapcondition",
    "bid.id",
    "@contract",
    "rule",
    "buyerout.tokens(tid",
    "self.id",
    "r4[coll[byte]].get",
    "buyerout.propositionbyte",
    "tokens.getbykey(tid",
    "reason",
    "constant",
    "correspondence",
    "consistency",
    "translation",
    "transformation",
    "dex(buyer",
    "addrss",
    "long",
    "sigmaprop",
    "provedlog",
    "outputs.size",
    "regr4",
    "r4[coll[byte",
    "regr4.get",
    "sellorder",
    "help",
    "battle",
    "domain",
    "stream",
    "processing",
    "deep",
    "learning",
    "databases",
    "shift",
    "focus",
    "place",
    "work",
    "spec",
    "file",
    "json",
    "protobuf",
    "editor",
    "dapps",
    ".flowcard",
    "viewer",
    "designing",
    "experience",
    "correctness",
    "thank",
    "robert",
    "kornacki",
    "draft"
  ],
  "sections": [
    {
      "heading": "FlowCards",
      "content": "FlowCards aim to radically simplify dApp development on Ergo by providing a high-level declarative language, execution runtime, storage format and a graphical notation.\nSee also, flowcardLib: Ergo FlowCard library for diagrams.net"
    },
    {
      "heading": "Introduction#",
      "content": "ErgoScript is the smart contract language used by the Ergo blockchain. While it has concise syntax adopted from Scala/Kotlin, it may still seem confusing at first because conceptually, ErgoScript is quite different from conventional languages. This is because Ergo is a UTXO-based blockchain, whereas smart contracts are traditionally associated with account-based systems like Ethereum. However, Ergo's transaction model has many advantages over the account-based model, and with the right approach, developing Ergo contracts can even be significantly easier than writing and debugging Solidity code.\nBelow, we cover the key aspects of the Ergo contract model that make it different:"
    },
    {
      "heading": "Paradigm#",
      "content": "The account model of Ethereum is imperative. This means that the typical task of sending coins from Alice to Bob requires changing the balances in storage as a series of operations. Ergo's UTXO-based programming model, on the other hand, is declarative. ErgoScript contracts specify conditions for a transaction to be accepted by the blockchain (not changes to be made in the storage state resulting from the contract execution)."
    },
    {
      "heading": "Scalability#",
      "content": "In the account model of Ethereum, both storage changes and validity checks are performed on-chain during code execution. In contrast, Ergo transactions are created off-chain, and only validation checks are performed on-chain, thus reducing the number of operations performed by every node on the network. In addition, due to the immutability of the transaction graph, various optimization strategies can improve the throughput of transactions per second in the network. Light verifying nodes are also possible, thus further facilitating scalability and accessibility of the network."
    },
    {
      "heading": "Shared state#",
      "content": "The account-based model relies on the shared mutable state, which is known to lead to complex semantics (and subtle, million-dollar bugs) in the context of concurrent and distributed computation. Ergo's model is based on an immutable graph of transactions. This approach, inherited from Bitcoin, is well-suited to the concurrent and distributed nature of blockchains and facilitates light trustless clients."
    },
    {
      "heading": "Expressive Power#",
      "content": "Ethereum advocated the execution of a Turing-complete language on the blockchain. It theoretically promised unlimited potential; however, in practice, severe limitations arose from excessive blockchain bloat, subtle multi-million dollar bugs, gas costs that limit contract complexity, and other such problems. Ergo, on the flip side, extends UTXO to enable Turing-completeness while limiting the complexity of the ErgoScript language itself. The same expressive power is achieved in a different, more semantically sound way.\nWith all of the above points, it should be clear that there are many benefits to the model Ergo uses. In the rest of this article, I will introduce you to the concept of FlowCards - a dApp developer component that allows for designing complex Ergo contracts in a declarative and visual way."
    },
    {
      "heading": "From Imperative to Declarative#",
      "content": "In the imperative programming model of Ethereum, a transaction is a sequence of operations executed by the Ethereum VM. The following Solidity function implements a transfer of tokens from sender to receiver. The transaction starts when the sender calls this function on an instance of a contract and ends when the function returns.\n// Sends an amount of existing coins from any caller to an address\nfunction send(address receiver, uint amount) public {\n    require(amount <= balances[msg.sender], \"Insufficient balance.\");\n    balances[msg.sender] -= amount;\n    balances[receiver] += amount;\n    emit Sent(msg.sender, receiver, amount);\n}\nThe function first checks the preconditions, then updates the storage (i.e. balances) and finally publishes the post-condition as the Sent event. The gas which is consumed by the transaction is sent to the miner as a reward for executing this transaction.\nUnlike Ethereum, a transaction in Ergo is a data structure holding a list of input coins which it spends and a list of output coins which it creates, preserving the total balances of ERGs and tokens (in which Ergo is similar to Bitcoin).\nTurning back to the example above, since Ergo natively supports tokens, therefore for this specific example of sending tokens, we don't need to write any code in ErgoScript. Instead, we need to create the 'send' transaction shown in the following figure, which describes the same token transfer but declaratively.\nThe picture visually describes the following steps, which the network user needs to\nperform:\n1) Select the sender's unspent boxes, containing a total of tB >= amount tokens and B >= txFee + minErg ERGs.\n2) Create an output target box protected by the receiver public key with minErg ERGs and amount of T tokens.\n3) Create one fee output protected by the minerFee contract with txFee ERGs.\n4) Create one change output protected by the sender public key, containing B - minErg - txFee ERGs and tB - amount of T tokens.\n5) Create a new transaction, sign ..."
    },
    {
      "heading": "From Changing State to Checking Context#",
      "content": "In the send function example, we first checked the precondition (require(amount <= balances[msg.sender],...)) and then changed the state (i.e., updated balances balances[msg.sender] -= amount). This is typical of Ethereum transactions. Before we change anything, we need to check if it is valid to do so.\nIn Ergo, as we discussed previously, the state (i.e., the UTXO set of boxes) is changed implicitly when a valid transaction is included in a block. Thus, we only need to check the preconditions before the transaction can be added to the block. This is what ErgoScript contracts do.\nIt is not possible to \"change the state\" in ErgoScript because it is a language for checking preconditions for spending coins. ErgoScript is a purely functional language without side effects that operates on immutable data values. This means all the inputs, outputs, and other transaction parameters available in a script are immutable. This, among other things, makes ErgoScript a very simple language that is easy to learn and safe to use. Similar to Bitcoin, each input box contains a script, which should return the true value in order to 1) allow spending of the box (i.e., remove it from the UTXO set) and 2) allow the transaction to be added to the block.\nIf we are being pedantic, it is therefore incorrect (strictly speaking) to think of ErgoScript as the language of Ergo contracts because it is the language of propositions (logical predicates, formulas, etc.) that protect boxes from \"illegal\" spending. Unlike Bitcoin, in Ergo, the whole transaction and a part of the current blockchain context are available to every script. Therefore, each script may check which outputs are created by the transaction, their ERG and token amounts (we will use this capability in our example DEX contracts), the current block number, etc.\nIn ErgoScript, you define whether the conditions of changes (i.e., coin spending) are allowed to happen in a given context. This is in contrast to programming the changes imper..."
    },
    {
      "heading": "FlowCard Diagrams#",
      "content": "The idea behind FlowCard diagrams is based on the following observations: 1) An Ergo box is immutable and can only be spent in the transaction that uses it as an input. 2) Therefore, we can draw a flow of boxes through transactions so that boxes flowing in to the transaction are spent and those flowing out are created and added to the UTXO set. 3) A transaction from this perspective is simply a transformer of old boxes to new ones, preserving the balances of ERGs and tokens involved.\nThe following figure shows the main elements of the Ergo transaction we've already seen\npreviously (now under the name of FlowCard Diagram).\nThere is a strictly defined meaning (semantics) behind every element of the diagram,\nso that the diagram is a visual representation (or a view) of the underlying executable\ncomponent (called FlowCard).\nThe FlowCard can be used as a reusable component of an Ergo dApp to create and initiate the\ntransaction on the Ergo blockchain. We will discuss this in the coming sections.\nNow let's look at the individual pieces of the FlowCard diagram one by one."
    },
    {
      "heading": "1. Name and Parameters#",
      "content": "Each flow card is given a name and a list of typed parameters. This is similar to a template with parameters. In the above figure, we can see the Send flow card, which has five parameters. The parameters are used in the specification."
    },
    {
      "heading": "2. Contract Wallet#",
      "content": "This is a key element of the flow card. Every box has a guarding script. Often, it is the script that checks a signature against a public key. This script is trivial in ErgoScript and is defined like the def pk(pubkey: Address) = { pubkey } template, where pubkey is a parameter of the type Address. In the figure, the script template is applied to the parameter pk(sender), and thus a concrete wallet contract is obtained. Therefore, pk(sender) and pk(receiver) yield different scripts and represent different wallets on the diagram, even though they use the same template.\nContract Wallet contains a set of all UTXO boxes which have a given script derived from the given script template using flow card parameters. For example, in the figure, the template is pk, and the parameter pubkey is substituted with the sender flow card parameter."
    },
    {
      "heading": "3. Contract#",
      "content": "Even though a contract is a property of a box, on the diagram, we group the boxes by their contracts. Therefore, it looks like the boxes belong to the contracts rather than the contracts belonging to the boxes. In the example, we have three instantiated contracts: pk(sender), pk(receiver), and minerFee. Note that pk(sender) is the instantiation of the pk template with the concrete parameter sender, and minerFee is the instantiation of the pre-defined contract that protects the miner reward boxes."
    },
    {
      "heading": "4. Box name#",
      "content": "In the diagram, we can give each box a name. Besides the readability of the diagram, we also use the name as a synonym for a more complex indexed access to the box in the contract. For example, change is the name of the box, which can also be used in the ErgoScript conditions instead of OUTPUTS(2). We also use box names to associate spending conditions with the boxes."
    },
    {
      "heading": "5. Boxes in the wallet#",
      "content": "In the diagram, we show boxes (darker rectangles) as belonging to the contract wallets (lighter rectangles). Each such box rectangle is connected to a grey transaction rectangle by either orange or green arrows or both. An output box (with an incoming green arrow) may include many lines of text where each line specifies a condition that should be checked as part of the transaction. The first line specifies the condition on the amount of ERG that should be placed in the box. Other lines may take one of the following forms:\n1) amount: TOKEN - the box should contain the given amount of the given TOKEN.\n2) R == value - the box should contain the given value in the given register R.\n3) boxName ? condition - the box named boxName should check condition in its script.\nWe discuss these conditions in the sections below."
    },
    {
      "heading": "6. Amount of ERGs in the box#",
      "content": "Each box must store a minimum amount of ERGs. This is checked when the creating transaction is validated. In the diagram, the amount of ERGs is always shown as the first line (e.g., B: ERG or B - minErg - txFee). The value type ascription B: ERG is optional and may be used for readability. When the value is given as a formula, then this formula must be respected by the transaction that creates the box.\nIt is important to understand that variables like amount and txFee are not named properties of the boxes. They are parameters of the whole diagram and represent specific amounts. Put another way, they are shared parameters between transactions (e.g., Sell Order and Swap transactions from the DEX example below share the tAmt parameter). So, the same name is tied to the same value throughout the diagram (this is where tooling would help significantly). However, when it comes to on-chain validation of those values, only explicit conditions marked with ? are transformed into ErgoScript. At the same time, all other conditions are ensured off-chain during transaction building (for example, in an application using the Appkit API) and during transaction validation when it is added to the blockchain."
    },
    {
      "heading": "7. Amount of T token#",
      "content": "A box can store the values of many tokens. The tokens on the diagram are named, and a value variable may be associated with the token T using the value: T expression. The value may be given as a formula. If the formula is prefixed with a box name like boxName ? formula, then it should also be checked in the guarding script of the boxName box. This additional specification is very convenient because 1) it allows the visual design to be validated automatically, and 2) the conditions specified in the boxes of a diagram are enough to synthesize the necessary guarding scripts (more about this below at \"From Diagrams To ErgoScript Contracts\")."
    },
    {
      "heading": "8. Tx Inputs#",
      "content": "Inputs are connected to the corresponding transaction by orange arrows. An input arrow may have a label of the following forms:\n1) name@index - optional name with an index, e.g., fee@0 or @2. This is a property of the target endpoint of the arrow. The name is used in conditions of related boxes, and the index is the position of the corresponding box in the INPUTS collection of the transaction.\n2) !action - is a property of the source of the arrow and gives a name for an alternative spending path of the box (we will see this in the DEX example).\nBecause of alternative spending paths, a box may have many outgoing orange arrows, in which case they should be labeled with different actions."
    },
    {
      "heading": "9. Transaction#",
      "content": "A transaction spends input boxes and creates output boxes. The input boxes are given by the orange arrows, and the labels are expected to place inputs at the right indexes in the INPUTS collection. The output boxes are given by the green arrows. Each transaction must preserve a strict balance of ERG values (sum of inputs == sum of outputs), and for each token, the sum of inputs >= the sum of outputs. The design diagram requires an explicit specification of the ERG and token values for all output boxes to avoid implicit errors and ensure better readability."
    },
    {
      "heading": "10. Tx Outputs#",
      "content": "Outputs are connected to the corresponding transaction by green arrows. An output arrow may have a label of the following form name@index, where an optional name is accompanied by an index, e.g., fee@0 or @2. This is a property of the source endpoint of the arrow. The name is used in conditions of the related boxes, and the index is the position of the corresponding box in the OUTPUTS collection of the transaction."
    },
    {
      "heading": "Example: Decentralized Exchange (DEX)#",
      "content": "Now let's use the above-described notation to design a FlowCard for a DEX dApp. It is simple enough yet also illustrates all the key features of FlowCard diagrams that we've introduced in the previous section.\nThe dApp scenario is shown in the figure below:\nThere are three participants (buyer, seller, and DEX) of the DEX dApp and five different transaction types that are created by participants. The buyer wants to swap ergAmt of ERGs for tAmt of TID tokens (or vice versa, the seller wants to sell TID tokens for ERGs; who sends the order first doesn't matter). Both the buyer and the seller can cancel their orders at any time. The DEX off-chain matching service can find matching orders and create the Swap transaction to complete the exchange.\nThe following diagram fully (and formally) specifies all five transactions that must be created off-chain by the DEX dApp. It also specifies all the spending conditions that must be verified on-chain.\nLet's discuss the FlowCard diagram and the logic of each transaction in detail:"
    },
    {
      "heading": "Buy Order Transaction#",
      "content": "A buyer creates a Buy Order transaction. The transaction spends E amount of ERGs (which we will write E: ERG) from one or more boxes in the pk(buyer) wallet. The transaction creates a bid box with ergAmt: ERG protected by the buyOrder script. The buyOrder script is synthesized from the specification (see below at \"From Diagrams To ErgoScript Contracts\") either manually or automatically by a tool. Even though we don't need to define the buyOrder script explicitly during design, at run time, the bid box must contain the buyOrder script as the guarding proposition (which checks the box spending conditions); otherwise, the conditions specified in the diagram will not be checked.\nThe change box is created to make the input and output sums of the transaction balanced. The transaction fee box is omitted because it can be added automatically by the tools. In practice, however, the designer can add the fee box explicitly to the diagram. This covers cases of more complex transactions (like swap) where there are many ways to pay the transaction fee."
    },
    {
      "heading": "Cancel Buy, Cancel Sell Transactions#",
      "content": "At any time, the buyer can cancel the order by sending a CancelBuy transaction. The transaction must satisfy the guarding buyOrder contract that protects the bid box.\nAs you can see on the diagram, both the Cancel and the Swap transactions can spend the bid box. When a box has spending alternatives (or spending paths), each alternative is identified by a unique name prefixed with ! (!cancel and !swap for the bid box). Each alternative path has specific spending conditions. In our example, when the Cancel Buy transaction spends the bid box, the ?buyer condition must be satisfied, which we read as \"the signature for the buyer address must be presented in the transaction\". Therefore, only the buyer can cancel the buy order. This \"signature\" condition is only required for the !cancel alternative spending path and not required for !swap."
    },
    {
      "heading": "Sell Order Transaction#",
      "content": "The Sell Order transaction is similar to the BuyOrder in that it deals with tokens in addition to ERGs. The transaction spends E: ERG and T: TID tokens from the seller's wallet (specified as the pk(seller) contract). The two outputs are ask and change. The change box is a standard box to balance transactions. The ask box keeps tAmt: TID tokens for the exchange and minErg: ERG - the minimum amount of ERGs required in every box."
    },
    {
      "heading": "Swap Transaction#",
      "content": "This is a key transaction in the DEX dApp scenario. The transaction has several spending conditions on the input boxes, and those conditions are included in the buyOrder and sellOrder scripts, which are verified when the transaction is added to the blockchain. However, on the diagram, those conditions are not specified in the bid and ask boxes; they are instead defined in the output boxes of the transaction.\nThis is a convention for improved usability because most conditions relate to the properties of the output boxes. We could specify those properties in the bid box, but then we would have to use more complex expressions.\nLet's consider the output created by the arrow labeled with buyerOut@0. This label tells us that the output is at index 0 in the OUTPUTS collection of the transaction and that in the diagram, we can refer to this box by the buyerOut name. Thus, we can label both the box itself and the arrow to give the box a name.\nThe conditions shown in the buyerOut box have the form bid ? condition, which means they must be verified on-chain in order to spend the bid box. The conditions have the following meaning:\ntAmt: TID requires the box to have tAmt amount of TID token.\nR4 == bid.id requires the R4 register in the box to be equal to the id of the bid box.\nscript == buyer requires the buyerOut box to have the script of the wallet where it is located on the diagram (i.e., pk(buyer)).\nSimilar properties are added to the sellerOut box, which is specified to be at index 1, and the name is given to it using the label on the box itself rather than on the arrow.\nThe Swap transaction spends two boxes, bid and ask, using the !swap spending path on both; however, unlike !cancel, the conditions on the path are not specified. This is where the bid ? and ask ? prefixes come into play. They are used so that the conditions listed in the buyerOut and sellerOut boxes are moved to the !swap spending path of the bid and ask boxes, respectively.\nIf you look at the conditions of..."
    },
    {
      "heading": "From Diagrams To ErgoScript Contracts#",
      "content": "What is interesting about FlowCard specifications is that we can use them to automatically generate the necessary ErgoTree scripts. With appropriate tooling support, this can be done automatically, but lacking that, it can be done manually. Thus, the FlowCard allows us to capture and visually represent all design choices and semantic details of an Ergo dApp.\nWhat we are going to do next is mechanically create the buyOrder contract from the information given in the DEX flow card. Recall that each script is a proposition (boolean-valued expression) that must evaluate to true to allow spending of the box. When we have many conditions to be met simultaneously, we can combine them in a logical formula using the AND binary operation, and if we have alternatives (not necessarily exclusive), we can put them into the OR operation. The buyOrder box has the alternative spending paths !cancel and !swap.\nThus, the ErgoScript code should have an OR operation with two arguments - one for each spending path.\n/** buyOrder contract */\n{\n  val cancelCondition = {}\n  val swapCondition = {}\n  cancelCondition || swapCondition\n}\n\nThe formula for the cancelCondition expression is given in the !cancel spending path\nof the buyOrder box. We can directly include it in the script.\n/** buyOrder contract */\n{\n  val cancelCondition = { buyer }\n  val swapCondition = {}\n  cancelCondition || swapCondition\n}\nFor the !swap spending path of the buyOrder box, the conditions are specified in the\nbuyerOut output box of the Swap transaction. If we simply include them in the\nswapCondition, then we get a syntactically incorrect script.\n/** buyOrder contract */\n{\n  val cancelCondition = { buyer }\n  val swapCondition = {\n    tAmt: TID &&\n    R4 == bid.id &&\n    @contract\n  }\n  cancelCondition || swapCondition\n}\n\nWe can, however, translate the conditions from the diagram syntax to ErgoScript expressions using the following simple rules:\n1) buyerOut@0 ==> val buyerOut = OUTPUTS(0)\n2) tAmt: TID  ==> tid._2 == tAmt..."
    },
    {
      "heading": "Conclusions#",
      "content": "Declarative programming models have already won the battle against imperative programming in many application domains (like Big Data, Stream Processing, Deep Learning, Databases, etc.). Ergo is pioneering the declarative model of dApp development as a better and safer alternative to the now-popular imperative model of smart contracts.\nThe concept of FlowCard shifts the focus from writing ErgoScript contracts to the overall flow of values (hence the name) in such a way that ErgoScript can always be generated from them. You may never need to look at the ErgoScript code once the tooling is in place.\nHere are the possible next steps for future work:\n1) Storage format for FlowCard Spec and a corresponding EIP-standardized file format (JSON/XML/Protobuf). This will allow various tools (Diagram Editor, Runtime, dApps, etc.) to create and use *.flowcard files.\n2) FlowCard Viewer, which can generate diagrams from *.flowcard files.\n3) FlowCard Runtime, which can run *.flowcard files, create, and send transactions to the Ergo network.\n4) FlowCard Designer Tool, which can simplify the development of complex diagrams. This will make designing and validating Ergo contracts a pleasant experience, more like drawing than coding. In addition, the correctness of the whole dApp scenario can be verified and controlled by the tooling."
    },
    {
      "heading": "References#",
      "content": "Ergo\nErgo Appkit\nIntroduction to Appkit\nAppkit Examples\nErgoTree Specification\nflowcardLib: Ergo FlowCard library for diagrams.net\nWith thanks to Robert Kornacki for polishing the draft."
    }
  ],
  "qa_pairs": []
}