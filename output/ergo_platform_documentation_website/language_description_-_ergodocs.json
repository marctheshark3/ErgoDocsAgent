{
  "title": "Language Description - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/dev/scs/sigma/lang-spec/",
  "summary": "\u00f0\u009f\u0094\u0097 From sigmastate-interpreter ErgoScript is a language to write contracts for Ergo blockchain. ErgoScript contracts can be compiled to ErgoTrees, serialized and stored in UTXOs. A good starting point to writing contracts is to use ErgoScript by Example with Ergo Playgrounds or Appkit. The ErgoScript compiler is published\nas a library which is cross compiled for Java 7 and Java 8+ and can be used from any JVM lanugage, Android or JavaFX.",
  "keywords": [
    "\u00f0\u009f\u0094\u0097",
    "sigmastate",
    "interpreter",
    "ergoscript",
    "language",
    "contract",
    "ergo",
    "blockchain",
    "ergotrees",
    "utxo",
    "starting",
    "point",
    "writing",
    "example",
    "playgrounds",
    "appkit",
    "compiler",
    "library",
    "cross",
    "java",
    "lanugage",
    "android",
    "javafx",
    "source",
    "code",
    "transaction",
    "freezecoin.java",
    "detail",
    "string",
    "literal",
    "block",
    "declaration",
    "expression",
    "condition",
    "constant",
    "freezedeadline",
    "pkowner",
    "value",
    "compilecontract",
    "method",
    "section",
    "operation",
    "object",
    "sense",
    "member",
    "function",
    "property",
    "variable",
    "type",
    "representation",
    "number",
    "boolean",
    "runtime",
    "user",
    "class",
    "note",
    "trait",
    "synonyms",
    "coll",
    "program",
    "text",
    "unit",
    "interger",
    "bool",
    "coll(1",
    "collection",
    "item",
    "character",
    "syntax",
    "deserialize",
    "base64",
    "below",
    "scala",
    "addition",
    "inherit",
    "numeric",
    "following",
    "script",
    "context",
    "datum",
    "data",
    "access",
    "listing",
    "header",
    "preheader",
    "storage",
    "register",
    "other",
    "index",
    "myoutput",
    "outputs(0",
    "myinput",
    "size",
    "element",
    "existence",
    "predicate",
    "paper"
  ],
  "sections": [
    {
      "heading": "ErgoScript Language Description#",
      "content": "\u00f0\u009f\u0094\u0097 From sigmastate-interpreter"
    },
    {
      "heading": "Introduction#",
      "content": "ErgoScript is a language to write contracts for Ergo blockchain. ErgoScript contracts can be compiled to ErgoTrees, serialized and stored in UTXOs.\nA good starting point to writing contracts is to use ErgoScript by Example with Ergo Playgrounds or Appkit.\nThe ErgoScript compiler is published\nas a library which is cross compiled for Java 7 and Java 8+ and can be used from any JVM lanugage, Android or JavaFX.\nThe following example shows how source code of ErgoScript contract can be used to create new transaction using Appkit, see FreezeCoin.java for more details.\n// To create transaction we use a builder obtained from the context\n// the builder keeps relationship with the context to access necessary blockchain data.\nUnsignedTransactionBuilder txB = ctx.newTxBuilder();\n\n// create new box using new builder obtained from the transaction builder\n// in this case we compile new ErgoContract from source ErgoScript code\nOutBox newBox = txB.outBoxBuilder()\n        .value(amountToPay)\n        .contract(ctx.compileContract(\n                ConstantsBuilder.create()\n                        .item(\"freezeDeadline\", ctx.getHeight() + newBoxDelay)\n                        .item(\"pkOwner\", prover.getP2PKAddress().pubkey())\n                        .build(),\n                \"{ \" +\n                \"  val deadlinePassed = sigmaProp(HEIGHT > freezeDeadline)\" +\n                \"  deadlinePassed && pkOwner \" +\n                \"}\"))\n        .build();\nThe contract is given as the string literal which contains the block of val declarations followed by the logical expression. The expression defines the all possible conditions to spend the box. The contract can also contain named\nconstants (which cannot be represented as literals in the source code).\nIn the example freezeDeadline and pkOwner are named constants. The concrete values of named constants should be given to the compiler (see compileContract method)\n**The following sections describe ErgoScript and its operations. **"
    },
    {
      "heading": "ErgoScript language features overview#",
      "content": "Syntax borrowed from Scala\nStandard syntax and semantics for well known constructs (operations, code blocks, if branches etc.)\nHigh-order language with first-class lambdas which are used in collection operations\nCall-by-value (eager evaluation)\nStatically typed with local type inference\nBlocks are expressions \nSemicolon inference in blocks\nType constructors: Pair, Coll, Option"
    },
    {
      "heading": "Operations and constructs overview#",
      "content": "Binary operations: >, <, >=, <=, +, -, &&, ||, ==, !=, |, &, *, /, %, ^, ++\nPredefined primitives: blake2b256, byteArrayToBigInt, proveDlog etc. \nVal declarations: val h = blake2b256(pubkey)\nIf-then-else clause: if (x > 0) 1 else 0\nCollection literals: Coll(1, 2, 3, 4)\nGeneric high-order collection operations: map, filter, fold, exists, forall, etc.\nAccessing fields of any predefined types: box.value\nMethod invocation for predefined types: coll.map({ x => x + 1 })\nFunction invocations (predefined and user defined): proveDlog(pubkey) \nUser defined function declarations: def isProven(pk: GroupElement) = proveDlog(pk).isProven\nLambdas and high-order methods: OUTPUTS.exists { (out: Box) => out.value >= minToRaise }"
    },
    {
      "heading": "Data types#",
      "content": "In ErgoScript, everything is an object in the sense that we can call member functions and properties on any variable.\nSome of the types can have a special internal representation - for example, numbers and booleans can be\nrepresented as primitive values at runtime - but to the user they look like ordinary classes.\nNOTE: in ErgoScript we use type, class and trait as synonyms, we prefer type when talking about primitive values and\ntrait or class when talking about methods.\nType Name\nDescription\n\n\n\n\nAny\na supertype of any other type (not used directly in ErgoScript)\n\n\nUnit\na type with a single value ()\n\n\nBoolean\na type with two logical values true and false\n\n\nByte\n8 bit signed integer\n\n\nShort\n16 bit signed integer\n\n\nInt\n32 bit signed integer\n\n\nLong\n64 bit signed integer\n\n\nBigInt\n256 bit signed integer\n\n\nSigmaProp\na type representing a sigma proposition which can be verified by executing a Sigma protocol with zero-knowledge proof of knowledge. Every contract should return a value of this type.\n\n\nAvlTree\nrepresents a digest of authenticated dynamic dictionary and can be used to verify proofs of operations performed on the dictionary\n\n\nGroupElement\nelliptic curve points\n\n\nBox\na box containing a monetary value (in NanoErgs), tokens and registers along with a guarding proposition\n\n\nOption[T]\na container which either have some value of type T or none.\n\n\nColl[T]\na collection of arbitrary length with all values of type T\n\n\n(T1,T2)\na pair of values where T1, T2 can be different types\nThe type constructors Coll, (_,_) can be used to construct complex\ntypes as in the following example.\n{\n  val keyValues = OUTPUTS(0).R4[Coll[(Int, (Byte, Long))]].get\n  ...\n}"
    },
    {
      "heading": "Literal syntax and Constants#",
      "content": "Literals are used to introduce values of some types directly in program text\nlike in the following example:\nval unit: Unit = ()       // unit constant\nval long: Int = 10        // interger value literal\nval bool: Boolean = true  // logical literal\nval arr = Coll(1, 2, 3)   // constructs a collection with given items\nval str = \"abc\"           // string of characters \n\nNote that many types don't have literal syntax and their values are introduced \nby applying operations, for example deserialize function can be used to introduce\na constant of any type by using Base64 encoded string (See predefined function)."
    },
    {
      "heading": "Primitive Types#",
      "content": "Below we specify methods of pre-defined types using Scala-like declaration of classes.\nNote, the Boolean type doesn't have pre-defined methods in addition to the standard operations.\nNote, ErgoScript doesn't allow to define new class types, however it has many pre-defined classes with methods defined below.\nEvery numeric type has the following methods.\n/** Base supertype for all numeric types. */\nclass Numeric {\n  /** Convert this Numeric value to Byte. \n   * @throws ArithmeticException if overflow happens. \n   */\n  def toByte: Byte\n\n  /** Convert this Numeric value to Short. \n   * @throws ArithmeticException if overflow happens. \n   */\n  def toShort: Short\n\n  /** Convert this Numeric value to Int. \n   * @throws ArithmeticException if overflow happens. \n   */\n  def toInt: Int\n\n  /** Convert this Numeric value to Long. \n   * @throws ArithmeticException if overflow happens. \n   */\n  def toLong: Long\n\n  /** Convert this Numeric value to BigInt. */\n  def toBigInt: BigInt\n}\nAll the predefined numeric types inherit Numeric class and its methods.\nThey can be thought of as being pre-defined, like the following.\nclass Byte extends Numeric\nclass Short extends Numeric\nclass Int extends Numeric\nclass Long extends Numeric\nclass BigInt extends Numeric"
    },
    {
      "heading": "Context Data#",
      "content": "Every script is executed in a context, which is a collection of data available\nfor operations in the script. The context data is available using the CONTEXT\nvariable which is of pre-defined class Context which is shown below.\nThere are also shortcut variables which are available in every script to\nsimplify access to the most commonly used context data.\nVariable\nType\nShortcut for ...\n\n\n\n\nHEIGHT\nInt\nCONTEXT.HEIGHT\n\n\nSELF\nBox\nCONTEXT.SELF\n\n\nINPUTS\nColl[Box]\nCONTEXT.INPUTS\n\n\nOUTPUTS\nColl[Box]\nCONTEXT.OUTPUTS\nThe following listing shows the methods of pre-defined Context, Header,\nPreHeader types.\n/** Represents data available in ErgoScript using `CONTEXT` global variable */\nclass Context {\n  /** Height (block number) of the block which is currently being validated. */\n  def HEIGHT: Int\n\n  /** Box whose proposition is being currently executing */\n  def SELF: Box\n\n  /** Zero based index in `inputs` of `selfBox` */\n  def selfBoxIndex: Int\n\n  /** A collection of inputs of the current transaction, the transaction where\n    * selfBox is one of the inputs. \n    */\n  def INPUTS: Coll[Box]\n\n  /** A collection of data inputs of the current transaction. Data inputs are\n    * not going to be spent and thus don't participate in transaction validation\n    * as `INPUTS`, but data boxes are available in guarding propositions of\n    * `INPUTS` and thus can be used in spending logic.\n    */\n  def dataInputs: Coll[Box]\n\n  /** A collection of outputs of the current transaction. */\n  def OUTPUTS: Coll[Box]\n\n  /** Authenticated dynamic dictionary digest representing Utxo state before\n    * current state. \n    */\n  def LastBlockUtxoRootHash: AvlTree\n\n  /** A fixed number of last block headers in descending order (first header is\n    * the newest one) */\n  def headers: Coll[Header]\n\n/** Fields of a new block header, that can be predicted by a miner before block's formation */\n  def preHeader: PreHeader\n  /** Bytes of encoded miner's public key.\n    * Same as `preHeader.minerPk.getEncoded`\n    *..."
    },
    {
      "heading": "Box type#",
      "content": "Box represents a unit of storage in Ergo blockchain. It contains 10 registers\n(indexed 0-9). First 4 are mandatory and the others are optional.\n/** Representation of Ergo boxes used during execution of ErgoTree operations. */\nclass Box {\n  /** Box monetary value in NanoErg */\n  def value: Long \n\n  /** Blake2b256 hash of this box's content, basically equals to\n    * `blake2b256(bytes)` \n    */\n  def id: Coll[Byte] \n\n  /** Serialized bytes of guarding script, which should be evaluated to true in\n    * order to open this box. \n    */\n  def propositionBytes: Coll[Byte] \n\n  /** Serialized bytes of this box's content, including proposition bytes. */\n  def bytes: Coll[Byte] \n\n  /** Serialized bytes of this box's content, excluding transactionId and index\n    * of output. \n    */\n  def bytesWithoutRef: Coll[Byte]\n\n  /** If `tx` is a transaction which generated this box, then `creationInfo._1`\n    * is a height of the tx's block. The `creationInfo._2` is a serialized\n    * transaction identifier followed by box index in the transaction outputs.\n    */\n  def creationInfo: (Int, Coll[Byte]) \n\n  /** Synonym of R2 obligatory register */\n  def tokens: Coll[(Coll[Byte], Long)] \n\n  /** Extracts register by id and type.\n    * ErgoScript is typed, so accessing a register is an operation which involves some\n    * expected type given in brackets. Thus `SELF.R4[Int]` expression should evaluate to a\n    * valid value of the `Option[Int]` type.\n    *\n    * For example `val x = SELF.R4[Int]` expects the\n    * register, if it is present, to have type `Int`. At runtime the corresponding type\n    * descriptor is passed as `implicit t: RType[T]` parameter of `getReg` method and\n    * checked against the actual value of the register.\n    *\n    * There are three cases:\n    * 1) If the register doesn't exist.\n    *   Then `val x = SELF.R4[Int]` succeeds and returns the None value, which conforms to\n    *   any value of type `Option[T]` for any T. (In the example above T is equal to\n    *   `Int`)..."
    },
    {
      "heading": "GroupElement#",
      "content": "/** Base class for points on elliptic curves. */\nclass GroupElement {\n  /** Exponentiate this <code>GroupElement</code> to the given number.\n    * @param k The power.\n    * @return <code>this to the power of k</code>.\n    */\n  def exp(k: BigInt): GroupElement\n\n  /** Group operation. */\n  def multiply(that: GroupElement): GroupElement\n\n  /** Inverse element in the group. */\n  def negate: GroupElement\n\n  /** Get an encoding of the point value.\n    *\n    * @return the point encoding\n    */\n  def getEncoded: Coll[Byte]\n}"
    },
    {
      "heading": "AvlTree#",
      "content": "/** Type of data which efficiently authenticates potentially huge dataset having key-value dictionary interface.\n  * Only root hash of dynamic AVL+ tree, tree height, key length, optional value length, and access flags are stored\n  * in an instance of the datatype.\n  *\n  * Please note that standard hash function from `scorex.crypto.hash` is used, and height is stored along with root hash of\n  * the tree, thus `digest` size is always CryptoConstants.hashLength + 1 bytes.\n  */\nclass AvlTree {\n  /** Returns digest of the state represented by this tree.\n    * Authenticated tree digest = root hash bytes ++ tree height\n    */\n  def digest: Coll[Byte]\n\n  /** Flags of enabled operations packed in single byte.\n    * isInsertAllowed == (enabledOperations & 0x01) != 0\n    * isUpdateAllowed == (enabledOperations & 0x02) != 0\n    * isRemoveAllowed == (enabledOperations & 0x04) != 0\n    */\n  def enabledOperations: Byte\n\n  /** All the elements under the tree have the same length of the keys */\n  def keyLength: Int\n\n  /** If non-empty, all the values under the tree are of the same length. */\n  def valueLengthOpt: Option[Int]\n\n  /** Checks if Insert operation is allowed for this tree instance. */\n  def isInsertAllowed: Boolean\n\n  /** Checks if Update operation is allowed for this tree instance. */\n  def isUpdateAllowed: Boolean\n\n  /** Checks if Remove operation is allowed for this tree instance. */\n  def isRemoveAllowed: Boolean\n\n  /** Replace digest of this tree producing a new tree.\n    * Since AvlTree is immutable, this tree instance remains unchanged.\n    * @param newDigest   a new digest\n    * @return a copy of this AvlTree instance where `this.digest` replaced by\n    *         `newDigest`\n    */\n  def updateDigest(newDigest: Coll[Byte]): AvlTree\n\n  /** Enable/disable operations of this tree producing a new tree.\n    * Since AvlTree is immutable, `this` tree instance remains unchanged.\n    * @param newOperations a new flags which specify available operations on a\n    *         ..."
    },
    {
      "heading": "Option[T]#",
      "content": "/** Represents optional values. Instances of `Option`\n *  are either an instance of `Some(x)` or the value `None`.\n */\nclass Option[A] {\n  /** Returns true if the option is an instance of Some(value), false otherwise. \n   */\n  def isDefined: Boolean;\n\n  /** Returns the option's value if the option is nonempty, otherwise\n    * return the result of evaluating `default`.\n    * NOTE: the `default` is evaluated even if the option contains the value\n    * i.e. not lazily.\n    *\n    * @param default  the default expression.\n    */\n  def getOrElse[B](default: B): B  \n\n  /** Returns the option's value.\n   *  @note The option must be nonempty.\n   *  @throws InterpreterException if the option is empty.\n   */\n  def get: A\n\n  /** Returns a Some containing the result of applying $f to this option's\n   * value if this option is nonempty.\n   * Otherwise return None.\n   *\n   * @note This is similar to `flatMap` except here, $f does not need to wrap its result in an $option.\n   *\n   * @param  f   the function to apply\n   * @since  2.0\n   * @see flatMap\n   */\n  def map[B](f: A => B): Option[B]\n\n\n  /** Returns this option if it is nonempty '''and''' applying the predicate $p to\n   * this option's value returns true. Otherwise, return $none.\n   *\n   * @param  p   the predicate used for testing.\n   * @since  2.0\n   */\n  def filter(p: A => Boolean): Option[A]\n}"
    },
    {
      "heading": "Coll[T]#",
      "content": "/** Indexed (zero-based) collection of elements of type `A` \n  * @tparam A the collection element type\n  */\nclass Coll[A] {\n  /** The number of elements in the collection */\n  def size: Int\n\n  /** The element at given index.\n   *  Indices start at `0`; `xs.apply(0)` is the first element of collection `xs`.\n   *  Note the indexing syntax `xs(i)` is a shorthand for `xs.apply(i)`.\n   *\n   *  @param    i   the index\n   *  @return       the element at the given index\n   *  @throws       ArrayIndexOutOfBoundsException if `i < 0` or `length <= i`\n   */\n  def apply(i: Int): A\n\n  /** The element of the collection or default value. \n   * If an index is out of bounds (`i < 0 || i >= length`) then `default` value is returned.\n   *  @param    i   the index\n   *  @return       the element at the given index or default value if index is out or bounds\n   */\n  def getOrElse(i: Int, default: A): A\n\n  /** Builds a new collection by applying a function to all elements of this collection.\n   *\n   *  @param f      the function to apply to each element.\n   *  @tparam B     the element type of the returned collection.\n   *  @return       a new collection of type `Coll[B]` resulting from applying the given function\n   *                `f` to each element of this collection and collecting the results.\n   */\n  def map[B](f: A => B): Coll[B]\n\n  /** For this collection (x0, ..., xN) and other collection (y0, ..., yM)\n   * produces a collection ((x0, y0), ..., (xK, yK)) where K = min(N, M) \n   */\n  def zip[B](ys: Coll[B]): Coll[(A, B)]\n\n  /** Tests whether a predicate holds for at least one element of this collection.\n   *  @param   p     the predicate used to test elements.\n   *  @return        `true` if the given predicate `p` is satisfied by at least one element of this collection, otherwise `false`\n   */\n  def exists(p: A => Boolean): Boolean\n\n  /** Tests whether a predicate holds for all elements of this collection.\n   *  @param   p   the predicate used to test elements.\n   *  @return      ..."
    },
    {
      "heading": "Predefined global functions#",
      "content": "ErgoScript standard library include predefined functions that can be called \nwithout prior declaration.\nThe following function declarations are automatically imported into any script:\n/** Returns true if all the elements in collection are true. */\ndef allOf(conditions: Coll[Boolean]): Boolean\n\n/** Returns true if at least on element of the conditions is true */\ndef anyOf(conditions: Coll[Boolean]): Boolean\n\n/** Similar to allOf, but performing logical XOR operation instead of `&&` */\ndef xorOf(conditions: Coll[Boolean]): Boolean \n\n/** Returns SigmaProp value which can be ZK proven to be true \n * if at least k properties can be proven to be true. \n */\ndef atLeast(k: Int, properties: Coll[SigmaProp]): SigmaProp\n\n/** Embedding of Boolean values to SigmaProp values. As an example, this\n * operation allows boolean expressions to be used as arguments of\n * `atLeast(..., sigmaProp(myCondition), ...)` operation.\n */\ndef sigmaProp(condition: Boolean): SigmaProp\n\n/** Cryptographic hash function Blake2b256 (See scorex.crypto.hash.Blake2b256) */\ndef blake2b256(input: Coll[Byte]): Coll[Byte]\n\n/** Cryptographic hash function Sha256 (See scorex.crypto.hash.Sha256) */\ndef sha256(input: Coll[Byte]): Coll[Byte]\n\n/** Create BigInt from a collection of bytes. */\ndef byteArrayToBigInt(input: Coll[Byte]): BigInt\n\n/** Create Long from a collection of bytes. */\ndef byteArrayToLong(input: Coll[Byte]): Long  \n\n/** Returns bytes representation of Long value. */\ndef longToByteArray(input: Long): Coll[Byte]\n\n/** Convert bytes representation of group element (ECPoint) \n  * to a new value of GroupElement (using\n  * org.bouncycastle.math.ec.ECCurve.decodePoint())\n  */\ndef decodePoint(bytes: Coll[Byte]): GroupElement \n\n\n/** Extracts Context variable by id and type.\n  * ErgoScript is typed, so accessing a the variables is an operation which involves\n  * some expected type given in brackets. Thus `getVar[Int](id)` expression should\n  * evaluate to a valid value of the `Option[Int]` type.\n  *\n  * For ..."
    },
    {
      "heading": "Examples#",
      "content": "See white paper for examples"
    }
  ],
  "qa_pairs": []
}