{
  "title": "Reusable Functions - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/dev/scs/ergoscript/reusable-functions/",
  "summary": "Yes, the EIP-3 secret functions similarly to an account index for deriving public keys. As confirmed by user 'Aberg (Satergo dev)', the Satergo wallet refers to this as the \"address index,\" and custom indices can be utilized. The decodePoint method is likely what you need to convert proposition bytes (Coll[Byte]) into a SigmaProp. Yes, you can, but be aware that some off-chain code might become confused. The amounts will be merged into a single entry in the box's tokens array.",
  "keywords": [
    "eip-3",
    "function",
    "account",
    "index",
    "user",
    "aberg",
    "satergo",
    "wallet",
    "address",
    "custom",
    "decodepoint",
    "method",
    "proposition",
    "byte",
    "coll[byte",
    "sigmaprop",
    "chain",
    "code",
    "amount",
    "entry",
    "tokens",
    "array",
    "error",
    "transaction",
    "script",
    "utxo",
    "model",
    "concept",
    "java",
    "scala",
    "course",
    "https://docs.ergoplatform.com/dev/get-started/",
    "starting",
    "point",
    "knowledge",
    "ergoscript",
    "building",
    "process",
    "logic",
    "verifie",
    "condition",
    "output",
    "token",
    "sale",
    "service",
    "contract",
    "example",
    "illustration",
    "https://github.com/ergoplatform/ergoscript-by-example/blob/main/tokensalesservice.md",
    "aspect",
    "option",
    "type",
    "value",
    "register",
    "context",
    "variable",
    "getvar[t",
    "workaround",
    "scenario",
    "operation",
    "r4[boolean].map(r",
    "expression",
    "collection",
    "fold",
    "sumfunc(a",
    "long",
    "b.value",
    "totalvalue",
    "inputs.fold(0l",
    "sumfunc",
    "inline",
    "lambda",
    "totalvaluelambda",
    "accum",
    "box.value",
    "parameter",
    "sumgeneric[t](a",
    "structure",
    "totalgeneric",
    "note",
    "upcoming",
    "sigma",
    "inputs.sumby(b",
    "ergotree",
    "fleet",
    "javascript",
    "typescript",
    "representation",
    "target",
    "outputbuilder(safe_min_box_value",
    "some",
    "builder",
    ".setadditionalregister",
    "sconstant(scoll(sbyte",
    "ergoaddress.frombase58(target_script_address).ergotree)).tohex",
    "nanoergs",
    "input",
    "accumulator",
    "sumvalues(accum",
    "inputs",
    "totalnanoergs",
    "sumvalues",
    "hash",
    "const",
    "targetaddress",
    "targetergotreebytes",
    ".setadditionalregisters",
    "targetergotreebytes)).tohex"
  ],
  "sections": [
    {
      "heading": "Debugging Techniques#",
      "content": "Check the versions of dependencies like ergo-lib-wasm-nodejs and ergo-lib-wasm-browser to ensure you have the latest fixes.\nIf an issue is suspected to originate from the Nautilus wallet, try manually replacing the .wasm file in the extension directory with an updated version from sigma-rust.\nBuilding Nautilus from source with updated dependencies can help identify issues.\nWhen encountering issues with on-chain boxes, you can try the following:\nMake temporary contract edits (e.g., set a condition to always evaluate to true).\nCompile the modified contract and obtain the new ErgoTree hex.\nReplace the ErgoTree of the problematic box with the new hex (off-chain).\nAttempt to sign the transaction (this should work locally even if the modified tree wouldn't validate on-chain, helping isolate signing issues).\nFor mocking boxes in unit tests, use the mockUTxO function from @fleet-sdk/mock-chain instead of manually editing box contents."
    },
    {
      "heading": "Is the EIP-3 Secret similar to an account index for derived public keys?#",
      "content": "Yes, the EIP-3 secret functions similarly to an account index for deriving public keys. As confirmed by user 'Aberg (Satergo dev)', the Satergo wallet refers to this as the \"address index,\" and custom indices can be utilized."
    },
    {
      "heading": "How do I convert a Coll[Byte] of proposition bytes to the SigmaProp type?#",
      "content": "The decodePoint method is likely what you need to convert proposition bytes (Coll[Byte]) into a SigmaProp."
    },
    {
      "heading": "Can I insert two tokens with the same ID but different amounts into a box?#",
      "content": "Yes, you can, but be aware that some off-chain code might become confused. The amounts will be merged into a single entry in the box's tokens array."
    },
    {
      "heading": "How do I fix the \"Tree root should be real but was UnprovenSchnorr(ProveDlog(Ecp(...\" error?#",
      "content": "This error usually indicates that the transaction was signed using an incorrect private key (i.e., one that doesn't correspond to the public key expected by the script)."
    },
    {
      "heading": "As a complete coding beginner, should I learn Java then Scala before ErgoScript?#",
      "content": "It's generally recommended to focus on understanding UTXO model concepts first, rather than diving deep into Java or Scala initially. The courses available at https://docs.ergoplatform.com/dev/get-started/ provide a good starting point without requiring prior Java or Scala knowledge."
    },
    {
      "heading": "How are dApp fees handled in ErgoScript contracts?#",
      "content": "In ErgoScript, fees are handled explicitly during the transaction building process, not directly within the script logic itself. The script verifies conditions based on the transaction outputs. See the Token Sale Service contract example for illustration: \nhttps://github.com/ergoplatform/ergoscript-by-example/blob/main/tokenSalesService.md\nKey aspects:\nThe transaction fee (MinTxFee) must be included in one of the output boxes (typically the last one, designated for the miner).\nOther output boxes handle the distribution of payment and token amounts according to the contract's logic.\nThe fee is paid from the value contained within the input boxes being spent."
    },
    {
      "heading": "How can Option/Some(...) be used in ErgoScript outside of registers and context variables?#",
      "content": "The use of Option types (like Some(...)) is effectively limited to values originating from registers (box.R<N>[Type]) and context variables (getVar[T](...)). A potential workaround for other scenarios involves using a \"dummy\" optional register value and applying a map operation: box.R4[Boolean].map(r => <some expression which doesn't depend on r>)."
    },
    {
      "heading": "What's the proper syntax for fold/map/reduce operations in ErgoScript?#",
      "content": "Here are some examples demonstrating common collection operations:\n// Simple sum using fold with an explicitly defined function\ndef sumFunc(a: Long, b: Box): Long = a + b.value\nval totalValue = INPUTS.fold(0L, sumFunc)\n\n// Using fold with an inline lambda function\nval totalValueLambda = INPUTS.fold(0L, { (accum: Long, box: Box) => accum + box.value })\n\n// Declaring a generic function (though type parameter often inferred)\n// def sumGeneric[T](a: T, b: Box): T = ??? // Example structure\n// val totalGeneric = INPUTS.fold(0L, sumGeneric) // Type parameter usually not needed here\n\n// Note: Upcoming Sigma 6.0 might introduce more direct methods like:\n// val total = INPUTS.sumBy(b => b.value)"
    },
    {
      "heading": "How can I store a script hash in a register using Fleet for later comparison?#",
      "content": "To store the bytes of a script (ErgoTree) in a register, allowing an ErgoScript contract to later verify that an output box is protected by that specific script:\n// In your off-chain Fleet code (JavaScript/TypeScript):\n// Create an output box and set register R8 to the hex representation \n// of the target script's ErgoTree bytes.\nnew OutputBuilder(SAFE_MIN_BOX_VALUE, /* Some Address */)  \n  // ... other builder methods\n  .setAdditionalRegisters({\n    R8: SConstant(SColl(SByte, ErgoAddress.fromBase58(TARGET_SCRIPT_ADDRESS).ergoTree)).toHex() \n  });\n// In your ErgoScript contract:\n{\n  // Retrieve the expected script bytes from the register\n  val expectedScriptBytes = SELF.R8[Coll[Byte]].get \n\n  // Get the actual script bytes of an output box\n  val outputBoxScriptBytes = OUTPUTS(0).propositionBytes \n\n  // Verify that the output box uses the expected script\n  expectedScriptBytes == outputBoxScriptBytes\n  // ... other conditions\n}"
    },
    {
      "heading": "Noted Issues#",
      "content": "A bug existed in sigma-rust where coll.slice did not gracefully handle empty collections, differing from the Scala version used in nodes. This caused issues for approximately 3 weeks until fixed by user 'greenhat'. The fix has been merged into the develop branch of sigma-rust.\nThis fix needs to propagate through the dependency tree (including updates to libraries like ergo-lib-wasm and wallets like Nautilus) before fully resolving issues for all end users.\nSome unexpected exceptions have been reported when using .toBigInt on Long register values in ErgoScript. Further investigation is needed.\nWith ErgoNames, if a token representing a registered name is burned, that name registration is permanently lost. Potential solutions are being researched."
    },
    {
      "heading": "Tutorial Code Snippets#",
      "content": "Summing nanoErgs of all inputs:\n// Define a function to add a box's value to an accumulator\ndef sumValues(accum: Long, box: Box): Long = accum + box.value\n// Use fold to apply the sum function across all INPUTS, starting with 0L\nval totalNanoErgs = INPUTS.fold(0L, sumValues)\nStoring a script hash in a register using Fleet:\n// Off-chain code to create an output box storing the target script's hash in R8\nconst targetAddress = \"TARGET_SCRIPT_ADDRESS\"; // Replace with the actual address\nconst targetErgoTreeBytes = ErgoAddress.fromBase58(targetAddress).ergoTree;\n\nnew OutputBuilder(SAFE_MIN_BOX_VALUE, /* Some Address */)\n  .setAdditionalRegisters({ \n    R8: SConstant(SColl(SByte, targetErgoTreeBytes)).toHex() \n  });"
    },
    {
      "heading": "Additional Resources#",
      "content": "ErgoScript Language Specification: https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/docs/LangSpec.md\nErgo Playground/eScript IDE: https://escript.online/"
    }
  ],
  "qa_pairs": []
}