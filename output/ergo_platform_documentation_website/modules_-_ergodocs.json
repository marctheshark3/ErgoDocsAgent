{
  "title": "Modules - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/dev/stack/headless/modules/",
  "summary": "This module exposes the BoxSpec struct, which allows you to create a specification of a UTXO. This is used for defining the boxes which are required for the actions of your protocol. Once you've constructed a BoxSpec, you have a number of essential methods that simplify the experience of writing off-chain code for dApps. For example, verify_box allows you to test whether an ErgoBox you provide as input matches the specification you created with your BoxSpec. This module exposes two traits: All ExplorerFindable structs are also SpecifiedBoxes which are all WrappedBoxes.",
  "keywords": [
    "module",
    "boxspec",
    "struct",
    "specification",
    "utxo",
    "action",
    "protocol",
    "number",
    "method",
    "experience",
    "chain",
    "code",
    "dapps",
    "example",
    "verify_box",
    "ergobox",
    "input",
    "trait",
    "explorerfindable",
    "specifiedboxes",
    "wrappedboxes",
    "specifiedbox",
    "wrappedbox",
    "work",
    "interface",
    "ergoboxes",
    "specifiedboxe",
    "hand",
    "box_spec",
    "ergo",
    "explorer",
    "instance",
    "specified",
    "actions",
    "devs",
    "access",
    "datum",
    "oracle",
    "pool",
    "ergsbox",
    "ergusdoraclepoolbox",
    "adausdoraclepoolbox",
    "ergs",
    "contract",
    "dapp",
    "developer",
    "implementor",
    "pools",
    "wallet",
    "application",
    "rate",
    "block",
    "line",
    "output",
    "user",
    "change",
    "builder",
    "changebox",
    "txfeebox",
    "function",
    "life",
    "unsignedtransaction",
    "encoding",
    "wrapping",
    "value",
    "form",
    "crate",
    "macro",
    "wrapbox",
    "specbox",
    "wasmbox",
    "wasm",
    "support",
    "w_new",
    "w_box_struct"
  ],
  "sections": [
    {
      "heading": "Box Spec#",
      "content": "This module exposes the BoxSpec struct, which allows you to create a specification of a UTXO. This is used for defining the boxes which are required for the actions of your protocol.\n/// A specification which specifies parameters of an `ErgoBox`.\n/// This spec is used as a \"source of truth\" to both verify and find\n/// `ErgoBox`es which match the spec. This is often used for defining\n/// Stages in multi-stage smart contract protocols, but can also be used\n/// to define input boxes for Actions.\n/// All fields are wrapped in `Option`s to allow ignoring specifying\n/// the field.\n#[wasm_bindgen]\n#[derive(Clone)]\npub struct BoxSpec {\n    /// The address of the box\n    address: Option<ErgoAddressString>,\n    /// The allowed range of nanoErgs\n    value_range: Option<Range<NanoErg>>,\n    /// A sorted list of `Constant`s which define registers\n    /// of an `ErgoBox`.\n    /// First element is treated as R4, second as R5, and so on.\n    registers: Vec<Option<Constant>>,\n    /// A sorted list of `TokenSpec`s which define tokens\n    /// of an `ErgoBox`.\n    tokens: Vec<Option<TokenSpec>>,\n    /// An optional predicate which allows for defining custom\n    /// specification logic which gets processed when verifying\n    /// the box.\n    predicate: Option<fn(&ErgoBox) -> bool>,\n}\nOnce you've constructed a BoxSpec, you have a number of essential methods that simplify the experience of writing off-chain code for dApps.\nFor example, verify_box allows you to test whether an ErgoBox you provide as input matches the specification you created with your BoxSpec.\npub fn verify_box(&self, ergo_box: &ErgoBox) -> Result<()> {"
    },
    {
      "heading": "Box Traits#",
      "content": "This module exposes two traits:\nWrappedBox\nSpecifiedBox\nExplorerFindable\nAll ExplorerFindable structs are also SpecifiedBoxes which are all WrappedBoxes. In your off-chain code you will be defining all of your inputs UTXOs to actions as structs that implement SpecifiedBox, while automatically deriving WrappedBox and ExplorerFindable without any extra work.\nWrappedBoxes provide a simplified interface for interacting with ErgoBoxes. SpecifiedBoxes on the other hand specify that a given WrappedBox also implements a BoxSpec via the box_spec() method. And lastly ExplorerFindable provides an interface on top of the SpecifiedBox trait for finding boxes that match the BoxSpec from an Ergo Explorer API instance."
    },
    {
      "heading": "Specified Boxes#",
      "content": "This module exposes generic \"Specified Box\" structs that implement the SpecifiedBox/WrappedBox/ExplorerFindable traits. These boxes can be used as inputs for Actions in your off-chain protocol code, while also enabling front-end devs to easily gain access to on-chain data, such as Oracle Pool data.\nCurrently Implemented Specified Boxes:\n1. ErgsBox\n2. ErgUsdOraclePoolBox\n3. AdaUsdOraclePoolBox\nErgsBox are used for acquiring inputs that hold Ergs inside of them which can be used within your smart contract protocol actions.\nErgUsdOraclePoolBox & AdaUsdOraclePoolBox provide an extremely simplified interface for both headless dApp developers as well as front-end implementors to utilize data from the two currently running Oracle Pools. These two specified boxes can even be used by wallets/any off-chain application that needs to read the current rates from the Oracle Pool boxes.\nThe code block below shows how in 4 lines you can read the current Erg-USD oracle pool rate from your preferred Ergo Explorer API instance:\nlet url = ErgUsdOraclePoolBox::explorer_endpoint(\"https://api.ergoplatform.com/api\").unwrap();\nlet response = get(&url).unwrap().text().unwrap();\nlet oracle_pool_box =\n    ErgUsdOraclePoolBox::process_explorer_response(&response).unwrap()[0].clone();\nprintln!(\n    \"Erg-USD Oracle Pool: {} nanoErgs per USD\",\n    oracle_pool_box.datapoint()\n);"
    },
    {
      "heading": "Output Builders#",
      "content": "This module exposes structs which provide you with a basic interface\nfor creating common output UTXOs within your Actions. These are often\nused for creating outputs that hold a user's change or pay a tx fee.\nExample Output Builders:\n1. ChangeBox\n2. TokensChangeBox\n3. TxFeeBox"
    },
    {
      "heading": "Tx Creation#",
      "content": "This module exposes a few basic functions for making your life easier when building UnsignedTransactions inside of your Actions."
    },
    {
      "heading": "Encoding#",
      "content": "This module exposes a number of helpful functions related to encoding/decoding/wrapping/unwrapping values from one form into another.\nExamples:\npub fn erg_to_nano_erg(erg_amount: f64) -> u64;\npub fn nano_erg_to_erg(nanoerg_amount: u64) -> f64;\npub fn unwrap_long(c: &Constant) -> Result<i64>;\npub fn serialize_p2s_from_ergo_tree(ergo_tree: ErgoTree) -> P2SAddressString;"
    },
    {
      "heading": "Procedural Macros#",
      "content": "This crate exposes three procedural macros to make the life of devs much simpler:\nWrapBox\nSpecBox\nWASMBox\nWrapBox simply implements the WrappedBox trait for you, SpecBox implements a customized new() method that uses your BoxSpec + implements the ExplorerFindable trait for you, and WASMBox implements the two basic required methods to enable WASM support for your struct (w_new() and w_box_struct())."
    }
  ],
  "qa_pairs": []
}