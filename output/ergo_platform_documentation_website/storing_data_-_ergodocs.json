{
  "title": "Storing Data - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/dev/scs/ergoscript/storing-data/",
  "summary": "ErgoScript, the language used in the Ergo blockchain, provides two primary methods for data storage. The first method involves the use of registers during the creation of a box. The second method utilizes context variables when a box is being spent. For the purpose of this discussion, we will concentrate on the use of registers. An Ergo box is equipped with ten registers, labeled from R0 to R9.",
  "keywords": [
    "ergoscript",
    "language",
    "ergo",
    "blockchain",
    "method",
    "datum",
    "storage",
    "register",
    "creation",
    "context",
    "variable",
    "purpose",
    "discussion",
    "protocol",
    "below",
    "example",
    "code",
    "snippet",
    "line",
    "self.r4[groupelement",
    "option[groupelement",
    "type",
    "option",
    "semantic",
    "scala",
    "self.r4",
    "groupelement",
    "branch",
    "statement"
  ],
  "sections": [
    {
      "heading": "Data Storage in ErgoScript#",
      "content": "ErgoScript, the language used in the Ergo blockchain, provides two primary methods for data storage. The first method involves the use of registers during the creation of a box. The second method utilizes context variables when a box is being spent. For the purpose of this discussion, we will concentrate on the use of registers.\nAn Ergo box is equipped with ten registers, labeled from R0 to R9. The protocol reserves the first four registers (R0 through R3). The remaining six registers (R4 through R9) are available for data storage and are initially empty. It's important to note that you cannot have an empty register between two filled registers.\nBelow is an example demonstrating how registers can be used in ErgoScript:\n{\n   val r4 = SELF.R4[GroupElement]\n   if (r4.isDefined) {\n      val x = r4.get\n      proveDlog(x) \n   } else {\n      proveDlog(decodePoint(fromBase64(\"AlCGOtZKh66KL+g8GvGoQDy1P1PkhthRHa2KBIh+WyNS\")))\n   } \n}\nIn this code snippet, the line SELF.R4[GroupElement] returns an Option[GroupElement] type. The Option type semantics in ErgoScript are identical to those in Scala. If the Option is defined\u00e2\u0080\u0094meaning SELF.R4 does contain a GroupElement type\u00e2\u0080\u0094then the first branch of the if statement is executed. Otherwise, if Option is undefined, the second branch is executed."
    }
  ],
  "qa_pairs": []
}