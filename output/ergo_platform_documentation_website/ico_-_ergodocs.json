{
  "title": "ICO - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/dev/scs/tx/ico/",
  "summary": "Another popular use case on Ethereum is an Initial Coin Offering (ICO) contract. An ICO mirrors an Initial Public Offering (IPO), providing a mechanism for a project to collect funding (often in stablecoins or the platform's native token) and then issue project \"shares\" (in the form of new tokens) to investors. Generally, an ICO comprises 3 stages: This example ICO contract is quite complex compared to previous examples as it involves multiple stages and parties. The number of investors might run into the thousands. A naive solution, similar to some approaches on account-based models like the ERC-20 standard on Ethereum, might attempt to store all investor data directly within the contract state.",
  "keywords": [
    "case",
    "ethereum",
    "initial",
    "coin",
    "offering",
    "contract",
    "mirror",
    "public",
    "mechanism",
    "project",
    "funding",
    "stablecoin",
    "platform",
    "token",
    "share",
    "form",
    "investor",
    "stage",
    "example",
    "party",
    "number",
    "thousand",
    "solution",
    "approach",
    "account",
    "model",
    "erc-20",
    "standard",
    "datum",
    "state",
    "ergo",
    "dataset",
    "structure",
    "tree",
    "digest",
    "byte",
    "avltree",
    "root",
    "hash",
    "value",
    "dictionary",
    "element",
    "spending",
    "transaction",
    "proof",
    "lookup",
    "modification",
    "chain",
    "storage",
    "script",
    "register",
    "amount",
    "pair",
    "p2pk",
    "period",
    "investment",
    "input",
    "contribution",
    "withdrawal",
    "verifie",
    "output",
    "ergs",
    "block",
    "height",
    "issuancescript",
    "data",
    "action",
    "updates",
    "flags",
    "operation",
    "insert",
    "removal",
    "enabledoperation",
    "flag",
    "avltreedata",
    "verifies",
    "issuance",
    "supply",
    "total",
    "self.value",
    "transition",
    "withdrawscript",
    "checks",
    "outputs(1",
    "address",
    "projectpubkeyhash",
    "process",
    "batch",
    "self",
    "entry",
    "boxes",
    "context",
    "variable",
    "lookupproof",
    "existence",
    "removeproof",
    "simplification",
    "instance",
    "logic",
    "destruction",
    "cleanup",
    "comet",
    "thecomettoken.com/ico"
  ],
  "sections": [
    {
      "heading": "ICO",
      "content": "Another popular use case on Ethereum is an Initial Coin Offering (ICO) contract. An ICO mirrors an Initial Public Offering (IPO), providing a mechanism for a project to collect funding (often in stablecoins or the platform's native token) and then issue project \"shares\" (in the form of new tokens) to investors.\nGenerally, an ICO comprises 3 stages:\nFunding: During this period, investors are allowed to fund the project.\nIssuance: A new asset token is created and issued to investors.\nWithdrawal: Investors can withdraw their newly issued tokens.\nThis example ICO contract is quite complex compared to previous examples as it involves multiple stages and parties. The number of investors might run into the thousands. A naive solution, similar to some approaches on account-based models like the ERC-20 standard on Ethereum, might attempt to store all investor data directly within the contract state.\nUnlike Ethereum, Ergo contracts cannot store arbitrarily large datasets directly. Instead, Ergo utilizes authenticated data structures like AVL trees. We store only a compact digest (e.g., ~33 bytes for an AvlTree) representing the root hash and state of a potentially vast (key, value) dictionary. To access or modify elements in the dictionary, a spending transaction must provide cryptographic proofs (lookup or modification proofs). This allows a contract to authenticate large datasets using very little on-chain storage."
    },
    {
      "heading": "Funding#",
      "content": "The project initiates the ICO by creating a box guarded by the script shown below. This initial box also contains, in its R5 register, the authenticated digest of an empty dictionary intended to store (investor PK hash, invested amount) pairs. Here, an \"investor PK hash\" refers to the hash of the script (typically a standard P2PK script) that will guard the box containing the investor's withdrawn ICO tokens after the funding period ends.\n// check if the index of the current input is 0\nval selfIndexIsZero = INPUTS(0).id == SELF.id\n\n// get the AVL tree proof from a register\nval proof = getVar[Coll[Byte]](1).get\n\n// collect pk and value of all inputs, except for the first one\nval toAdd = INPUTS.slice(1, INPUTS.size).map({(b: Box) =>\n    val pk = b.R4[Coll[Byte]].get\n    val value = longToByteArray(b.value)\n    (pk, value)\n})\n\n// insert the collected inputs into the AVL tree, using the proof\nval modifiedTree = SELF.R5[AvlTree].get.insert(toAdd, proof).get\n\n// get the expected AVL tree from the first output\nval expectedTree = OUTPUTS(0).R5[AvlTree].get\n\n// check if the self output is correct by comparing the script\n// if the current height is less than 2000, compare the script to the current box\n// otherwise, compare the script to the issuance script\nval selfOutputCorrect =\n    if (HEIGHT < 2000) OUTPUTS(0).propositionBytes == SELF.propositionBytes\n    else OUTPUTS(0).propositionBytes == issuanceScript\n\n// check if there is only one output and if the self output is correct\nval outputsCorrect = OUTPUTS.size == 1 && selfOutputCorrect\n\n// check if the index is 0, outputs are correct, and the expected tree matches the modified tree\nselfIndexIsZero && outputsCorrect && modifiedTree == expectedTree\nThe first funding transaction spends this initial box and creates a new box containing the same script but with an updated dictionary digest in R5 reflecting the first investment. Subsequent funding transactions spend the box created by the previous funding transaction. The script e..."
    },
    {
      "heading": "Issuance#",
      "content": "This stage involves a single transaction to transition to the withdrawal stage. The spending transaction performs the following actions, verified by the issuanceScript:\n1.  Updates AVL Tree Flags: It changes the allowed operations on the dictionary from \"inserts only\" to \"removals only\" by updating the enabledOperations flag in the AvlTreeData.\n2.  Verifies Token Issuance: It checks that the correct amount of ICO tokens are issued. In Ergo, a transaction can issue a new token, whose ID is determined by the ID of the first input box. The issuanceScript verifies that a new token (with this ID) is created in the first output box (OUTPUTS(0)) with a total supply equal to the total nanoErgs collected during the funding stage (SELF.value).\n3.  Transitions to Withdrawal Script: It ensures the output box (OUTPUTS(0)) containing the tokens and the dictionary digest is protected by the withdrawScript for the next stage.\n4.  Checks Outputs: It verifies that the transaction has exactly two outputs: OUTPUTS(0) (the main contract box for the withdrawal stage) and OUTPUTS(1) (a box sending the collected Ergs to the project's designated address, identified by projectPubKeyHash).\nThe complete issuanceScript is shown below.\n// Get the open and closed trees\nval openTree = SELF.R5[AvlTree].get\nval closedTree = OUTPUTS(0).R5[AvlTree].get\n\n// Check that the digests, key lengths and values are the same\nval correctDigest = openTree.digest == closedTree.digest\nval correctKeyLength = openTree.keyLength == closedTree.keyLength\nval correctValue = openTree.valueLengthOpt == closedTree.valueLengthOpt\n\n// Check that the closed tree is a remove-only tree\nval removeOnlyTree = closedTree.enabledOperations == 4\n\n// Check that the token IDs and amounts are correct\nval tokenId: Coll[Byte] = INPUTS(0).id\nval tokenIssued = OUTPUTS(0).tokens(0)._2\nval correctTokenNumber = OUTPUTS(0).tokens.size == 1 && OUTPUTS(1).tokens.size == 0\nval correctTokenIssued = SELF.value == tokenIssued\nval correctTokenId = OUTP..."
    },
    {
      "heading": "Withdrawal#",
      "content": "Investors can now withdraw their allocated ICO tokens. The withdrawal process typically happens in batches. A withdrawal transaction spends the current ICO box (SELF) and creates N + 1 outputs:\n*   OUTPUTS(0): The new ICO box, containing the remaining tokens and the updated dictionary digest (with withdrawn entries removed). It is protected by the same withdrawScript.\n*   OUTPUTS(1) to OUTPUTS(N): Boxes sent to the withdrawing investors. Each box is protected by the investor's script (whose hash was stored as the key in the dictionary) and contains the corresponding amount of ICO tokens.\nThe withdrawScript requires two AVL tree proofs provided in context variables:\n1.  lookupProof: Proves the existence and amounts associated with the investor keys being withdrawn.\n2.  removeProof: Proves that these investor entries have been correctly removed from the dictionary, resulting in the updated dictionary digest found in OUTPUTS(0).\nThe complete withdrawScript is shown below:\n// Get removeProof and lookupProof\nval removeProof = getVar[Coll[Byte]](2).get\nval lookupProof = getVar[Coll[Byte]](3).get\n\n// Get withdraw indexes and tokenId\nval withdrawIndexes = getVar[Coll[Int]](4).get\nval tokenId: Coll[Byte] = SELF.R4[Coll[Byte]].get\n\n// Map over withdrawIndexes and find tokenIds\nval withdrawals = withdrawIndexes.map({(idx: Int) =>\n    val b = OUTPUTS(idx)\n    if (b.tokens(0)._1 == tokenId)\n        (blake2b256(b.propositionBytes), b.tokens(0)._2)\n    else\n        (blake2b256(b.propositionBytes), 0L)\n    })\n\n// Get withdrawValues and calculate the total amount withdrawn\nval withdrawValues = withdrawals.map({(t: (Coll[Byte], Long)) => t._2})\nval total = withdrawValues.fold(0L, {(l1: Long, l2: Long) => l1 + l2 })\n\n// Get list of nodes to remove and removed values\nval toRemove = withdrawals.map({(t: (Coll[Byte], Long)) => t._1})\nval initialTree = SELF.R5[AvlTree].get\nval removedValues = initialTree.getMany(toRemove, lookupProof).map(\n    {(o: Option[Coll[Byte]]) => byteArrayToLong(o..."
    },
    {
      "heading": "Comet Refundable ICO#",
      "content": "Comet has a refundable ICO live at thecomettoken.com/ICO\nThe contract used is provided:\n{\n  // Receipt Tokens held in Contract\n  val receiptTokens = SELF.tokens(0)._2\n  // Comet Held in Contract\n  val cometTokens = SELF.tokens(1)._2\n  // Receipt Token Id\n  val receiptId = fromBase58(\"5HWxQHyjjVFNEWtswcc71922Bq84LsmtMbgEG5eNxAKZ\")\n  // Comet Token Id\n  val cometId = fromBase58(\"s9d3vUc6AhNAPZhxnGXCitQFqdAXN6X7gXT3h9GupWE\")\n  // Swap Price\n  val amountToSwap = 15 * (OUTPUTS(0).value - SELF.value) / 100000\n  // Refund Price\n  val amountToRefund = 15 * (SELF.value - OUTPUTS(0).value) / 100000\n\n  // Conditions that are always true\n  val alwaysTrue = allOf(Coll(\n    OUTPUTS(0).propositionBytes == SELF.propositionBytes, // OUTPUT(0) is contract box\n    OUTPUTS(0).R4[Coll[Byte]].get == SELF.id, // Protect against spending two contract boxes of same value in 1 tx.\n    OUTPUTS(0).tokens(0)._1 == receiptId // Contract always holds receipt tokens\n  ))\n\n  // Conditions that depend on spending action\n  val conditionals = if (OUTPUTS(0).value > SELF.value) { // Purchase comet condition\n    allOf(Coll(\n      OUTPUTS(0).tokens(0)._2 >= receiptTokens - amountToSwap, // Unlock value amount of receipt for spending\n      OUTPUTS(0).tokens(1)._1 == cometId,\n      OUTPUTS(0).tokens(1)._2 >= cometTokens - amountToSwap // Unlock value amount of comet for spending\n    ))\n  } else { // Refund comet condition\n    allOf(Coll(\n      OUTPUTS(0).tokens(0)._2 >= receiptTokens + amountToRefund, // Unlock receipt amount of Erg for spending\n      OUTPUTS(0).tokens(1)._1 == cometId,\n      OUTPUTS(0).tokens(1)._2 >= cometTokens + amountToRefund // Unlock comet amount of Erg for spending\n    ))\n  }\n\n  val drainAddressConditions = allOf(Coll(\n    OUTPUTS(0).value == SELF.value,\n    OUTPUTS(0).tokens(0)._2 == receiptTokens, // Cannot withdraw receipt tokens\n    OUTPUTS(0).tokens(1)._1 == cometId,\n    OUTPUTS(0).tokens(1)._2 >= 1 // Free up all comet\n  ))\n\n  val addFunds = alwaysTrue && allOf(Coll(\n    OUTP..."
    }
  ],
  "qa_pairs": []
}