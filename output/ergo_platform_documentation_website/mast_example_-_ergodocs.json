{
  "title": "MAST Example - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/dev/scs/tx/mast-example/",
  "summary": "Merkleized Abstract Syntax Trees (MAST) are a technique used in blockchain protocols to improve privacy and efficiency for complex smart contracts with multiple spending conditions. Instead of revealing the entire contract script when spending, MAST allows revealing only the specific condition (script branch) that was actually met and proving its inclusion in the original set of conditions. Imagine a contract with several possible ways it can be spent: Traditionally, the entire script containing all these conditions would be stored in the box's propositionBytes. When spending, the whole script is evaluated, revealing all possible spending paths. With MAST:\n1.",
  "keywords": [
    "merkleized",
    "abstract",
    "syntax",
    "trees",
    "mast",
    "technique",
    "protocol",
    "privacy",
    "efficiency",
    "contract",
    "spending",
    "condition",
    "script",
    "branch",
    "inclusion",
    "propositionbyte",
    "path",
    "fragment",
    "ergotree",
    "byte",
    "representation",
    "coll[byte",
    "blake2b256",
    "hash",
    "leave",
    "merkle",
    "tree",
    "root",
    "locking",
    "constant",
    "lock",
    "scriptbyte",
    "proof",
    "merkleproof",
    "blake2b256(scriptbyte",
    "leaf",
    "data",
    "context",
    "variable",
    "signature",
    "execution",
    "graph",
    "b[hash",
    "c[hash",
    "alice",
    "spend",
    "e1[hash",
    "f1[hash",
    "timelock",
    "g1[hash",
    "multisig",
    "style",
    "fill:#f9f",
    "stroke:#333,stroke",
    "width:2px",
    "fill:#bbf",
    "fill:#bfb",
    "fill:#fbf",
    "commit",
    "fill:#afa",
    "subgraph",
    "chain",
    "alicescriptbytes[\"alice",
    "bytes",
    "getvar[0",
    "getvar[1",
    "proofpositions[\"proof",
    "positions",
    "getvar[2",
    "sibling",
    "example",
    "core",
    "logic",
    "self.r4[coll[byte]].get",
    "providedscriptbyte",
    "getvar[coll[byte]](0).getorelse(coll[byte",
    "getvar[coll[coll[byte]]](1).getorelse(coll[coll[byte",
    "position",
    "proofposition",
    "leafhash",
    "blake2b256(providedscriptbyte",
    "verification",
    "helper",
    "function",
    "implementation",
    "assume",
    "verifymerkleproof",
    "sigmaprop",
    "spendingcondition",
    "execute",
    "conceptual",
    "testing",
    "scope",
    "extension",
    "verifymerkleproof(root",
    "length",
    "currenthash",
    "proof.fold(leaf",
    "proofelement",
    "positions(i",
    "element",
    "blake2b256(h",
    "world",
    "handling",
    "edge",
    "case",
    "optimization",
    "ergoscript",
    "setup",
    "define",
    "compile",
    "conditions",
    "ergo",
    "appkit",
    "scala",
    "import",
    "scorex.crypto.hash",
    "scorex.util",
    "bytearray",
    "alicepk",
    "bobpk",
    "string",
    "alicespendscript",
    "provedlog(alicepk",
    "bobspendscript",
    "provedlog(bobpk",
    "timelockscript",
    "height",
    "blockchaincontext",
    "alicebyte",
    "alicepk).build",
    "bobbytes",
    "bobpk).build",
    "bobspendscript).getergotree.byte",
    "timelockbyte",
    "ctx.compilecontract(constantsbuilder.empty",
    "timelockscript).getergotree.byte",
    "build",
    "hashalice",
    "blake2b256.hash(alicebytes",
    "hashbob",
    "blake2b256.hash(bobbytes",
    "hashtimelock",
    "blake2b256.hash(timelockbytes",
    "library",
    "replace",
    "usage",
    "merkletree.build(seq(hashalice",
    "merkleroot",
    "array[byte",
    "create",
    "mastcontract",
    "rest",
    "blake2b256(getvar[coll[byte]](0).get",
    "getvar[coll[coll[byte]]](1).get",
    "getvar[coll[byte]](2).get",
    "executefromvar[sigmaprop](0",
    "1000000l",
    "outbox",
    ".value(boxvalue",
    "store",
    "transaction",
    "prep",
    "tree.getproofforleaf(hashalice",
    "generate",
    "proofhashe",
    "seq[array[byte",
    "contextvar",
    "contextvar(0.tobyte",
    "ergovalue.of(chosenconditionbytes",
    "contextvar(1.tobyte",
    "ergovalue.of(proofhashes.map(ergovalue.of).toarray",
    "ergotype.colltype(ergotype.colltype(ergotype.bytetype",
    "contextvar(2.tobyte",
    "ergovalue.of(proofpositions",
    "input",
    "unsignedtx",
    "txbuilder",
    "signedtx",
    "prover.sign(unsignedtx",
    "concept",
    "finite",
    "state",
    "machines",
    "fsms",
    "design",
    "preparation",
    "step",
    "generation",
    "creation"
  ],
  "sections": [
    {
      "heading": "Tutorial: Merkleized Abstract Syntax Trees (MAST) in Ergo#",
      "content": "Merkleized Abstract Syntax Trees (MAST) are a technique used in blockchain protocols to improve privacy and efficiency for complex smart contracts with multiple spending conditions. Instead of revealing the entire contract script when spending, MAST allows revealing only the specific condition (script branch) that was actually met and proving its inclusion in the original set of conditions."
    },
    {
      "heading": "Concept#",
      "content": "Imagine a contract with several possible ways it can be spent:\nCondition A: Alice can spend after time T1.\nCondition B: Bob can spend if he provides a secret value X.\nCondition C: Alice and Bob can spend together anytime.\nTraditionally, the entire script containing all these conditions would be stored in the box's propositionBytes. When spending, the whole script is evaluated, revealing all possible spending paths.\nWith MAST:\n1.  Each condition (A, B, C) is treated as a separate script fragment.\n2.  These fragments are serialized to their ErgoTree byte representation (Coll[Byte]).\n3.  Each byte representation is hashed (e.g., using blake2b256).\n4.  These hashes are arranged as leaves in a Merkle Tree.\n5.  The Merkle root of this tree is calculated and stored in the main locking script of the box (often as a constant).\nThe locking script essentially says: \"This box can be spent if you provide:\n1.  A specific script fragment (scriptBytes).\n2.  A Merkle proof (merkleProof) demonstrating that blake2b256(scriptBytes) is a valid leaf within the Merkle tree whose root is expectedMerkleRoot.\n3.  Data (context variables, signatures, etc.) that satisfies the execution of the provided scriptBytes.\""
    },
    {
      "heading": "Visual Representation#",
      "content": "graph TD\n    A[Root Hash] --> B[Hash of (Hash A + Hash B)]\n    A --> C[Hash of (Hash C + Hash D)]\n    B --> D1[Hash A (Alice Spend)]\n    B --> E1[Hash B (Bob Spend)]\n    C --> F1[Hash C (Timelock)]\n    C --> G1[Hash D (Multisig)]\n\n    style D1 fill:#f9f,stroke:#333,stroke-width:2px\n    style E1 fill:#bbf,stroke:#333,stroke-width:2px\n    style F1 fill:#bfb,stroke:#333,stroke-width:2px\n    style G1 fill:#fbf,stroke:#333,stroke-width:2px\nThe Merkle Root (A) commits to all possible spending conditions (leaves).\nWhen spending using Alice's condition (Hash A), only the necessary path needs to be revealed:\ngraph TD\n    A[Root Hash] --> B[Hash of (Hash A + Hash B)]\n    A --> C[Hash C - Provided in Proof]\n    B --> D1[Hash A (Alice Spend)]\n    B --> E1[Hash B - Provided in Proof]\n\n    style A fill:#afa,stroke:#333,stroke-width:2px\n    style B fill:#afa,stroke:#333,stroke-width:2px\n    style D1 fill:#afa,stroke:#333,stroke-width:2px\n    style C fill:#bbf,stroke:#333,stroke-width:2px\n    style E1 fill:#bbf,stroke:#333,stroke-width:2px\n\n    subgraph Revealed On-Chain\n        A\n        B\n        D1\n        AliceScriptBytes[\"Alice's Script Bytes (getVar[0])\"]\n    end\n    subgraph Provided in Proof \"(getVar[1])\"\n        C\n        E1\n        ProofPositions[\"Proof Positions (getVar[2])\"]\n    end\n\n    AliceScriptBytes -->|blake2b256| D1\nOnly Alice's script bytes and the sibling hashes (E1, C) needed to reconstruct the root are revealed."
    },
    {
      "heading": "Benefits#",
      "content": "Privacy: Only the executed spending condition is revealed on-chain. Unused conditions remain hidden.\nEfficiency: Smaller on-chain footprint for the main locking script (just the root hash). Validation cost can be lower if the executed branch is simple, though Merkle proof verification adds overhead.\nScalability: Allows for contracts with a very large number of potential conditions without making the base script excessively large or complex."
    },
    {
      "heading": "Comparison: Traditional vs. MAST Execution#",
      "content": "Aspect\nTraditional Script\nMAST-based Execution\n\n\n\n\nPrivacy\nAll conditions visible on-chain\nOnly used condition revealed\n\n\nScript Size\nFull script stored on-chain\nOnly Merkle root stored on-chain\n\n\nExecution Cost\nEvaluates potentially complex script\nVerifies proof + Evaluates simple branch\n\n\nComplexity Limit\nLimited by practical script size/cost\nCan support many conditions\n\n\nImplementation\nStraightforward ErgoScript\nRequires off-chain prep + proof logic\n\n\nSecurity\nDirect script validation\nRequires proper Merkle proof verification"
    },
    {
      "heading": "ErgoScript MAST Example (with Proof Verification)#",
      "content": "This example demonstrates the core on-chain logic using context variables to receive the script branch and its Merkle proof.\n{\n  // Merkle root of all possible spending conditions (calculated off-chain)\n  // This would typically be embedded as a constant in the script\n  val merkleRoot = SELF.R4[Coll[Byte]].get // Example: Get root from R4\n\n  // Context variable 0: The specific spending script bytes being executed\n  val providedScriptBytes = getVar[Coll[Byte]](0).getOrElse(Coll[Byte]()) \n\n  // Context variable 1: The Merkle proof (sibling hashes)\n  val merkleProof = getVar[Coll[Coll[Byte]]](1).getOrElse(Coll[Coll[Byte]]()) \n\n  // Context variable 2: The positions of sibling hashes (0 for left, 1 for right)\n  val proofPositions = getVar[Coll[Byte]](2).getOrElse(Coll[Byte]())\n\n  // Hash the provided script to get the leaf hash\n  val leafHash = blake2b256(providedScriptBytes)\n\n  // --- Merkle Proof Verification Logic ---\n  // (Simplified helper function - real implementation might be more complex/optimized)\n  // Assumes 'verifyMerkleProof' takes root, leaf, proof, positions and returns Boolean\n  val proofIsValid = verifyMerkleProof(merkleRoot, leafHash, merkleProof, proofPositions)\n  // --- End Merkle Proof Verification ---\n\n  // If the proof is valid, execute the provided script fragment\n  // The script fragment itself should return SigmaProp\n  val spendingCondition = if (proofIsValid) {\n    executeFromVar[SigmaProp](0) // Execute script from context variable 0\n  } else {\n    sigmaProp(false) // Proof invalid, reject\n  }\n\n  spendingCondition\n}\n\n// --- Helper Function (Conceptual - Needs careful implementation/testing) ---\n// This function would need to be defined within the script scope or \n// potentially made available via context extension or future built-ins.\ndef verifyMerkleProof(root: Coll[Byte], leaf: Coll[Byte], proof: Coll[Coll[Byte]], positions: Coll[Byte]): Boolean = {\n  // Basic check for consistent proof/position lengths\n  if (proof.size != positions.size) ..."
    },
    {
      "heading": "Practical Implementation Steps (Off-Chain)#",
      "content": "The setup for MAST happens off-chain before creating the box locked by the MAST script.\nDefine & Compile Conditions:\n// Using Ergo's AppKit (Scala Example)\nimport org.ergoplatform.appkit._\nimport scorex.crypto.hash.Blake2b256\nimport scorex.utils.ByteArray\n\nval alicePk = prover.getP2PKAddress.pubkey // Get Alice's public key\nval bobPk = ... // Get Bob's public key\n\n// Define spending conditions as ErgoScript strings\nval aliceSpendScript = s\"{ proveDlog(alicePk) }\"\nval bobSpendScript = s\"{ proveDlog(bobPk) }\"\nval timelockScript = s\"{ HEIGHT > 100000 }\"\n\n// Compile scripts to ErgoTree bytes using BlockchainContext (ctx)\nval aliceBytes = ctx.compileContract(ConstantsBuilder.create().item(\"alicePk\", alicePk).build(), aliceSpendScript).getErgoTree.bytes\nval bobBytes = ctx.compileContract(ConstantsBuilder.create().item(\"bobPk\", bobPk).build(), bobSpendScript).getErgoTree.bytes\nval timelockBytes = ctx.compileContract(ConstantsBuilder.empty(), timelockScript).getErgoTree.bytes\n\n\n\nBuild Merkle Tree:\n// Hash each condition's ErgoTree bytes\nval hashAlice = Blake2b256.hash(aliceBytes)\nval hashBob = Blake2b256.hash(bobBytes)\nval hashTimelock = Blake2b256.hash(timelockBytes)\n\n// Use a Merkle Tree library (conceptual - replace with actual library usage)\n// Example: val tree = MerkleTree.build(Seq(hashAlice, hashBob, hashTimelock))\n// val merkleRoot: Array[Byte] = tree.rootHash \nval merkleRoot: Array[Byte] = ??? // Calculate the root hash\n\n\n\nCreate MAST Box:\n// Embed the Merkle Root, e.g., in R4\nval mastContract = ctx.compileContract(ConstantsBuilder.empty(), \"\"\"\n  {\n    val expectedRoot = SELF.R4[Coll[Byte]].get \n    // ... rest of MAST verification script from above ... \n    verifyMerkleProof(expectedRoot, blake2b256(getVar[Coll[Byte]](0).get), getVar[Coll[Coll[Byte]]](1).get, getVar[Coll[Byte]](2).get) &&\n    executeFromVar[SigmaProp](0)\n  }\n\"\"\")\n\nval boxValue = 1000000L // 0.001 ERG\nval outBox = txBuilder.outBoxBuilder()\n  .value(boxValue)\n  .contract(mastContract)\n  .registers(..."
    },
    {
      "heading": "Security Considerations#",
      "content": "Merkle Proof Verification: The on-chain script must correctly and completely verify the provided Merkle proof against the expected root hash. The verifyMerkleProof example above is simplified; a robust implementation is crucial. Without proper verification, an attacker could provide arbitrary script bytes and bypass the intended logic.\nScript Execution: Ensure executeFromVar is only called after the Merkle proof is successfully verified.\nContext Variable Indices: Use distinct and well-defined indices for context variables (getVar, executeFromVar) to avoid collisions or unintended data access.\nGas Costs: Verifying Merkle proofs on-chain consumes computational resources and increases transaction fees. Optimize proof verification logic or consider patterns where verification is minimized.\nOff-Chain Security: The process of generating the Merkle tree, calculating the root, and generating proofs for spending must be secure and correct off-chain."
    },
    {
      "heading": "Merkleized Finite State Machines (MFSMs)#",
      "content": "The MAST concept can be combined with Finite State Machines (FSMs) for complex multi-stage contracts:\nState Transitions as Branches: Each possible state transition logic in an FSM can be represented as a separate script branch in a Merkle tree.\nImplementation Pattern: The main contract box stores the current FSM state identifier (e.g., in R4) and the Merkle root of all possible state transition scripts. To transition, the spender provides the specific transition script bytes and its Merkle proof via context variables. The main script verifies the proof and then uses executeFromVar to run the transition script, which validates the state change (e.g., checks INPUTS(0).R4 vs OUTPUTS(0).R4).\nBenefits: Allows complex FSMs without revealing all possible states and transitions on-chain, enhancing privacy and potentially reducing on-chain script size."
    },
    {
      "heading": "Resources & Examples#",
      "content": "Specifications in sigmastate-interpreter:\nMASTExampleSpecification.scala: Provides Scala code demonstrating MAST concepts in a testing context.\n\n\nRelated Primitives:\nContext Extension (getVar, executeFromVar)\nRegister Execution (executeFromSelfReg)\n\n\nConceptual Docs:\nMerkle Trees\nImplementing MAST securely requires careful design of both the on-chain verification script and the off-chain preparation steps (tree generation, proof creation)."
    }
  ],
  "qa_pairs": []
}