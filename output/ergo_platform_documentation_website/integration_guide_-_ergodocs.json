{
  "title": "Integration Guide - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/dev/Integration/guide/",
  "summary": "This guide provides developers with the necessary information to integrate with the Ergo Blockchain Platform. For suggestions to improve this guide, please reach out to us at team@ergoplatform.org or join our #development channel on Discord. For the best performance, we advise you to run your own node. If that's not feasible, you can use a public node available at 213.239.193.208:9053. For backup options, feel free to reach out to us at team@ergoplatform.org or join our group chat.",
  "keywords": [
    "guide",
    "developer",
    "information",
    "ergo",
    "blockchain",
    "platform",
    "suggestion",
    "team@ergoplatform.org",
    "development",
    "channel",
    "discord",
    "performance",
    "node",
    "option",
    "group",
    "chat",
    "list",
    "api.tokenjay.app/peers/list",
    "interface",
    "127.0.0.1:9053",
    "panel",
    "port",
    "testnet",
    "guidance",
    "page",
    "amount",
    "disk",
    "space",
    "factor",
    "size",
    "number",
    "transaction",
    "operation",
    "setup",
    "utxo",
    "snapshot",
    "exchange",
    "wallet",
    "setting",
    "configuration",
    "swagger",
    "rest",
    "http",
    "specification",
    "openapi",
    "format",
    "user",
    "experiment",
    "functionality",
    "explorer",
    "explorer.ergoplatform.com",
    "community",
    "alternative",
    "detail",
    "toolkit",
    "mirror",
    "section",
    "graphql",
    "query",
    "datum",
    "fetching",
    "under",
    "server",
    "database",
    "schema",
    "instance",
    "logic",
    "library",
    "block",
    "mempool",
    "spending",
    "bitcoin",
    "consist",
    "input",
    "output",
    "unspent",
    "entity",
    "ground",
    "script",
    "depth",
    "understanding",
    "model",
    "p2pk",
    "address",
    "register",
    "value",
    "token",
    "tokenid",
    "pair",
    "demo",
    "seed",
    "generation",
    "java",
    "adressgenerationdemo.java",
    "/wallet",
    "derivenextkey",
    "derivation",
    "bip-32",
    "withdrawal",
    "type",
    "util",
    "byaddress",
    "method",
    "version",
    "call",
    "byidbinary/{boxid",
    "example",
    "bytes",
    "field",
    "request",
    "approach",
    "result",
    "array",
    "ergotree",
    "process",
    "batch",
    "level",
    "overview",
    "processing",
    "adjustment",
    "code",
    "framework",
    "json",
    "post",
    "http://{node_ip}:9053",
    "network",
    "confirmation",
    "error",
    "execution",
    "limit",
    "vector(ergobox(0275eb3a125bc02fe997cb98c0de8131bd9b2e4617110d",
    "/transactions",
    "dust",
    "miner",
    "deposit",
    "protocol",
    "stream",
    "reward",
    "excess",
    "mining",
    "traffic",
    "payment",
    "parameter",
    "change",
    "airdrop",
    "asset",
    "auto",
    "burn",
    "effort",
    "issue",
    "spamming",
    "registry",
    "resource",
    "ergotipper",
    "spectrum",
    "finance",
    "p2sh",
    "hash",
    "problem",
    "case",
    "complexity",
    "form",
    "conversion",
    "address.create",
    "string",
    "object",
    "fees",
    "system",
    "spam",
    "prevention",
    "strategy",
    "guideline",
    "nanoerg",
    "byte",
    "validation",
    "cost",
    "unit",
    "voting",
    "mechanism",
    "contract",
    "requirement",
    "hashrate",
    "risk",
    "spend",
    "attack",
    "prioritization",
    "collection",
    "topic",
    "algorithm",
    "boxid",
    "content",
    "appkit",
    "rule",
    "preventive",
    "measure",
    "chain",
    "forking",
    "view",
    "fork",
    "application",
    "layer",
    "thing",
    "supermajority",
    "feature",
    "improvement",
    "proposals",
    "eips",
    "storage",
    "rent",
    "machine",
    "whitelisting",
    "whitelist",
    "synchronization",
    "difference",
    "combination",
    "inclusionheight",
    "creation",
    "height",
    "person",
    "inclusion",
    "header",
    "numconfirmations",
    "/blockchain",
    "byid/{txid",
    "practice",
    "minute",
    "event",
    "time",
    "balance",
    "endpoint",
    "/balance",
    "account"
  ],
  "sections": [
    {
      "heading": "Ergo Platform Blockchain Integration Guide#",
      "content": "This guide provides developers with the necessary information to integrate with the Ergo Blockchain Platform. For suggestions to improve this guide, please reach out to us at team@ergoplatform.org or join our #development channel on Discord."
    },
    {
      "heading": "Key Features#",
      "content": "Ergo's transactions consist of multiple inputs and outputs, similar to Bitcoin. Unspent outputs, known as single-use entities, are used once. Although built from the ground up, Ergo's scripts and transaction formats differ from Bitcoin's. For an in-depth understanding, refer to the Ergo 'Box' model.\nErgo incorporates standard scripts, associated with P2PK addresses, much like Bitcoin. Explore more about the address scheme here.\nAn Ergo UTXO box utilizes registers to store arbitrary values, such as native tokens, rather than a single amount (like BTC). Each box holds an ERG amount and may include {tokenid, token amount} pairs, adhering to the UTXO model.\nErgo's built-in wallet API caters to most use cases. The API employs a Swagger interface and operates on 127.0.0.1:9053 by default in the mainnet (9052 on the testnet).\nThe precision of each transaction on the Ergo platform is up to \\(10^{-9}\\) ERG. This means that transactions can be made with a precision of up to 0.000000001 ERG.\nThe average interval time of each block on the Ergo blockchain is approximately 2 minutes."
    },
    {
      "heading": "Node#",
      "content": "For the best performance, we advise you to run your own node. If that's not feasible, you can use a public node available at 213.239.193.208:9053. For backup options, feel free to reach out to us at team@ergoplatform.org or join our group chat. You can also find a dynamic list of public nodes at api.tokenjay.app/peers/list.\nIf you choose to run a public node, you can access the web interface at 127.0.0.1:9053/panel. Please note that the port switches to 9052 on the testnet. For guidance on getting started with the testnet, please refer to this page.\nRunning an Ergo node requires a certain amount of disk space, which depends on factors like the size of the blockchain and the number of transactions. We recommend having at least 100 GB of disk space to ensure seamless operation.\nFor a more efficient setup, you can bootstrap a pruned node using a verified UTXO set snapshot and NiPoPoWs."
    },
    {
      "heading": "Exchange Specific Node Settings#",
      "content": "For exchange nodes, consider implementing the following non-default wallet settings:\nSet ergo.wallet.dustLimit = 1000000 to disregard incoming payments (e.g., airdrops) of 0.001 ERG or less. Adjust as needed. The default null accounts for all incoming payments.\nSet ergo.wallet.profile to exchange to enable larger Bloom filters for more efficient scanning with many addresses.\nSet ergo.wallet.tokensWhitelist to a non-null value to automatically burn airdrop tokens and similar.\nCombine these settings in your configuration:\nergo {\n    ...\n    wallet {\n      ...  \n\n      # boxes with value smaller than dustLimit are disregarded in wallet scan logic\n      dustLimit = 1000000\n\n      # Whitelisted tokens, if non-null, the wallet will automatically burn non-whitelisted tokens from\n      # inputs when doing transactions.\n      # If tokensWhitelist = [], all the tokens will be burnt,\n      # tokensWhitelist = [\"example\"] means that all the tokens except of \"example\" will be burnt\n      # tokensWhitelist = null means no tokens burnt automatically\n      tokensWhitelist = [\n        # SigUSD\n        \"03faf2cb329f2e90d6d23b58d91bbb6c046aa143261cc21f52fbe2824bfcbf04\",\n        # SigRSV\n        \"003bd19d0187117f130b62e1bcab0939929ff5c7709f843c5c4dd158949285d0\"\n      ]\n\n\n      # Wallet profile allows to say wallet what kind of load it should expect,\n      # and so spend memory on caches and Bloom filters accordingly.\n      # There are three options: user, exchange, appServer\n      # User profile is about ordinary planned usage.\n      # Exchange consumes ~20 MB of RAM for high-load ready Bloom filters\n      # AppServer is in between\n      profile = \"exchange\"\n    }\n  }"
    },
    {
      "heading": "Node Wallet#",
      "content": "Swagger\nErgo node offers a REST API accessible via HTTP. The complete API specification, in OpenAPI format, can be found here. When the node is operational, access the user-friendly Swagger UI at 127.0.0.1:9053/swagger or experiment with it here. An optional indexed node API is also available.\nMajor wallet functionalities include:\nWallet creation (/wallet/init) and mnemonic generation\nWallet restoration (/wallet/restore) from mnemonic\nWallet unlock (/wallet/unlock) for transaction signing\nWallet lock (/wallet/lock)\nSending a simple payment (/wallet/payment/send)\nChecking wallet status (/wallet/status)\nDeriving a new key according to EIP-3 (BIP 44 implementation for Ergo) (/wallet/deriveNextKey)\nChecking wallet balance (/wallet/balances) for all addresses\nRetrieving wallet transactions (/wallet/transactions) for all addresses"
    },
    {
      "heading": "RPC Documentation#",
      "content": "Overview\nAPI Spec\nIndexed Node"
    },
    {
      "heading": "Explorer#",
      "content": "The public explorer is available at explorer.ergoplatform.com. Community-hosted alternatives include ergexplorer.com and sigmaspace.io.\nFor more information, including additional details, toolkits, mirrors, and more, please visit the dedicated Explorer section."
    },
    {
      "heading": "GQL#",
      "content": "GraphQL queries provide flexible data fetching, minimizing over-fetching and under-fetching. The GraphQL server, built on the Ergo Platform's explorer database schema, is accessible at gql.ergoplatform.com.\nThe most reliable instance is currently explore.sigmaspace.io/api/graphql."
    },
    {
      "heading": "Creating an External Wallet#",
      "content": "Develop your wallet logic externally using one of the available libraries and the block explorer.\nConsider mempool transactions to avoid double-spending.\nAvailable libraries:\nergo-appkit: A complete Java SDK.\nergo-wallet: Developed in Java, source code available in the Ergo node repository.\nsigma-rust: A Rust library with WASM bindings for JavaScript/TypeScript.\nergo-golang: An early-stage Go library.\nergo-lib-go: A Go library for Ergo.\nErgo's transactions, akin to Bitcoin, consist of multiple inputs and outputs. Unspent outputs, known as single-use entities, are used once. Although Ergo is built from the ground up, its scripts and transaction formats are distinct from Bitcoin's. For an in-depth understanding, refer to the Ergo 'Box' model.\nErgo incorporates standard scripts, associated with P2PK addresses, much like Bitcoin. An Ergo UTXO box utilizes registers to store arbitrary values, such as its native tokens, rather than a single amount (like BTC). Consequently, each box holds an ERG amount and may also include {tokenid, token amount} pairs, adhering to the UTXO model."
    },
    {
      "heading": "Offline Signing#",
      "content": "Demo for transaction assembly and offline signing using ergo-wallet and Java: AdressGenerationDemo.java\nTransaction assembly and signing in Rust: tx_builder.rs and signing.rs\nTransaction assembly and signing in JavaScript"
    },
    {
      "heading": "Address Generation#",
      "content": "Demo for secret seed and derived addresses generation using ergo-wallet and Java: AdressGenerationDemo.java\nUse the /wallet/deriveNextKey API to generate new addresses in the same wallet:\ncurl -X GET \"http://localhost:9053/wallet/deriveNextKey\" -H  \"accept: application/json\" -H  \"api_key: hello\"\nThe output would be:\n{\n  \"derivationPath\": \"m/44'/429'/0'/0/1\",\n  \"address\": \"9gF9QP33MoPc8uekF95VHdosL4KzgSz7Ec7MLEtuhx4uPAd3eZs\"\n}\nDerivation is done according to BIP-32."
    },
    {
      "heading": "Address Validation#",
      "content": "For exchanges, restrict withdrawals to P2PK addresses and invalidate other types. Supporting other types is not recommended. See address types for more information.\nergo-simple-addresses contains Java-friendly utils for working with addresses."
    },
    {
      "heading": "Composing Transactions Outside the Node#",
      "content": "Get unspent UTXOs for an address using the transactions/boxes/byAddress/unspent Explorer API method:\nhttps://api.ergoplatform.com/transactions/boxes/byAddress/unspent/9gAE5e454UT5s3NB1625u1LynQYPS2XzzBEK4xumvSZdqnXT35M\nWhen selecting UTXOs manually, be sure to use the binary-encoded version of the inputs. You can retrieve the binary data for a UTXO by making a call to /utxo/byIdBinary/{boxId}.\nFor example:\ncurl -X 'GET' \\\n  'http://127.0.0.1:9053/utxo/byIdBinary/{boxId}' \\\n  -H 'accept: application/json'\nUse the returned bytes field in your inputsRaw field of the transaction request."
    },
    {
      "heading": "Handling Unconfirmed UTXOs#",
      "content": "To avoid double-spending, it's important to handle unconfirmed UTXOs properly. There are two main approaches:\nFetch unconfirmed transactions using the /transactions/unconfirmed/byErgoTree endpoint and exclude inputs from these transactions. You can convert an address to ergoTree using the ErgoAddress class in fleetSDK:\nErgoAddress.fromPublicKey(hex.decode(publicKey), Network.Mainnet).ergoTree;\nDownload the whole mempool using the /transactions/unconfirmed endpoint and exclude unconfirmed UTXOs from your inputs.\nHere's an example of fetching unconfirmed transactions by ergoTree:\ncurl -X POST \"https://api.ergoplatform.com/transactions/unconfirmed/byErgoTree\" -H \"Content-Type: application/json\" -d \"\\\"00020006f03234fca83e0f00e7fe45e4bdb9db03008f279f599273b471bd85e22d8f1ef01\\\"\"\nIf the result is an empty array, there are no unconfirmed transactions for the given ergoTree."
    },
    {
      "heading": "Batch Withdrawals#",
      "content": "Processing user withdrawals in batches by gathering them in a script and pushing all outputs in one transaction can be beneficial. Here's a high-level overview of the process:\nWhen a user initiates a withdrawal, store the transaction details in your system.\nEvery X minutes (e.g., 5-10 minutes), collect all pending withdrawals.\nBuild a new transaction with multiple inputs (from your exchange's wallet) and outputs (to the users' withdrawal addresses).\nSign and broadcast the batch transaction.\nThis approach can help optimize transaction processing and reduce overall fees. However, it may require adjustments to your existing code framework."
    },
    {
      "heading": "Example Batch Transaction Request#",
      "content": "When manually creating transactions, make sure the inputsRaw field contains binary-encoded UTXOs retrieved as described earlier. An example transaction might look like this:\n{\n    \"requests\": [\n        {\n            \"address\": \"9ek75mvKwhM5uTT39L9mEdsPGWtMkc7wKRUToVNYT5FSAHJazWc\",\n            \"value\": 4664620000\n        },\n        {\n            \"address\": \"9fF8dd6XcbAx6n475CZqu7JsxSXTLRJm2ov22GiV6kaxrugX1x6\",\n            \"value\": 1000000000\n        }\n    ],\n    \"fee\": 1000000,\n    \"inputsRaw\": [\"8089938d150008cd021d9e5e6e45f12c5dc22f7edbb78391c51483aef82300f0a4a3eaf2c6c66dfb0ffba5500000f97ba6d3d40d54cd2cabb69baf9fea0e2e23e263b9e0c17c360fc935167aa5fa01\"],\n    \"dataInputsRaw\": []\n}\nSubmit this transaction via a POST request as described below."
    },
    {
      "heading": "Broadcasting Transactions#",
      "content": "To broadcast a transaction made outside the node, serialize it into JSON. In Java:\nJson json = JsonCodecsWrapper.ergoLikeTransactionEncoder().apply(tx);\nSystem.out.println(json.toString());\nSend this JSON via a POST request to the public Explorer:\ncurl -X POST \"https://api.ergoplatform.com/api/v0/transactions/send\" \\\n-H \"Content-Type: application/json\" \\\n-d '{...}'\nOr to your private Explorer or a node with open API (POST to http://{node_ip}:9053/transactions):\ncurl -X POST \"http://{node_ip}:9053/transactions\" \\\n-H \"Content-Type: application/json\" \\\n-d '{...}'\nThis ensures that the transaction is properly submitted to the Ergo network for confirmation."
    },
    {
      "heading": "Determining Failed Transactions in UTXO Mode:#",
      "content": "Malformed transactions:\nSimple transactions should produce an explicit error when signing and/or broadcasting such as:\nFailed to sign boxes due to Estimated execution cost 1001580 exceeds the limit 1000000: Vector(ErgoBox(0275eb3a125bc02fe997cb98c0de8131bd9b2e4617110d\nThis error can occur due to too many inputs collected in a transaction for dusty wallets.\nValid RBF transactions:\nDropped transactions will be removed from the mempool, this can be checked with the /transactions/unconfirmed/{txId} endpoint"
    },
    {
      "heading": "Dust Collection#",
      "content": "Collect dust from miners' deposits periodically to prevent small UTXOs from accumulating.\nErgo's extended-UTXO model can lead to dust - fractional ERG values usually below the protocol fee. Miner wallets are prone to becoming dusty due to the stream of rewards. Excess UTXOs can slow down and impact node functionality. This is important for exchanges receiving mining traffic. Collect dust aggressively, as new dust arrives constantly for miners.\nNode-specific settings to address this:\nGet UTXOs from /wallet/boxes/unspent with min confirmations\nGet their ids and total sum\nGet binary representations of UTXOs via /utxo/byIdBinary/{boxId}\nConstruct the payment transaction:\n{\n  \"requests\": [\n    {\n      \"address\": \"3WwbzW6u8hKWBcL1W7kNVMr25s2UHfSBnYtwSHvrRQt7DdPuoXrt\",\n      \"value\": 10000000000\n    }\n  ],\n  \"fee\": 1000000,\n  \"inputsRaw\": [\n    \"utxo1\", \"utxo2\"\n  ],\n  \"dataInputsRaw\": [\n  ]\n}\nPost to /wallet/transaction/send.\nSet value and fee such that value + fee = total sum of UTXOs.\nQuery with specific parameters:\ncurl -X GET \"http://127.0.0.1:9053/wallet/boxes/unspent?minConfirmations=10&minInclusionHeight=0\" -H  \"accept: application/json\" -H  \"api_key: hello\"\nAnother simple way to collect dust is to set:\nergo {\n wallet {\n   maxInputs = 300 \n   optimalInputs = 100\n }\n}\nAnd send 1 ERG to the change address. The node will attach 100 dust inputs (send any large change amounts to the change address as well)."
    },
    {
      "heading": "Failed to sign boxes#",
      "content": "This error can occur due to too many inputs collected in a transaction for dusty wallets:\nFailed to sign boxes due to Estimated execution cost 1001580 exceeds the limit 1000000: Vector(ErgoBox(0275eb3a125bc02fe997cb98c0de8131bd9b2e4617110d"
    },
    {
      "heading": "Native Assets#",
      "content": "For large airdrops, users may mistakenly put exchange addresses to receive native assets. An auto-burn method will be in future node versions to reduce manual effort. See this Issue for more information.\nSend this request via /wallet/payment/send, replacing tokenId with the IDs of the spamming tokens:\n[\n  {\n    \"address\": \"4MQyMKvMbnCJG3aJ\",\n    \"value\": 100000000,\n    \"assets\": [\n      {\"tokenId\":\"e55adbda4e42f2bd21b1cb9498c105ff3bc1069012942d6158412f55759369c3\",\"amount\":1},\n      {\"tokenId\":\"6dd3e0ac4edd9702094aa4e3cad7c0c73d5437292c11805adf5d5068312748b4\",\"amount\":1}\n    ]\n  }\n]\nThere is no central token registry. Use community resources like supported tokens in the ergotipper bot and spectrum-finance/ergo-token-list."
    },
    {
      "heading": "Frequently Asked Questions#",
      "content": "Can P2S and P2SH be two address formats for the same script?\nYes. For P2S, the script is serialized directly into the address. For P2SH, the address contains only a hash of the serialized script.\nAre there issues with supporting address types other than P2PK?\nSupporting other types isn't a problem if the user is aware of what they're doing, but this is often not the case and can introduce complexity. P2S addresses can't validate input size in forms.\nHow are ergoTree and address related for conversions?\nIn appkit, Address.create() accepts an address string and returns an object from which you can obtain the ergoTree.\nTransaction Fees\nErgo's transaction fee system is designed to be flexible and explicit. Although the protocol does not enforce a specific minimum transaction fee, it employs a spam-prevention strategy that requires each box to contain a minimum amount of ERG based on its size. This minimum value is determined by a parameter voted on by miners.\nAs a guideline, it is suggested to allocate 0.001 ERG (1,000,000 NanoErg) for each box involved in the transaction. Including a fee incentivizes miners to process your transaction more quickly.\nMiners prioritize transactions based on either the fee per byte or the validation cost unit, which are adjustable via a voting mechanism among miners. Transaction fees are collected in a specific contract that can only be spent through a miner's script.\nTo determine the appropriate transaction fee, consider the protocol's minimum requirements based on the box size and the network's current hashrate. Higher hashrates reduce the risk of double-spend attacks, thus requiring fewer confirmations.\nFor more detailed information on transaction fees, including minimum values, miner prioritization, fee collection, and related topics, please refer to the dedicated Transaction Fees page.\nWhat algorithm generates a boxid?\nThe boxid is generated by hashing the box contents.\nSee the code in AppKit for details\nA box's bytes are unique becau..."
    },
    {
      "heading": "Frequently Asked Questions#",
      "content": "What is the difference between the value field and assets array in a box?\nEach box always has an ERG value in the value field. Assets are optional and are represented in the assets array. A box can contain a combination of ERG and tokens.\nWhat is the difference between inclusionHeight and creationHeight?\nCreation height is when the transaction was built, but it's not reliable since the person building the transaction can input a number <= current block height. Inclusion height is the block number where the transaction was first included (first confirmation).\nHow can I get the block number of the first transaction confirmation?\nCall /blocks/{blockId}/header to get the block height. The height in the header defines the block number in which the transactions from that block received their first confirmation.\nIs the numConfirmations value returned by /blockchain/transaction/byId/{txId} the number of transaction confirmations?\nYes, it is.\nWhat is considered a safe number of confirmations?\nA common practice is to use 10 confirmations for deposits, which takes about 20 minutes. Ergo doesn't have many forking events due to the relatively long block time.\nWhat's the difference between /wallet/balances and /wallet/balances/withUnconfirmed endpoints?\n/balances returns the balance excluding current unconfirmed transactions in the mempool. /balances/withUnconfirmed accounts for transactions in the mempool, returning the confirmed balance plus (or minus) unconfirmed transactions.\nWhich endpoint should be used to get the balance before sending a transaction?\nWhen working with chained transactions, it's better to use /balances/withUnconfirmed to get the balance before sending a transaction, as it reflects the \"new wallet balance\" after sending the previous transaction."
    }
  ],
  "qa_pairs": []
}