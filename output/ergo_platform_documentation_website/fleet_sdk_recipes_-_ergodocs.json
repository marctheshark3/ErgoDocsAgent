{
  "title": "Fleet SDK Recipes - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/dev/tutorials/fleet-sdk-recipes/",
  "summary": "This page contains useful code snippets, patterns, and troubleshooting tips for common tasks when using the Fleet SDK in TypeScript/JavaScript. A common requirement when building off-chain logic is to validate conditions that mirror on-chain checks. One such check is verifying that an input box belongs to a specific owner whose public key (as a SigmaProp) is stored in another box's register. This is often needed for refund scenarios or proving ownership before allowing an action. The core task involves: Important: Directly constructing ErgoAddress from SSigmaProp is not the correct approach in Fleet SDK.",
  "keywords": [
    "page",
    "code",
    "snippet",
    "pattern",
    "task",
    "fleet",
    "typescript",
    "javascript",
    "requirement",
    "chain",
    "logic",
    "condition",
    "check",
    "input",
    "owner",
    "sigmaprop",
    "register",
    "refund",
    "scenario",
    "ownership",
    "action",
    "core",
    "ergoaddress",
    "ssigmaprop",
    "approach",
    "byte",
    "contract",
    "value",
    "deadline",
    "timestamp",
    "count",
    "sint",
    "slong",
    "collection",
    "bytes",
    "scoll(sbyte",
    "data",
    "structure",
    "tuple",
    "typea",
    "typeb",
    "option[typea",
    "coll[typea",
    "deserialize",
    "function",
    "object",
    "type",
    "component",
    "general",
    "example",
    "long",
    "assume",
    "element",
    "option[int",
    "integer",
    "coll[int",
    "array",
    "coll[byte",
    "compiler",
    "module",
    "ergoscript",
    "source",
    "ergotree",
    "string",
    "ergotrees",
    "issue",
    "problem",
    "property",
    "p2pk",
    "address",
    "possible",
    "causes",
    "solutions",
    "deserialized.type",
    "solution",
    "helper",
    "format",
    "diagram",
    "conversion",
    "path"
  ],
  "sections": [
    {
      "heading": "Fleet SDK Recipes#",
      "content": "This page contains useful code snippets, patterns, and troubleshooting tips for common tasks when using the Fleet SDK in TypeScript/JavaScript."
    },
    {
      "heading": "Table of Contents#",
      "content": "Fleet SDK Recipes\nTable of Contents\nValidating Box Ownership (SigmaProp from Register)\nComplete Example:\n\n\nWorking with Numeric Registers\nExtracting Token IDs from Registers\nDecoding Complex Types (Tuples, Options, Collections)\nCompiling ErgoScript to ErgoTree\nTroubleshooting Common Issues\n1. ErgoTree Comparison Failures\n2. Unexpected Register Format\n\n\nRelationship Diagram\nRelated Documentation"
    },
    {
      "heading": "Validating Box Ownership (SigmaProp from Register)#",
      "content": "A common requirement when building off-chain logic is to validate conditions that mirror on-chain checks. One such check is verifying that an input box belongs to a specific owner whose public key (as a SigmaProp) is stored in another box's register. This is often needed for refund scenarios or proving ownership before allowing an action.\nThe core task involves:\nExtracting the owner's SigmaProp bytes from a register (e.g., R4).\nDeserializing these bytes correctly.\nConverting the public key bytes into the owner's P2PK ErgoTree.\nComparing this derived ErgoTree with the ErgoTree of the box being validated.\nImportant: Directly constructing ErgoAddress from SSigmaProp is not the correct approach in Fleet SDK. You need to extract the public key bytes first."
    },
    {
      "heading": "Complete Example:#",
      "content": "import { \n  Box, \n  ErgoAddress, \n  SByte, // Note: SByte might not be directly needed for deserialization logic\n  SColl, \n  SGroupElement, \n  SSigmaProp \n} from \"@fleet-sdk/core\";\nimport { deserialize } from \"@fleet-sdk/serializer\"; // Fleet's serializer is key\n\n/**\n * Validates if a box belongs to the owner specified in another box's register R4.\n * Assumes R4 contains a serialized SigmaProp representing the owner's public key.\n * @param boxToValidate The box whose ownership we want to verify.\n * @param boxWithOwnerInfo Box containing owner's SigmaProp in R4.\n * @returns boolean indicating if ownership is valid.\n */\nfunction validateBoxOwnership(boxToValidate: Box, boxWithOwnerInfo: Box): boolean {\n  try {\n    // 1. Extract SigmaProp bytes from register R4\n    const registerValueHex = boxWithOwnerInfo.additionalRegisters.R4;\n    if (!registerValueHex) {\n      console.error(\"Register R4 is empty or not present.\");\n      return false;\n    }\n\n    // 2. Deserialize the register value (hex string)\n    // The register often contains a serialized SigmaProp, typically starting with '07' (SColl(SByte)) or 'cd' (SSigmaProp)\n    const deserializedValue = deserialize(registerValueHex);\n\n    // 3. Extract the raw public key bytes based on common serialization formats\n    let publicKeyBytes: Uint8Array;\n\n    if (deserializedValue.type === \"SColl\" && deserializedValue.elemType === \"SByte\") {\n      // Format: SColl(SByte) - a simple collection of bytes\n      publicKeyBytes = new Uint8Array(deserializedValue.value);\n    } else if (deserializedValue.type === \"SSigmaProp\") {\n      // Format: SSigmaProp(SGroupElement(bytes))\n      if (deserializedValue.value?.type === \"SGroupElement\") {\n        publicKeyBytes = new Uint8Array(deserializedValue.value.value);\n      } else {\n        throw new Error(`Unsupported SigmaProp inner type: ${deserializedValue.value?.type}`);\n      }\n    } else {\n      throw new Error(`Unsupported register format type: ${deserializedValue.type}`);\n    }\n\n    //..."
    },
    {
      "heading": "Working with Numeric Registers#",
      "content": "Contracts often store numeric values like deadlines (timestamps), counts, or amounts in registers. These are typically stored as SInt or SLong.\nimport { Box, SLong, SInt } from \"@fleet-sdk/core\"; // SInt might be needed depending on contract\nimport { deserialize } from \"@fleet-sdk/serializer\";\n\n/**\n * Extracts a numeric value (BigInt) from a specified register.\n * Handles SLong and SInt types.\n * @param box The box containing the register.\n * @param register The register name (R4-R9).\n * @returns The numeric value as BigInt, or null if not found/not a supported number type.\n */\nfunction getNumericFromRegister(box: Box, register: \"R4\" | \"R5\" | \"R6\" | \"R7\" | \"R8\" | \"R9\"): bigint | null {\n  try {\n    const registerValueHex = box.additionalRegisters[register];\n    if (!registerValueHex) {\n        // console.warn(`Register ${register} not found in box ${box.boxId}`);\n        return null;\n    }\n\n    const deserialized = deserialize(registerValueHex);\n\n    // Handle different numeric types\n    if (deserialized.type === \"SLong\") {\n      // SLong stores value as string, convert to BigInt\n      return BigInt(deserialized.value); \n    } else if (deserialized.type === \"SInt\") {\n      // SInt stores value as number, convert to BigInt\n      return BigInt(deserialized.value); \n    } else {\n      // console.warn(`Register ${register} has non-numeric type: ${deserialized.type}`);\n      return null;\n    }\n\n  } catch (error) {\n    console.error(`Error extracting numeric value from ${register} in box ${box.boxId}:`, error);\n    return null;\n  }\n}\n\n// --- Usage Example ---\n/*\nconst contractBox: Box = { ... }; // Populate with actual box data\nconst deadlineTimestamp = getNumericFromRegister(contractBox, \"R4\");\n\nif (deadlineTimestamp !== null) {\n  if (BigInt(Date.now()) > deadlineTimestamp) {\n    console.log(\"Deadline has passed!\");\n  } else {\n    console.log(\"Deadline is still in the future.\");\n  }\n} else {\n  console.log(\"Could not read deadline from R4.\");\n}\n*/"
    },
    {
      "heading": "Extracting Token IDs from Registers#",
      "content": "Token IDs are frequently stored in registers, usually as a collection of bytes (SColl(SByte)).\nimport { Box } from \"@fleet-sdk/core\";\nimport { deserialize } from \"@fleet-sdk/serializer\";\nimport { Buffer } from 'buffer'; // Use Buffer for hex conversion\n\n/**\n * Extracts a token ID (hex string) from a register containing SColl(SByte).\n * @param box The box containing the register.\n * @param register The register name (R4-R9).\n * @returns The token ID as a hex string, or null if not found or not CollByte format.\n */\nfunction getTokenIdFromRegister(box: Box, register: \"R4\" | \"R5\" | \"R6\" | \"R7\" | \"R8\" | \"R9\"): string | null {\n  try {\n    const registerValueHex = box.additionalRegisters[register];\n    if (!registerValueHex) {\n      // console.warn(`Register ${register} not found in box ${box.boxId}`);\n      return null;\n    }\n\n    const deserialized = deserialize(registerValueHex);\n\n    // Handle CollByte format (most common for token IDs / Box IDs / Tx IDs)\n    if (deserialized.type === \"SColl\" && deserialized.elemType === \"SByte\") {\n      // Convert byte array (deserialized.value) to hex string\n      return Buffer.from(deserialized.value).toString('hex');\n    } else {\n      // console.warn(`Register ${register} is not in CollByte format: ${deserialized.type}`);\n      return null;\n    }\n\n  } catch (error) {\n    console.error(`Error extracting token ID from ${register} in box ${box.boxId}:`, error);\n    return null;\n  }\n}\n\n// --- Usage Example ---\n/*\nconst contractBox: Box = { ... }; // Populate with actual box data\nconst requiredTokenId = getTokenIdFromRegister(contractBox, \"R5\");\n\nif (requiredTokenId) {\n  console.log(`Contract requires token ID: ${requiredTokenId}`);\n  // Now you can check if an input box contains this token\n} else {\n  console.log(\"Could not read required token ID from R5.\");\n}\n*/"
    },
    {
      "heading": "Decoding Complex Types (Tuples, Options, Collections)#",
      "content": "Contracts might store more complex data structures in registers, such as tuples (TypeA, TypeB), optional values Option[TypeA], or collections Coll[TypeA]. Fleet's deserialize function handles these, returning a nested object structure that mirrors the on-chain type. You need to inspect this structure to extract the individual components.\nGeneral Approach:\nCall deserialize(registerValueHex).\nCheck the type property of the result (e.g., \"STuple\", \"SColl\", \"SOption\").\nAccess the value property.\nFor STuple and SColl, value is typically an array. Iterate through it, inspecting the type and value of each element.\nFor SOption, value is either null (representing None) or an object representing the Some(value) content. Check if value is null before accessing its properties.\n\n\nRecursively apply this process for nested structures.\nExample 1: Decoding a Tuple (SigmaProp, Long) from R5\nAssume R5 contains a serialized tuple where the first element is a SigmaProp (owner's public key) and the second is a Long (deadline).\nimport { Box } from \"@fleet-sdk/core\";\nimport { deserialize } from \"@fleet-sdk/serializer\";\nimport { Buffer } from 'buffer'; \n\n/**\n * Extracts data from a register assumed to contain a serialized (SigmaProp, Long) tuple.\n * @param box The box containing the register.\n * @param register The register name (R4-R9).\n * @returns An object { ownerPubKeyHex: string, deadline: bigint } or null if format is wrong.\n */\nfunction decodeSigmaPropLongTuple(box: Box, register: \"R4\" | \"R5\" | \"R6\" | \"R7\" | \"R8\" | \"R9\"): { ownerPubKeyHex: string; deadline: bigint } | null {\n  try {\n    const registerValueHex = box.additionalRegisters[register];\n    if (!registerValueHex) return null;\n\n    const deserialized = deserialize(registerValueHex);\n\n    // Expecting STuple with two items\n    if (deserialized.type !== \"STuple\" || !Array.isArray(deserialized.value) || deserialized.value.length !== 2) {\n      console.warn(`Register ${register} is not the expected STuple format.`);\n      return ..."
    },
    {
      "heading": "Compiling ErgoScript to ErgoTree#",
      "content": "The Fleet SDK includes a compiler module to convert ErgoScript source code into its corresponding ErgoTree hex string, which is needed when creating contract boxes.\nimport { compile } from \"@fleet-sdk/compiler\";\n\n/**\n * Compiles an ErgoScript string to its ErgoTree hex representation.\n * @param script The ErgoScript source code.\n * @returns Promise resolving to the compiled ErgoTree hex string.\n * @throws Error if compilation fails.\n */\nasync function compileToErgoTree(script: string): Promise<string> {\n  try {\n    // The compile function returns an object with address, ergoTree, template, etc.\n    const result = await compile(script); \n    if (!result || !result.ergoTree) {\n        throw new Error(\"Compilation result did not contain ErgoTree.\");\n    }\n    return result.ergoTree;\n  } catch (error) {\n    console.error(\"ErgoScript Compilation Error:\", error);\n    // Rethrow or handle as needed\n    throw error; \n  }\n}\n\n// --- Usage Example ---\nconst timedContractScript = `{\n  // Contract allows spending only after a certain height (deadline)\n  val deadline = SELF.R4[Long].getOrElse(0L) // Get deadline from R4, default 0\n  sigmaProp(HEIGHT >= deadline) // Proposition is true if current height >= deadline\n}`;\n\nasync function exampleCompilation() {\n  try {\n    const compiledTree = await compileToErgoTree(timedContractScript);\n    console.log(\"Compiled ErgoTree:\", compiledTree);\n    // Use this compiledTree when building an output box\n  } catch (error) {\n    console.error(\"Failed to compile contract script.\");\n  }\n}\n\n// exampleCompilation(); // Uncomment to run"
    },
    {
      "heading": "Troubleshooting Common Issues#",
      "content": "Working with registers and ErgoTrees off-chain can sometimes lead to unexpected issues. Here are some common problems and how to approach them:"
    },
    {
      "heading": "1. ErgoTree Comparison Failures#",
      "content": "Problem: You've derived an ErgoTree from a register's SigmaProp, but it doesn't match the ergoTree property of the box you expect it to match, even though you believe they represent the same P2PK address.\nPossible Causes & Solutions:\nSerialization Mismatch: The most likely cause is that the deserialize function didn't correctly interpret the register data into the raw public key bytes needed by ErgoAddress.fromPublicKey. Double-check how the SigmaProp was serialized into the register on-chain. Common formats include SColl(SByte) containing the 33 public key bytes, or SSigmaProp(SGroupElement(...)) containing the same bytes nested deeper. Use detectRegisterFormat below or inspect the raw hex.\nIncorrect Prefix: ErgoTrees can have different hexadecimal prefixes depending on their structure (e.g., 00 for basic P2PK, 0e for hashes, etc.). Ensure you are comparing apples to apples. If one tree starts with 0008cd (standard P2PK) and the other doesn't, they represent different script types.\nAddress Type Mismatch: Are you sure the register contains a standard P2PK SigmaProp? If the contract uses a more complex script (P2S), deriving the ErgoTree from just a public key won't work. You'd need to compile the corresponding ErgoScript.\nfunction troubleshootErgoTreeComparison(ergoTree1: string, ergoTree2: string): string {\n  if (ergoTree1 === ergoTree2) return \"Exact Match: Trees are identical.\";\n\n  // Check for common P2PK prefix (00 + ProveDlog op code + cd)\n  const p2pkPrefix = \"0008cd\";\n  const tree1IsP2PK = ergoTree1.startsWith(p2pkPrefix);\n  const tree2IsP2PK = ergoTree2.startsWith(p2pkPrefix);\n\n  if (tree1IsP2PK && tree2IsP2PK) {\n    // Both seem P2PK, but don't match. Check lengths.\n     if (ergoTree1.length !== ergoTree2.length) {\n         return \"Mismatch: Both seem P2PK but have different lengths. Possible data corruption or different public keys.\";\n     }\n     // If lengths match, the public keys themselves must be different.\n     return \"Mismatch: Both seem P2PK with ..."
    },
    {
      "heading": "2. Unexpected Register Format#",
      "content": "Problem: You try to deserialize a register value, but the resulting type (deserialized.type) is not what you expected (e.g., you expected SLong but got SColl(SByte)).\nSolution: Inspect the raw register value (hex string) and use a helper function to guess the format, or consult the contract source code to understand what type should be stored.\nfunction detectRegisterFormat(registerHex: string): string {\n  if (!registerHex || registerHex.length < 2) return \"Invalid or empty register value\";\n\n  const prefix = registerHex.substring(0, 2);\n  const lengthByte = parseInt(registerHex.substring(2, 4), 16); // For CollByte length\n\n  if (prefix === \"0e\") { // SConstant placeholder + length byte\n      if (registerHex.length === 68) return \"Likely a Blake2b256 hash (0e + 20 + 32 bytes)\";\n      return `Likely some hash or ID prefixed with 0e, length byte ${lengthByte}`;\n  } else if (prefix === \"00\") {\n      if (registerHex.startsWith(\"0008cd\")) return \"Likely a P2PK ErgoTree\";\n      return \"Starts with 00, possibly complex ErgoTree or other structure.\";\n  } else if (prefix === \"04\") { // SInt\n      return \"Likely an SInt (Integer)\";\n  } else if (prefix === \"05\") { // SLong\n      return \"Likely an SLong (Long Integer / BigInt)\";\n  } else if (prefix === \"07\") { // SColl(SByte)\n      return `Likely a CollByte (serialized byte array), length byte indicates ${lengthByte} bytes follow`;\n  } else if (prefix === \"cd\") { // SSigmaProp direct serialization (less common in registers)\n      return \"Likely a raw SSigmaProp (without 00 ErgoTree wrapper)\";\n  } else {\n      // Add more checks for other SType prefixes if needed (e.g., 01 for SBoolean, etc.)\n      // See: https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/sigmastate/src/main/scala/sigmastate/serialization/TypeSerializer.scala\n      return `Unknown format starting with prefix ${prefix}`;\n  }\n}\n\n// --- Usage Example ---\n/*\nconst r4Value = contractBox.additionalRegisters.R4;\nif (r4Value) {\n    console.log(`R4 Fo..."
    },
    {
      "heading": "Relationship Diagram#",
      "content": "graph TD\n    A[Ergo Address String] -->|\"ErgoAddress decode\"| B[Public Key Bytes]\n    B -->|\"ErgoAddress fromPublicKey\"| C[ErgoAddress Object]\n    B -->|\"SGroupElement\"| D[SGroupElement Object]\n    D -->|\"SSigmaProp\"| E[SSigmaProp Object]\n    C -->|\"address ergoTree\"| F[ErgoTree Hex - P2PK Script]\n    E -->|\"ErgoAddress sigmaProp ergoTree\"| F\n\n    style F fill:#f9f,stroke:#333,stroke-width:2px\n    style B fill:#ccf,stroke:#333,stroke-width:2px\nThis diagram shows the typical conversion paths for P2PK addresses."
    },
    {
      "heading": "Related Documentation#",
      "content": "ErgoScript Sigma Propositions\nBox Registers Specification\nErgoTree Specification\nFleet SDK GitHub Examples\nFleet SDK Compiler\nFleet SDK Serializer"
    }
  ],
  "qa_pairs": []
}