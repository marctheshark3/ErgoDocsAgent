{
  "title": "As a Language - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/dev/scs/ergotree/ergotree-lang/",
  "summary": "This section provides improved and clearer documentation for the ErgoTree language. ErgoTree is a typed, call-by-value, higher-order functional language without recursion. It supports various features such as single-assignment blocks, tuples, optional values, indexed collections with higher-order operations, short-circuiting logical operations, and ternary if-else expressions with lazy branches. It is important to note that all operations in ErgoTree are deterministic, without side effects, and all values are immutable. The semantics of ErgoTree are specified by first translating it to a lower-level language called Core-\u00ce\u00bb and then providing its denotational evaluation semantics.",
  "keywords": [
    "section",
    "documentation",
    "ergotree",
    "language",
    "call",
    "value",
    "order",
    "recursion",
    "feature",
    "assignment",
    "block",
    "tuple",
    "collection",
    "operation",
    "expression",
    "branch",
    "side",
    "effect",
    "semantic",
    "level",
    "core",
    "evaluation",
    "syntax",
    "table",
    "class",
    "hierarchy",
    "reference",
    "implementation",
    "mnemonic",
    "column",
    "term",
    "type",
    "typing",
    "rule",
    "list",
    "method",
    "declaration",
    "principle",
    "object",
    "java",
    "scala",
    "instance",
    "argument",
    "variable",
    "signature",
    "methodcall",
    "figure",
    "lambda",
    "hand",
    "\\(\\lst{if}\\",
    "laziness",
    "\\(\\lst{unit",
    "\\lst{boolean}\\",
    "\\(\\lst{||}\\",
    "transformation"
  ],
  "sections": [
    {
      "heading": "ErgoTree as a Language#",
      "content": "This section provides improved and clearer documentation for the ErgoTree language. ErgoTree is a typed, call-by-value, higher-order functional language without recursion. It supports various features such as single-assignment blocks, tuples, optional values, indexed collections with higher-order operations, short-circuiting logical operations, and ternary if-else expressions with lazy branches. It is important to note that all operations in ErgoTree are deterministic, without side effects, and all values are immutable.\nThe semantics of ErgoTree are specified by first translating it to a lower-level language called Core-\u00ce\u00bb and then providing its denotational evaluation semantics. The abstract syntax of ErgoTree is defined in Table 1, which represents the Value class hierarchy in the reference implementation. The values in the \"Mnemonic\" column correspond to specific classes in the reference implementation."
    },
    {
      "heading": "Table 1: Abstract syntax of ErgoTree language#",
      "content": "Set Name\nSyntax\nMnemonic\nDescription\n\n\n\n\n\\(\\mathcal{T} \\ni T\\)\nP\nSPredefType\nSee Types\n\n\n\n\\(\\tau\\)\nSTypeVar\nType variable\n\n\n\n\\((T_1, \\ldots, T_n)\\)\nSTuple\nTuple of \\(n\\) elements (see [Tuple] type)\n\n\n\n\\((T_1, \\ldots, T_n) \\to T\\)\nSFunc\nFunction of \\(n\\) arguments (see [Func] type)\n\n\n\n\\({{Coll}}[T]\\)\nSCollection\nCollection of elements of type \\(T\\)\n\n\n\n\\({{Option}}[T]\\)\nSOption\nOptional value of type \\(T\\)\n\n\n\\(Term \\ni e\\)\n\\(C(v, T)\\)\nConstant\nTyped constant\n\n\n\n\\(x\\)\nValUse\nVariable\n\n\n\n\\(\\TyLam{x_i}{T_i}{e}\\)\nFuncExpr\nLambda expression\n\n\n\n\\(\\Apply{e_f}{\\Ov{e_i}}\\)\nApply\nApplication of a functional expression\n\n\n\n\\(\\Apply{e.m}{\\Ov{e_i}}\\)\nMethodCall\nMethod invocation\n\n\n\n\\(\\Apply{e_f}{\\Ov{e_i}}\\)\nTuple\nConstructor of a tuple with \\(n\\) items\n\n\n\n\\(\\Apply{\\delta}{\\Ov{e_i}}\\)\n\nPrimitive application\n\n\n\n\\(\\text{if}~(e_{\\text{cond}})~e_1~\\text{else}~e_2\\)\nIf\nIf-then-else expression\n\n\n\n\\(\\{{ \\overline{{\\text{val}}}~x_i = e_i;}~e\\}\\)\nBlockExpr\nBlock expression\n\n\n\\(cd\\)\n\\(\\Trait{I}{\\overline{ms_i}}\\)\nSTypeCompanion\nInterface declaration\n\n\n\\(ms\\)\n\\(\\MSig{m[\\overline{\\tau_i}]}{\\overline{x_i : T_i}}{T}\\)\nSMethod\nMethod signature declaration\nThe terms in ErgoTree are assigned types according to the typing rules specified in Typing.\nConstants contain both the type and the data value of that type. The type of a constant must correspond to its value for it to be well-formed.\nVariables are always typed and identified by a unique ID, which refers to either a lambda-bound variable or a val-bound variable.\nLambda expressions can take a list of lambda-bound variables, which can be used in the body expression. The body expression itself can also be a block expression.\nFunction application takes an expression of functional type (e.g., \\((T_1, \\ldots, T_n) \\to T\\)) and a list of arguments. The notation \\(e_f(\\Ov{e})\\) is not used to represent function application because it suggests that \\((\\Ov{e})\\) is a subterm, which it is not.\nMethod invocation allows the application of functions defined as..."
    },
    {
      "heading": "Figure 2: Lowering to Core-\u00ce\u00bb#",
      "content": "\\(Term_{ErgoTree}\\)\n\n\\(Term_{Core}\\)\n\n\n\n\n\\(\\Low{ \\TyLam{x_i}{T_i}{e}      }\\)\n\\(\\To\\)\n\\(\\Lam{   x:(T_0,\\dots,T_n)}{ \\Low{ \\{ \\Ov{\\lst{val}~x_i: T_i = x.\\_i;}~e\\} } }\\)\n\n\n\\(\\Low{ \\Apply{e_f}{\\Ov{e_i}}    }\\)\n\\(\\To\\)\n\\(\\Apply{ \\Low{e_f} }{ \\Low{(\\Ov{e_i})} }\\)\n\n\n\\(\\Low{ \\Apply{e.m}{\\Ov{e_i}}    }\\)\n\\(\\To\\)\n\\(\\Apply{ \\Low{e}.m}{\\Ov{ \\Low{e_i} }}\\)\n\n\n\\(\\Low{ \\Tup{e_1, \\dots ,e_n}    }\\)\n\\(\\To\\)\n\\(\\Tup{   \\Low{e_1}, \\dots ,\\Low{e_n}}\\)\n\n\n\\(\\Low{ e_1~\\text{\\|\\|}~e_2        }\\)\n\\(\\To\\)\n\\(\\Low{   \\IfThenElse{ e_1 }{ \\True }{ e_2 }}\\)\n\n\n\\(\\Low{ e_1~\\text{&&}~e_2      }\\)\n\\(\\To\\)\n\\(\\Low{   \\IfThenElse{ e_1 }{ e_2 }{ \\False } }\\)\n\n\n\\(\\Low{ \\IfThenElse{e_{cond}}{e_1}{e_2} }\\)\n\\(\\To\\)\n\\(\\Apply{(if(\\Low{e_{cond}} ,~\\Lam{(\\_:Unit)}{\\Low{e_1}} ,~\\Lam{(\\_:Unit)}{\\Low{e_2}} ))}{}\\)\n\n\n\\(\\Low{ \\{ \\Ov{\\text{val}~x_i: T_i = e_i;}~e\\} }\\)\n\\(\\To\\)\n\\(\\Apply{ (\\Lam{(x_1:T_1)}{( \\dots \\Apply{(\\Lam{(x_n:T_n)}{\\Low{e}})}{\\Low{e_n}} \\dots )}) }{\\Low{e_1}}\\)\\\n\n\n\\(\\Low{ \\Apply{\\delta}{\\Ov{e_i}} }\\)\n\\(\\To\\)\n\\(\\Apply{\\delta}{\\Ov{ \\Low{e_i} }}\\)\n\n\n\\(\\Low{ e }\\)\n\\(\\To\\)\n\\(e\\)\nAll \\(n\\)-ary lambdas where \\(n > 1\\) are transformed into single-argument lambdas using tupled arguments.\nIt should be noted that the \\(\\IfThenElse{e_{\\text{cond}}}{e_1}{e_2}\\) term in ErgoTree has lazy evaluation of its branches, while the right-hand-side \\(\\lst{if}\\) is a primitive operation with strict evaluation of the arguments. Laziness is achieved using lambda expressions of type \\(\\lst{Unit} \\to \\lst{Boolean}\\).\nLogical operations (\\(\\lst{||}\\), &&) in ErgoTree, which are lazy (short-circuiting) on the second argument, are translated to \\(\\lst{if}\\) terms in ErgoTree, which are then recursively translated to the corresponding Core-\u00ce\u00bb terms.\nSyntactic blocks in ErgoTree are eliminated and translated into nested lambda expressions, which unambiguously specify the evaluation semantics of blocks. The evaluation semantics of Core-\u00ce\u00bb are specified in evaluation.\nNote that the lowering transformation is used solely to specify s..."
    }
  ],
  "qa_pairs": []
}