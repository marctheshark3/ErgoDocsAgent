{
  "title": "Explorer APIs - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/dev/tutorials/blockchain-indexing/explorer-apis/",
  "summary": "One of the simplest ways to access indexed Ergo blockchain data for your dApp or service is by utilizing the public APIs provided by blockchain explorers. This approach avoids the need to run your own node or indexer but comes with trade-offs regarding control, performance, and flexibility. Public explorers like explorer.ergoplatform.com, ergexplorer.com, and sigmaspace.io maintain their own indexed databases of the Ergo blockchain. They expose this data through public APIs, often RESTful, allowing developers to query for information programmatically. Below are examples of common endpoints available from the main Ergo Explorer API (api.ergoplatform.com).",
  "keywords": [
    "ergo",
    "blockchain",
    "datum",
    "dapp",
    "service",
    "explorer",
    "approach",
    "need",
    "node",
    "indexer",
    "trade",
    "control",
    "performance",
    "flexibility",
    "explorer.ergoplatform.com",
    "sigmaspace.io",
    "database",
    "developer",
    "information",
    "below",
    "example",
    "endpoint",
    "functionality",
    "documentation",
    "note",
    "replace",
    "placeholder",
    "address",
    "tokenid",
    "boxid",
    "txid",
    "blockid",
    "value",
    "resource",
    "operation",
    "practice",
    "limitation",
    "solution",
    "production",
    "application"
  ],
  "sections": [
    {
      "heading": "Indexing Strategy: Using Public Explorer APIs#",
      "content": "One of the simplest ways to access indexed Ergo blockchain data for your dApp or service is by utilizing the public APIs provided by blockchain explorers. This approach avoids the need to run your own node or indexer but comes with trade-offs regarding control, performance, and flexibility."
    },
    {
      "heading": "Concept#",
      "content": "Public explorers like explorer.ergoplatform.com, ergexplorer.com, and sigmaspace.io maintain their own indexed databases of the Ergo blockchain. They expose this data through public APIs, often RESTful, allowing developers to query for information programmatically."
    },
    {
      "heading": "How It Works#",
      "content": "Identify Explorer & API Docs: Choose an explorer whose API provides the endpoints you need. Review their API documentation carefully to understand available queries, request/response formats, authentication (if any), and usage limitations (especially rate limits).\nErgo Explorer API Docs: api.ergoplatform.com/api/v1/docs/\nErgExplorer API Docs: ergexplorer.com/api/v1/docs/\n\n\nMake API Requests: Your application makes standard HTTP requests (GET, POST, etc.) to the explorer's API endpoints using libraries like axios (JS/TS), requests (Python), or built-in fetch functions.\nProcess Response: Your application parses the JSON (or other format) response from the API and uses the data. Implement robust error handling for network issues, API errors (like 404 Not Found or 429 Too Many Requests), and unexpected response formats."
    },
    {
      "heading": "Common API Endpoints#",
      "content": "Below are examples of common endpoints available from the main Ergo Explorer API (api.ergoplatform.com). Other explorers often provide similar functionality, but check their specific documentation."
    },
    {
      "heading": "Ergo Explorer API (api.ergoplatform.com)#",
      "content": "Endpoint\nDescription\nExample URL\n\n\n\n\n/api/v1/addresses/{address}\nGet address summary info\nhttps://api.ergoplatform.com/api/v1/addresses/9iMoHi8FUVh2RdFv3YD6xjjfxZ6nPqEjQbmxQzHbpBFE6hWxouq\n\n\n/api/v1/addresses/{address}/transactions\nGet address transactions\nhttps://api.ergoplatform.com/api/v1/addresses/9iMoHi8FUVh2RdFv3YD6xjjfxZ6nPqEjQbmxQzHbpBFE6hWxouq/transactions\n\n\n/api/v1/addresses/{address}/balance/confirmed\nGet confirmed balance\nhttps://api.ergoplatform.com/api/v1/addresses/9iMoHi8FUVh2RdFv3YD6xjjfxZ6nPqEjQbmxQzHbpBFE6hWxouq/balance/confirmed\n\n\n/api/v1/boxes/unspent/byAddress/{address}\nGet unspent boxes by address\nhttps://api.ergoplatform.com/api/v1/boxes/unspent/byAddress/9iMoHi8FUVh2RdFv3YD6xjjfxZ6nPqEjQbmxQzHbpBFE6hWxouq\n\n\n/api/v1/boxes/unspent/byErgoTree/{ergoTree}\nGet unspent boxes by ErgoTree\nhttps://api.ergoplatform.com/api/v1/boxes/unspent/byErgoTree/{ergoTreeHex}\n\n\n/api/v1/boxes/unspent/byTokenId/{tokenId}\nGet unspent boxes containing token\nhttps://api.ergoplatform.com/api/v1/boxes/unspent/byTokenId/03faf2cb329f2e90d6d23b58d91bbb6c046aa143261cc21f52fbe2824bfcbf04\n\n\n/api/v1/boxes/{boxId}\nGet box by ID\nhttps://api.ergoplatform.com/api/v1/boxes/851dd1bdd06a0f0f8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a\n\n\n/api/v1/transactions/{txId}\nGet transaction by ID\nhttps://api.ergoplatform.com/api/v1/transactions/851dd1bdd06a0f0f8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a\n\n\n/api/v1/tokens/{tokenId}\nGet token information\nhttps://api.ergoplatform.com/api/v1/tokens/03faf2cb329f2e90d6d23b58d91bbb6c046aa143261cc21f52fbe2824bfcbf04\n\n\n/api/v1/blocks/{blockId}\nGet block by ID\nhttps://api.ergoplatform.com/api/v1/blocks/851dd1bdd06a0f0f8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a\n\n\n/api/v1/info\nGet blockchain info\nhttps://api.ergoplatform.com/api/v1/info\n(Note: Replace placeholders like {address}, {ergoTreeHex}, {tokenId}, {boxId}, {txId}, {blockId} with actual values.)"
    },
    {
      "heading": "JavaScript/TypeScript (with Axios)#",
      "content": "import axios from 'axios';\n\n// Configuration\nconst explorerBaseUrl = 'https://api.ergoplatform.com/api/v1';\n\n// Create a reusable client with error handling\nconst explorerClient = axios.create({\n  baseURL: explorerBaseUrl,\n  timeout: 10000, // 10 second timeout\n  headers: {\n    'Accept': 'application/json',\n  }\n});\n\n// Add response interceptor for detailed error logging\nexplorerClient.interceptors.response.use(\n  response => response,\n  error => {\n    if (error.response) {\n      // Request made and server responded with a status code outside 2xx range\n      console.error('Explorer API Error:', error.response.status, error.response.data);\n    } else if (error.request) {\n      // Request made but no response received\n      console.error('Explorer API No Response:', error.request);\n    } else {\n      // Error setting up the request\n      console.error('Explorer API Request Setup Error:', error.message);\n    }\n    return Promise.reject(error); // Propagate the error\n  }\n);\n\n// Get address information\nasync function getAddressInfo(address: string) {\n  try {\n    const response = await explorerClient.get(`/addresses/${address}`);\n    return response.data;\n  } catch (error) {\n    console.error(`Failed to get info for address ${address}`);\n    // Optionally return null or a default object instead of throwing\n    return null; \n  }\n}\n\n// Get address balance (confirmed)\nasync function getAddressBalance(address: string) {\n  try {\n    const response = await explorerClient.get(`/addresses/${address}/balance/confirmed`);\n    return response.data;\n  } catch (error) {\n    console.error(`Failed to get balance for address ${address}`);\n    return null;\n  }\n}\n\n// Get unspent boxes for an address (first page)\nasync function getUnspentBoxes(address: string, limit: number = 50) {\n  try {\n    // API might use 'items' array and 'total' count for pagination\n    const response = await explorerClient.get(`/boxes/unspent/byAddress/${address}`, { params: { limit } });\n    return response.data.ite..."
    },
    {
      "heading": "Python Example#",
      "content": "import requests\nimport time\nfrom typing import Dict, List, Any, Optional\n\nclass ErgoExplorerClient:\n    \"\"\"A simple client for interacting with the Ergo Explorer API v1.\"\"\"\n\n    def __init__(self, base_url: str = \"https://api.ergoplatform.com/api/v1\"):\n        self.base_url = base_url\n        self.session = requests.Session()\n        self.session.headers.update({\n            \"Accept\": \"application/json\",\n            \"User-Agent\": \"ErgoDocsPythonClient/1.0\" # Good practice to identify your client\n        })\n\n    def _request(self, method: str, endpoint: str, **kwargs) -> Optional[Dict[str, Any]]:\n        \"\"\"Internal method to handle API requests with retries and error logging.\"\"\"\n        url = f\"{self.base_url}/{endpoint.lstrip('/')}\"\n        max_retries = 3\n        retry_delay = 1  # seconds\n\n        for attempt in range(max_retries):\n            try:\n                response = self.session.request(method, url, timeout=10, **kwargs) # 10 second timeout\n                response.raise_for_status() # Raises HTTPError for bad responses (4xx or 5xx)\n                return response.json()\n            except requests.exceptions.HTTPError as e:\n                print(f\"HTTP Error: {e.response.status_code} for URL {url}. Response: {e.response.text}\")\n                if e.response.status_code == 429: # Rate limited\n                    retry_after = int(e.response.headers.get('Retry-After', retry_delay))\n                    print(f\"Rate limited. Retrying after {retry_after} seconds...\")\n                    time.sleep(retry_after)\n                    retry_delay = retry_after + 1 # Add buffer\n                elif attempt < max_retries - 1:\n                    print(f\"Retrying in {retry_delay} seconds...\")\n                    time.sleep(retry_delay)\n                    retry_delay *= 2 # Exponential backoff\n                else:\n                    print(f\"Request failed after {max_retries} attempts.\")\n                    return None # Return None on final failure\n            exc..."
    },
    {
      "heading": "Rate Limiting and Best Practices#",
      "content": "Public APIs are shared resources. To ensure reliable operation and avoid being blocked, follow these best practices:\nUnderstand Rate Limits: Check the API documentation or community resources for stated rate limits (e.g., requests per second per IP). The main Ergo Explorer API often has limits around 10-20 req/sec. Exceeding limits can lead to 429 Too Many Requests errors or temporary IP bans.\nImplement Caching: Avoid fetching the same data repeatedly. Cache responses locally (in memory for short durations, or using persistent stores like Redis for longer) with appropriate Time-To-Live (TTL) values. Re-fetch only when the cache expires or specific events indicate data might have changed.\n    // Simple in-memory cache concept (JS)\nconst cache = new Map();\nconst CACHE_TTL = 60000; // 1 minute\n\nasync function getCachedData(url) {\n  const now = Date.now();\n  if (cache.has(url) && (now - cache.get(url).timestamp < CACHE_TTL)) {\n    return cache.get(url).data;\n  }\n  // Fetch fresh data if not cached or expired\n  const response = await fetch(url); // Use fetchWithRetry here\n  if (!response.ok) throw new Error(`API Error: ${response.status}`);\n  const data = await response.json();\n  cache.set(url, { data, timestamp: now });\n  return data;\n}\n\nUse Retry Logic with Exponential Backoff: If a request fails (especially due to rate limiting or transient network issues), don't immediately retry. Wait for a short period and increase the delay exponentially for subsequent retries. Respect the Retry-After header if provided in a 429 response.\n    # Conceptual retry logic within the Python client's _request method (see above)\n# Handles retries with increasing delay for transient errors and respects Retry-After\n\nBe Specific: Request only the data you need. Use API parameters (limit, offset, specific endpoints) to narrow down results instead of fetching large datasets and filtering client-side.\nIdentify Your Client: Use a descriptive User-Agent header in your requests so API providers ca..."
    },
    {
      "heading": "Pros & Cons Summary#",
      "content": "Pros: Simple to start, convenient endpoints.\nCons: Third-party reliance, rate limits, limited query flexibility, potential latency, centralization risk."
    },
    {
      "heading": "When to Use#",
      "content": "Simple applications, prototypes, low-volume tools.\nWhen reliance on a third party is acceptable.\nWhen required data fits well with available API endpoints.\nWhile convenient, the limitations often lead developers towards more robust solutions for production applications."
    }
  ],
  "qa_pairs": []
}