{
  "title": "Using Appkit from Python - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/dev/stack/appkit/appkit_py/",
  "summary": "To use Appkit from Python, you need to bridge to a JVM instance running the Appkit code. To do so, we use JPype for this guide. It is presumed that you've already set up a proper Python environment. Install jpype in your Python environment by typing (or pip3 when using Python3). For Appkit to work on your system, you'll need a JDK8 or JDK11 installed and you need the appkit \"fat jar\", that means a jar containing all dependencies to add to your project.",
  "keywords": [
    "appkit",
    "python",
    "instance",
    "code",
    "jpype",
    "guide",
    "environment",
    "install",
    "python3",
    "system",
    "jdk8",
    "jdk11",
    "dependency",
    "project",
    "release",
    "page",
    "wrapper",
    "option",
    "ergo",
    "method",
    "java",
    "kotlin",
    "scala",
    "logic",
    "language",
    "recommendation",
    "approach",
    "downside",
    "completion",
    "news",
    "thing",
    "look",
    "transaction",
    "import",
    "ergoclient",
    "copy",
    "blockchaincontext",
    "function",
    "class",
    "interface",
    "construct",
    "annotation",
    "roundtrip",
    "reducedtransaction",
    "feature",
    "base64",
    "encoding",
    "part",
    "ergopay",
    "request",
    "token",
    "knowledge",
    "boxoperations.minttokentocontracttxunsigned",
    "lambda",
    "time",
    "helper",
    "eip4tokenbuilder",
    "complexity",
    "tokenbuilder",
    "minttokenexecutor",
    "apply",
    "picture",
    "eip4tokenbuilder.buildnftpicturetoken",
    "address",
    "boxoperations",
    "object",
    "withamounttospend",
    "amount",
    "reduce",
    "format",
    "transmission",
    "get_base64_reduced_tx",
    "artefact",
    "https://github.com/ergo-pad/ergo-python-appkit"
  ],
  "sections": [
    {
      "heading": "Using AppKit from Python#",
      "content": "To use Appkit from Python, you need to bridge to a JVM instance running the Appkit code. To do so, we use JPype for this guide. It is presumed that you've already set up a proper Python environment."
    },
    {
      "heading": "General setup#",
      "content": "Install jpype in your Python environment by typing\npip install JPype1\n(or pip3 when using Python3).\nFor Appkit to work on your system, you'll need a JDK8 or JDK11 installed and you need the appkit \"fat jar\", that means a jar containing all dependencies to add to your project. You can find this jar on the releases page or build it yourself. (How to build the fat jar)\nThe general wrapper for your Python code is then something like this:\n# Enable Java imports\nimport jpype.imports\n\n# Pull in types\nfrom jpype.types import *\n\n# Launch the JVM\njpype.startJVM()\n# Add Appkit fat jar to JVM classpath\njpype.addClassPath(\"ergo-appkit-fat-jar.jar\")\n\nimport java.lang\n\n# ----> add your ergo related code here\n\njpype.shutdownJVM()\nYou have two options to implement your ergo related code: You can do everything in your Python code \nand call all necessary Appkit methods from Python, or you create an own Java/Kotlin/Scala project and\nimplement your necessary logic in these languages providing some methods for simpler use from Python.\nA general recommendation which approach is more useful can't be given - while Appkit is a bit more easier\nto use from JVM, you most likely are more comfortable coding Python if you read this guide, so you might\nprefer using Python.\nA downside is that code completion is not working for Appkit methods within Python (or at least there was\nno way found so far). The good news is that most things work pretty straightforward so code completion is\nnot a must have."
    },
    {
      "heading": "Construct an Ergo transaction#",
      "content": "Let's take a look on how to construct an ergo transaction in Appkit. In Java this is done the following way:\n// file header\n    import org.ergoplatform.appkit.Address;\n    import org.ergoplatform.appkit.BoxOperations;\n    import org.ergoplatform.appkit.NetworkType;\n    import org.ergoplatform.appkit.RestApiErgoClient;\n\n    // within a method\n    NetworkType networkType = NetworkType.TESTNET;\n    RestApiErgoClient.create(\n            \"http://213.239.193.208:9052/\", // use your node or a public node here\n            networkType,\n            \"\",\n            RestApiErgoClient.getDefaultExplorerUrl(networkType)\n    ).execute(ctx -> {\n        ErgoTreeContract contract = recipient.toErgoContract();\n        UnsignedTransaction unsignedTransaction = BoxOperations.createForSender(sender)\n                .withAmountToSpend(amountToSend)\n                .putToContractTxUnsigned(ctx, contract);\n\n        // reduce the transaction for use with ErgoPay\n        return ctx.newProverBuilder().build().reduce(unsignedTransaction, 0);\n    });\nHow to translate this to Python?\nAt first we need to declare all used imports. These can be done straightforward by looking at the Java imports:\nfrom org.ergoplatform.appkit import RestApiErgoClient, NetworkType, BoxOperations, Address\nConstructing the ErgoClient is also a straightforward copy from the Java code:\nnetwork_type = NetworkType.TESTNET\nnode_client = RestApiErgoClient.create(\"http://213.239.193.208:9052/\", network_type, \"\",\n                                       RestApiErgoClient.getDefaultExplorerUrl(network_type))\nTo execute code within a BlockchainContext, a lambda function is used within Java:\nergoClient.execute(ctx -> {\n    // ....\n    });\nInternally, lambda functions in Java are nothing more than an anonymous class implementing a special interface.\nSo to adapt this construct into Python, we need to define such a class implementing this interface. JPype provides\nspecial annotations for this:\n@JImplements(java.util.function.Function)\n..."
    },
    {
      "heading": "Minting a token#",
      "content": "For minting a token, you can make use of your knowledge gained above and by using Boxoperations.mintTokenToContractTxUnsigned().\nThis method takes another lambda for building the actual token, so this time we need two helper classes.\nBuilding the token itself is easy: Eip4TokenBuilder provides all necessary methods to hide away complexity.\n# Import the Eip4TokenBuilder class from the ergoplatform library \nfrom org.ergoplatform.appkit.impl import Eip4TokenBuilder\n\n# Define a helper class for the executor\n@JImplements(java.util.function.Function)\nclass TokenBuilder(object):\n    @JOverride\n    # Define the apply function for the TokenBuilder class\n    def apply(self, token_id):\n        # Build a non-fungible picture token with Eip4TokenBuilder\n        return Eip4TokenBuilder.buildNftPictureToken(token_id, 1, \"Picture token\", \"Description\", 0, bytearray(), \"ipfs://...\")\n\n# Define the MintTokenExecutor class\n@JImplements(java.util.function.Function)\nclass MintTokenExecutor(object):\n    # Initialize the class with a provided address\n    def __init__(self, address):\n        self.address = address\n\n    @JOverride\n    # Define the apply function for the MintTokenExecutor class\n    def apply(self, blockchain_context):\n        # Set the round_trip_address to the class address\n        round_trip_address = self.address\n        # Create a BoxOperations object with the sender's address\n        unsigned_tx = BoxOperations.createForSender(Address.create(round_trip_address), blockchain_context).withAmountToSpend(1000 * 1000).mintTokenToContractTxUnsigned(Address.create(round_trip_address).toErgoContract(), TokenBuilder())\n        # Return the reduced unsigned transaction from the newProverBuilder\n        return blockchain_context.newProverBuilder().build().reduce(unsigned_tx, 0)\n\n# Print the reduced transaction from the MintTokenExecutor class\nprint(get_base64_reduced_tx(MintTokenExecutor(\"3Wwxnaem5ojTfp91qfLw3Y4Sr7ZWVcLPvYSzTsZ4LKGcoxujbxd3\")))\nThis code defines two classes, TokenBu..."
    },
    {
      "heading": "Please note#",
      "content": "You can find published Python artefacts here https://github.com/ergo-pad/ergo-python-appkit"
    }
  ],
  "qa_pairs": []
}