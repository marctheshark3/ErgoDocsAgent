{
  "title": "Global Functions - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/dev/scs/global-functions/",
  "summary": "There are a variety of global functions available for use in ErgoScript. Here, we will go through some of the most commonly used functions (besides sigmaProp). A complete reference for all global functions and types can be found in the ErgoScript LangSpec. Logical functions are global functions that operate on booleans. These functions include operators such as && and ||, along with the following commonly used functions.",
  "keywords": [
    "variety",
    "function",
    "ergoscript",
    "sigmaprop",
    "reference",
    "type",
    "langspec",
    "boolean",
    "operator",
    "allof",
    "collection",
    "booleans",
    "evaluate",
    "inserting",
    "anyof",
    "xorof",
    "operation",
    "return",
    "number",
    "knowledge",
    "sigmaprops",
    "property",
    "truth",
    "integer",
    "zkproof",
    "block",
    "code",
    "scoping",
    "contract",
    "root",
    "cryptography",
    "hashing",
    "calculation",
    "groupelement",
    "value",
    "blake2b256",
    "coll[byte",
    "hash",
    "algorithm",
    "ergo",
    "part",
    "autolykos",
    "mine",
    "sha256",
    "decodepoint",
    "group",
    "element",
    "provedhtuple",
    "diffie",
    "hellman",
    "signature",
    "protocol",
    "multisignature",
    "ring",
    "setting",
    "provedlog",
    "logarithm",
    "problem",
    "compile",
    "time",
    "spending",
    "script",
    "ergotree",
    "language",
    "string",
    "compilation",
    "frombase64",
    "base",
    "address",
    "base58",
    "network",
    "identifier",
    "prefix",
    "deserialize[t",
    "parameter",
    "datum",
    "getvar[t",
    "context",
    "variable",
    "variables",
    "chain",
    "transaction",
    "creation",
    "change",
    "information",
    "substconstant",
    "contract\u00e2\u0080\u0099s",
    "proposition",
    "byte",
    "content",
    "constant",
    "\u00e2\u0080\u009ctemplate\u00e2\u0080\u009d",
    "sample",
    "scriptbytes",
    "position",
    "newvalues"
  ],
  "sections": [
    {
      "heading": "Global Functions#",
      "content": "There are a variety of global functions available for use in ErgoScript. Here, we will go through some of the most commonly used functions (besides sigmaProp). A complete reference for all global functions and types can be found in the ErgoScript LangSpec."
    },
    {
      "heading": "Logical Functions#",
      "content": "Logical functions are global functions that operate on booleans. These functions include operators such as && and ||, along with the following commonly used functions."
    },
    {
      "heading": "AllOf#",
      "content": "The allOf function takes a collection of booleans and returns a boolean indicating whether all booleans within the collection evaluate to true. It is equivalent to inserting && between each boolean in the collection."
    },
    {
      "heading": "AnyOf#",
      "content": "The anyOf function takes a collection of booleans and returns a boolean indicating whether at least one boolean within the collection evaluates to true. It is equivalent to inserting || between each boolean in the collection."
    },
    {
      "heading": "XorOf#",
      "content": "The xorOf function takes a collection of booleans and applies the XOR operation across the booleans within the collection. Therefore, xorOf returns true if an odd number of booleans within the collection evaluates to true, and false if an even number evaluates to true."
    },
    {
      "heading": "Zero-Knowledge Functions#",
      "content": "Zero-knowledge functions allow evaluating SigmaProps while preserving the zero-knowledge properties needed to verify the truth of the given SigmaProps."
    },
    {
      "heading": "AtLeast#",
      "content": "The atLeast function takes an integer k and a collection of SigmaProps and returns whether at least k SigmaProps within the collection evaluate to true. All SigmaProps are evaluated with zero knowledge."
    },
    {
      "heading": "ZKProof#",
      "content": "The ZKProof function takes a block of code and evaluates all operations within the code block under zero-knowledge scoping. This may be useful if some operations within your contract must be kept private. The code block must not use boolean operations to ensure zero-knowledge and must evaluate to a single root SigmaProp."
    },
    {
      "heading": "Cryptographic Functions#",
      "content": "Cryptographic functions are functions related to cryptography, such as hashing and calculations over GroupElement values."
    },
    {
      "heading": "Blake2b256#",
      "content": "blake2b256 takes a Coll[Byte] and returns a new Coll[Byte] representing the hash according to the Blake2b256 algorithm. The Blake2b256 algorithm is the main hashing algorithm used within Ergo and is also incorporated as part of the Autolykos PoW algorithm used to mine Ergo."
    },
    {
      "heading": "Sha256#",
      "content": "sha256 takes a Coll[Byte] and returns a new Coll[Byte] representing the hash according to the SHA256 hashing function."
    },
    {
      "heading": "DecodePoint#",
      "content": "decodePoint takes a Coll[Byte] representing a group element and converts it into the GroupElement type."
    },
    {
      "heading": "ProveDHTuple#",
      "content": "proveDHTuple takes four GroupElement values and constructs a public key represented by a SigmaProp according to the Diffie-Hellman signature protocol. This is useful for creating shared public keys in multisignature and ring signature settings."
    },
    {
      "heading": "ProveDLog#",
      "content": "proveDlog takes a GroupElement and creates a SigmaProp representing a public key based on the discrete logarithm problem."
    },
    {
      "heading": "Compile-Time Functions#",
      "content": "Compile-time functions are not evaluated during the spending of the script; instead, these functions are used when compiling an ErgoScript contract into the native ErgoTree language. These functions take Strings (which is not an actual ErgoScript type) and convert them into an ErgoScript type during contract compilation. These values are stored directly within the contract and cannot change once the contract has been compiled."
    },
    {
      "heading": "FromBase#",
      "content": "Two functions, fromBase64 and fromBase58, take strings in their respective base and convert them into a Coll[Byte] at compile time."
    },
    {
      "heading": "PK#",
      "content": "The PK function takes an address string (which is a base58 encoded GroupElement with a network identifier prefix) and converts it into a SigmaProp representing a public key at compile time. This is done using many of the functions listed above."
    },
    {
      "heading": "Deserialize#",
      "content": "The deserialize[T] function takes a type parameter T and a base58 encoded string of binary data. The string value is converted into a value of ErgoScript type T at compile time."
    },
    {
      "heading": "GetVar#",
      "content": "getVar[T] takes a type parameter T and an integer tag, returning a Context Variable of the given type associated with that tag. Context Variables are specific off-chain variables that can be attached to any box at the time of transaction creation. Context variables allow for robust changes to certain parameters within your contract. It is especially useful for providing generic contracts that rely on off-chain information that may change between different spending transactions."
    },
    {
      "heading": "SubstConstants#",
      "content": "The substConstants function has the following signature:\ndef substConstants[T](scriptBytes: Coll[Byte],\n positions: Coll[Int], newValues: Coll[T]): Coll[Byte]\nIt allows constructing another contract\u00e2\u0080\u0099s proposition bytes using the given parameters. Because a contract\u00e2\u0080\u0099s address is created using its contents, inputting different constants within a contract can change its address (and therefore, the contract itself). This function allows for a contract of the same \u00e2\u0080\u009ctemplate\u00e2\u0080\u009d to be created using a new set of constants. To be used properly, one must provide a sample of the contract\u00e2\u0080\u0099s proposition bytes (parameter scriptBytes), along with the positions at which certain constants of type T must be replaced with the corresponding values in the newValues parameter."
    },
    {
      "heading": "Example: Alcohol Sale Proxy Contract#",
      "content": "{\n    // ====== Alcohol Sale Proxy Contract Example ====== // \n\n    // Hard-coded constants expected at compile time are written in UpperCamelCase.\n\n    // INPUTS:\n    // license          = INPUTS(0)\n    // buyerProxyInputs = INPUTS - INPUTS(0)\n    //\n    // OUTPUTS:\n    // storeBox              = OUTPUTS(0)\n    // provincialSalesTaxBox = OUTPUTS(1)\n    // federalSalesTaxBox    = OUTPUTS(2)\n    // buyerWalletBox        = OUTPUTS(3)\n    // minerFeeBox           = OUTPUTS(4)\n    //\n    // (*) Note: \n    //           1. Mining fee box is always the last box in the set of OUTPUTS of a transaction,\n    //              I am just showing this for clarity, but it will not be accessed in this contract.\n        //           2. If there is any that change remains in the proxy, \n    //              it is sent back to the buyer wallet.\n\n    // Contract variables\n    val buyerPK: SigmaProp          = PK(buyerPKString)\n    val buyerProxyInputs: Coll[Box] = INPUTS.filter({ (input: Box) => input.propositionBytes == SELF.propositionBytes })\n    val buyerAmount: Long           = buyerProxyInputs.fold(0L)({ (input: Box, acc: Long) => acc + input.value })\n    val provincialSalesTax: Long    = (AlcoholSaleAmount * ProvincialSalesTaxNum) / ProvincialSalesTaxDenom\n    val federalSalesTax: Long       = (AlcoholSaleAmount * FederalSalesTaxNum) / FederalSalesTaxDenom\n    val totalCost: Long             = AlcoholSaleAmount + provincialSalesTax + federalSalesTax + MinerFee\n\n    // Variables associated with the buyer's license\n    val license = INPUTS(0)\n    val id      = license.R4[Coll[Byte]].get\n    val name    = license.R5[Coll[Byte]].get\n    val bDay    = license.R6[Coll[Byte]].get\n    val address = license.R7[Coll[Byte]].get\n    val expDate = license.R8[Coll[Byte]].get\n\n    // Context variables needed for the proxy contract, assuming they are provided correctly\n    val licenseTemplateContractBytes = getVar[Coll[Byte]](0).get\n\n    // Substitute the constants of the license template contract..."
    }
  ],
  "qa_pairs": []
}