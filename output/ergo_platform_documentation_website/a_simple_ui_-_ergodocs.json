{
  "title": "A simple UI - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/dev/stack/mosaik/tutorial2/",
  "summary": "In Part 1 of this tutorial series for Ergo Mosaik, we have seen that Ergo Mosaik is a UI layer for dApps using Ergo. It is not the exclusive UI layer but aims to streamline the development process for dApp developers by providing a way to implement both off-chain code and UI code on the same tech stack. Additionally, some wallet applications ship with a built-in Mosaik executor so that your dApp UI can be used within these wallet applications. Mosaik apps are a JSON-based markup language and can be generated by the tech stack of your choice. A reference implementation is provided by the Ergo core team to be used from Kotlin/JVM.",
  "keywords": [
    "part",
    "series",
    "ergo",
    "mosaik",
    "layer",
    "dapps",
    "development",
    "process",
    "dapp",
    "developer",
    "chain",
    "code",
    "tech",
    "stack",
    "wallet",
    "application",
    "ship",
    "executor",
    "json",
    "language",
    "choice",
    "reference",
    "implementation",
    "core",
    "team",
    "kotlin",
    "functionality",
    "appkit",
    "ergo\u00e2\u0080\u0099s",
    "hand",
    "library",
    "java",
    "ecosystem",
    "programming",
    "domain",
    "self",
    "feature",
    "user",
    "interface",
    "spring",
    "boot",
    "framework",
    "building",
    "service",
    "rest",
    "website",
    "battle",
    "example",
    "let\u00e2\u0080\u0099s",
    "you\u00e2\u0080\u0099ll",
    "need",
    "system",
    "source",
    "version",
    "intellij",
    "environment",
    "project",
    "initializr",
    "start.spring.io",
    "change",
    "\u00e2\u0080\u009cgradle",
    "project\u00e2\u0080\u009d",
    "\u00e2\u0080\u009ckotlin\u00e2\u0080\u009d",
    "\u00e2\u0080\u009cjava\u00e2\u0080\u009d",
    "name",
    "dependency",
    "\u00e2\u0080\u009cspre",
    "web\u00e2\u0080\u009d.",
    "file",
    "directory",
    "gradle",
    "time",
    "index",
    "terminal",
    "command",
    "gradlw",
    "bootrun",
    "windows",
    "server",
    "line",
    "port",
    "check",
    "\u00e2\u0080\u009cwhitelabel",
    "error",
    "success",
    "spring\u00e2\u0080\u0099s",
    "handling",
    "page\u00e2\u0080\u009d.",
    "class",
    "\u00e2\u0080\u009cmosaikappcontroller.kt\u00e2\u0080\u009d",
    "\u00e2\u0080\u009cpackage\u00e2\u0080\u009d",
    "\u00e2\u0080\u009cmosaikappapplication\u00e2\u0080\u009d.",
    "annotate",
    "method",
    "localhost:8080",
    "browser",
    "\u00e2\u0080\u009chello\u00e2\u0080\u009d",
    "that\u00e2\u0080\u0099s",
    "@restcontroll",
    "annotation",
    "singleton",
    "won\u00e2\u0080\u0099t",
    "trick",
    "endpoint",
    "request",
    "\u00e2\u0080\u009c/\u00e2\u0080\u009d",
    "object",
    "case",
    "string",
    "serialization",
    "datum",
    "nexus",
    "build",
    "tool",
    "build.gradle.kts",
    "section",
    "moment",
    "extension",
    "entry",
    "repository",
    "tweak",
    "default",
    "jackson",
    "configuration",
    "following",
    "\u00e2\u0080\u009cobject",
    "mapper\u00e2\u0080\u009d",
    "setup",
    "desktop",
    "debugging",
    "screen",
    "phrase",
    "getmainpage",
    "mosaikapp",
    "parameter",
    "view",
    "element",
    "demo",
    "you\u00e2\u0080\u0099ve",
    "group",
    "column",
    "there\u00e2\u0080\u0099s",
    "card",
    "root",
    "label",
    "text",
    "content",
    "viewtree",
    "button",
    "message",
    "layout",
    "padding",
    "outline",
    "people",
    "design",
    "side",
    "margin",
    "element\u00e2\u0080\u0099s",
    "neighboring",
    "child",
    "suiting",
    "style",
    "onclickaction",
    "action",
    "dialog",
    "thank",
    "ctrl",
    "click",
    "expression",
    "viewcontent",
    "assign",
    "property",
    "mind",
    "scene",
    "work",
    "behavior",
    "clashingaction",
    "look",
    "problem"
  ],
  "sections": [
    {
      "heading": "2: Building a simple UI with Mosaik Kotlin DSL and Spring Boot#",
      "content": "In Part 1 of this tutorial series for Ergo Mosaik, we have seen that Ergo Mosaik is a UI layer for dApps using Ergo. It is not the exclusive UI layer but aims to streamline the development process for dApp developers by providing a way to implement both off-chain code and UI code on the same tech stack. Additionally, some wallet applications ship with a built-in Mosaik executor so that your dApp UI can be used within these wallet applications.\nMosaik apps are a JSON-based markup language and can be generated by the tech stack of your choice. A reference implementation is provided by the Ergo core team to be used from Kotlin/JVM.\nThis choice was made because Kotlin/JVM can utilize the full functionality of ergo-appkit, Ergo\u00e2\u0080\u0099s first-hand SDK, and all libraries in the Java ecosystem, as well as providing a well-balanced mix of imperative and functional programming. Kotlin can process domain-specific languages and self-defined DSLs. This feature was used to give a Mosaik DSL with which the Mosaik user interface can be described naturally.\nBecause Kotlin/JVM seamlessly interoperates with the Java ecosystem, we can use Spring Boot to serve our Mosaik app to its executors. Spring Boot is a Java framework for building web services - REST APIs and dynamic websites - battle-tested, feature-rich and well-documented. You don\u00e2\u0080\u0099t need to use it when creating a Mosaik app, but we use it here in our examples because it helps implement REST APIs with very clean code.\nSo, let\u00e2\u0080\u0099s hop onto coding. You\u00e2\u0080\u0099ll need Java 11 installed on your system (open-source version preferred), and we recommend IntelliJ as the development environment, but you are free to use something else."
    },
    {
      "heading": "Setting up a Spring Boot project#",
      "content": "To set up a Spring Boot project, visit the Spring Initializr on start.spring.io. Change project to \u00e2\u0080\u009cGradle project\u00e2\u0080\u009d, language to \u00e2\u0080\u009cKotlin\u00e2\u0080\u009d, \u00e2\u0080\u009cJava\u00e2\u0080\u009d to \u00e2\u0080\u009c11\u00e2\u0080\u009d, and set the names as you want.\nAs dependencies, choose \u00e2\u0080\u009cSpring Web\u00e2\u0080\u009d.\nYou should end up with something like this:\nGenerate the project, extract the zip file and open the directory with the IDE of your choice. Using IntelliJ or another Gradle-compatible IDE will sync some time to download and index all dependencies.\nTo start the Spring Boot application, you can use the Terminal command\n./gradlew bootRun (or gradlw bootRun on Windows)\nto start your application server.\nThe command line will tell you that this worked and that the server is listening on port 8080:\nA quick check on http://localhost:8080 will give you a \u00e2\u0080\u009cWhitelabel error page\u00e2\u0080\u009d. What sounds like an error means success; it is Spring\u00e2\u0080\u0099s way to tell you that there\u00e2\u0080\u0099s nothing defined it can serve and no error handling defined. Hence the \u00e2\u0080\u009cwhitelabel error page\u00e2\u0080\u009d.\nLet\u00e2\u0080\u0099s change this by adding a class \u00e2\u0080\u009cMosaikAppController.kt\u00e2\u0080\u009d in the same directory (or better: \u00e2\u0080\u009cpackage\u00e2\u0080\u009d) as our main \u00e2\u0080\u009cMosaikappApplication\u00e2\u0080\u009d. Annotate this class and add a method as shown:\n@RestController\nclass MosaikAppController {\n   @GetMapping(\"/\")\n   fun getMainPage(): String {\n       return \"Hello\"\n   }\n}\nIf you start the server again and visit localhost:8080 in your web browser, you will see that \u00e2\u0080\u009cHello\u00e2\u0080\u009d is printed. That\u00e2\u0080\u0099s even more success.\nWhat did we do to achieve this?\nThe @RestController annotation on the new class tells Spring that this class should be instantiated as a singleton, and its methods are designed for Rest APIs. Adding a method alone won\u00e2\u0080\u0099t do the trick, though: the API endpoint must be defined. That\u00e2\u0080\u0099s why the method itself has another annotation, which defines this method should be called when a GET request to path \u00e2\u0080\u009c/\u00e2\u0080\u009d comes in.\nReturned objects of the REST API methods are automatically serialized to JSON by Spring. In th..."
    },
    {
      "heading": "Adding Mosaik to the project#",
      "content": "After making sure that Spring Boot is working, we now have to add Mosaik to the app. In the JVM ecosystem, libraries are served by Nexus servers, and the build tool fetches these libraries and adds them to the project during the build. We use Gradle as our build tool, and the dependencies for our project are declared in the build.gradle.kts file. Open it. You will find the following section:\ndependencies {\n  implementation(\"org.springframework.boot:spring-boot-starter-web\")\n  implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin\")\n  implementation(\"org.jetbrains.kotlin:kotlin-reflect\")\n  implementation(\"org.jetbrains.kotlin:kotlin-stdlib-jdk8\")\n  testImplementation(\"org.springframework.boot:spring-boot-starter-test\")\n}\nSo at the moment, spring boot web and some Kotlin extensions are declared. We add mosaik below the existing entries:\n// Mosaik\nval mosaikVersion = \"0.5.0\"\nimplementation(\"com.github.MrStahlfelge.mosaik:common-model:$mosaikVersion\")\nimplementation(\"com.github.MrStahlfelge.mosaik:common-model-ktx:$mosaikVersion\")\nimplementation(\"com.github.MrStahlfelge.mosaik:serialization-jackson:$mosaikVersion\")\nWe also need to declare another Nexus server that hosts these files. Change the repositories section (it is in the same build.gradle.kts file) like this:\nrepositories {\n   mavenCentral()\n   maven(\"https://jitpack.io\")\n}\nIf you use IntelliJ, it will automatically offer to resync the project. Do it, and it will download everything needed to use Mosaik.\nWell done! We need one little tweak now. As said before, Spring will automatically serialize objects to JSON. This automated serialization works well in most cases - but for some cases in Mosaik, the default serialization of Jackson, the library used by Spring here, is not what the standard describes and the executing application expects. So we need to tell Spring that some of our Mosaik objects need a different serialization than the default. Configurations like that are done on the Application class..."
    },
    {
      "heading": "A first simple screen#",
      "content": "Now we want to define the first screen users get presented when they open up our Mosaik app. This phrase already said implicit what has to come before the first screen: we must define the Mosaik app itself.\nLet's change our getMainPage method to return a Mosaik app:\n@GetMapping(\"/\")\nfun getMainPage(): MosaikApp {\n   return mosaikApp(\n       \"First Mosaik App\", // app name shown in executors\n       1 // the app version\n   ) {\n       // define the view here\n   }\n}\nmosaikApp() is a method defined in our Mosaik Kotlin DSL. It takes some parameters describing the app and, most importantly, the initial view screen.\nA view screen consists of multiple view elements, and some layout elements can contain other view elements. Check out the layout elements demo that you\u00e2\u0080\u0099ve started in part 1: You see that the three main group elements are Row, Column, and Box. There\u00e2\u0080\u0099s also Card which is nothing else than a decorated box.\nYou should use one of these group elements as your root view element on a screen. We will use a card here. Inside the card, we define a label with a standard text for a first project.\nreturn mosaikApp(\n   \"First Mosaik App\", // app name shown in executors\n   1 // the app version\n) {\n   // define the view here\n   card {\n       label(\"Hello Ergo world!\")\n   }\n}\nStart the Spring Boot server and use the desktop demo application to run your MosaikApp. It will look like this:\nWe see the app name, a somehow expected screen content, and we can also see how our viewtree looks like in JSON. Let\u00e2\u0080\u0099s spice this up a lot.\n// define the view here\ncard {\n   column(Padding.DEFAULT) {\n       label(\"Hello Ergo world!\", LabelStyle.HEADLINE2)\n\n       box(Padding.HALF_DEFAULT)\n\n       button(\"Click me\") {\n           onClickAction(showDialog(\"You clicked the button.\"))\n       }\n   }\n}\nRunning it results in this view, and the button works and presents a message.\nFor the first part, we improved the layout by adding padding between the card outline and the card contents. The padding..."
    }
  ],
  "qa_pairs": []
}