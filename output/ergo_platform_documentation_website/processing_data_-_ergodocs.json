{
  "title": "Processing data - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/dev/stack/mosaik/tutorial3/",
  "summary": "In Part 2 of this tutorial series for Ergo Mosaik, we learned how to define the first simple UI for a dApp that can be shown within Wallet applications (and by using the Mosaik web executors in web browsers as well). So far, we have seen how to show a card with a label and a button and how to run actions within Mosaik. I recommend you to take a look at the view elements demo again: Start the backend-demo-kotlin subproject from the mosaik repository and start the desktop debugger Then navigate to localhost:8080 on the desktop demo. Check out all the sub screens to get a feeling of how much is provided by Mosaik. Every page has a GitHub link at the top that brings you to the source code.",
  "keywords": [
    "part",
    "series",
    "ergo",
    "mosaik",
    "dapp",
    "wallet",
    "application",
    "executor",
    "browser",
    "card",
    "label",
    "button",
    "action",
    "look",
    "view",
    "element",
    "demo",
    "kotlin",
    "subproject",
    "repository",
    "desktop",
    "debugger",
    "screen",
    "feeling",
    "page",
    "github",
    "link",
    "source",
    "code",
    "overview",
    "showdialog",
    "openbrowser",
    "copytoclipboard",
    "interaction",
    "datum",
    "changeview",
    "other",
    "ergopay",
    "ergoauth",
    "we\u00e2\u0080\u0099ll",
    "request",
    "backend",
    "input",
    "value",
    "response",
    "logic",
    "outcome",
    "user",
    "text",
    "field",
    "mosaikcontroller",
    "time",
    "spring",
    "server",
    "process",
    "thing",
    "observation",
    "hand",
    "side",
    "json",
    "validity",
    "information",
    "screenshot",
    "\u00e2\u0080\u009cinputid\u00e2\u0080\u009d",
    "\u00e2\u0080\u009cnull\u00e2\u0080\u009d",
    "type",
    "switch",
    "string",
    "property",
    "restriction",
    "example",
    "name",
    "length",
    "character",
    "indication",
    "effect",
    "sense",
    "endpoint",
    "let\u00e2\u0080\u0099s",
    "line",
    "annotation",
    "post",
    "/enteredname",
    "method",
    "declaration",
    "object",
    "parameter",
    "@requestbody",
    "body",
    "entry",
    "backendresponse",
    "function",
    "version",
    "definition",
    "dialog",
    "case",
    "sugar",
    "replacement",
    "confuse",
    "folk",
    "behaviour",
    "situation",
    "default",
    "enforce",
    "\u00e2\u0080\u009call\u00e2\u0080\u009d",
    "\u00e2\u0080\u009cvalid\u00e2\u0080\u009d",
    "restart",
    "experience",
    "content",
    "mosaikview",
    "list",
    "root",
    "excursus",
    "group",
    "clarification",
    "column",
    "state",
    "behavior",
    "explanation",
    "message",
    "title",
    "change",
    "postvalue",
    "backendrequestaction",
    "postvaluetype",
    "valid",
    "\u00e2\u0080\u009ctitlelabel\u00e2\u0080\u009d",
    "answer",
    "reason",
    "wrapping",
    "flow",
    "project",
    "ageusd",
    "mock",
    "interface",
    "intention",
    "send",
    "amount",
    "address",
    "transaction",
    "network",
    "course",
    "introduction",
    "ingredient",
    "sneak",
    "peek"
  ],
  "sections": [
    {
      "heading": "3: Processing data#",
      "content": "In Part 2 of this tutorial series for Ergo Mosaik, we learned how to define the first simple UI for a dApp that can be shown within Wallet applications (and by using the Mosaik web executors in web browsers as well).\nSo far, we have seen how to show a card with a label and a button and how to run actions within Mosaik. I recommend you to take a look at the view elements demo again: Start the backend-demo-kotlin subproject from the mosaik repository and start the desktop debugger\n./gradlew backend-demo-kotlin:bootRun\n    ./gradlew desktop-demo:run\nThen navigate to localhost:8080 on the desktop demo. Check out all the sub screens to get a feeling of how much is provided by Mosaik. Every page has a GitHub link at the top that brings you to the source code. Use this to learn how to describe the view elements in the code.\nThere is also an overview of available actions. Most actions are much like the showDialog action we already learned about: openBrowser, copyToClipboard etc work quite similar.\nThere are some actions that are more complex. Some enable Mosaik to have real interaction and to process data with your backend, namely backendRequest() and changeView(). Some others allow initiating a blockchain interaction, namely ErgoPay and ErgoAuth. We\u00e2\u0080\u0099ll take a look at the former ones now."
    },
    {
      "heading": "Process data with backendRequest#",
      "content": "backendRequest() is an action that executes a POST request to your backend containing all input values of the current screen and expects a response with an action to run subsequently. This enables you to write complex logic in your backend resulting in different outcomes for the Mosaik app user. Your logic can operate on input values by the user. To have any input values defined, we need to add an input view element on our current screen. We start with a simple text input field. Open your MosaikController from last time and add it to your card:\ncard {\n   column(Padding.DEFAULT) {\n       label(\"Hello Ergo world!\", LabelStyle.HEADLINE2)\n\n       box(Padding.HALF_DEFAULT)\n\n\n       // this is new - begin\n\n\n       textInputField(\"inputId\", \"Enter your name\")\n\n       box(Padding.HALF_DEFAULT)\n\n\n       // this is new - end\n\n       button(\"Click me\") {\n           onClickAction(showDialog(\"You clicked the button.\", \"myaction\"))\n       }\n   }\n}\nStart your Spring server process and navigate to your app in the desktop debugger. We can observe two things: First, unsurprisingly, is that the text input field is shown and ready for input. The second observation is less obvious and perhaps not expected: The debugger shows the current values for inputs on the right-hand side above the JSON sources with validity information:\nWhen there is nothing entered (like in the screenshot above), the value for \u00e2\u0080\u009cinputId\u00e2\u0080\u009d is \u00e2\u0080\u009cnull\u00e2\u0080\u009d which is valid. Enter something. You will see the value reflected and the type switches to String.\nWhat is this validity? On many input types, you can add some properties defining restrictions on which inputs are valid. For example, we can define that only names with a length of 3 to 10 characters are valid by changing our app code like this:\ntextInputField(\"inputId\", \"Enter your name\") {\n   minValue = 3\n   maxValue = 10\n}\nRestart the app server and reload the app. You will now see that the text input field will indicate invalid inputs, and the desktop debugger w..."
    },
    {
      "heading": "Alter the screen content with changeView()#",
      "content": "changeView() is an action that contains a new mosaikView view content to attach it to the current screen. A view content is what you already delivered with your first main screen: it is an object holding a list of actions, and a root view element.\nExcursus: View element, view group, view content\nWe already know all of these objects, but to make sure no one gets confused, we list a clarification definition here.\nA view element is a basic element in a Mosaik view, like a label or a button.\nA view group is a special view element containing other view elements, like Box, Column, Row, Card.\nA view content defines the state of what Mosaik shows for your app. It is made up of is a root view element and a list of actions (which can be empty). Usually, the root view element should be a view group - otherwise, the screen would look very boring.\nThe behavior of changeView() action needs some more explanation regarding how it actually affects existing screen content:\nthe new actions defined by the view content of the changeView() action are added to the existing set of actions. (If any of the new actions\u00e2\u0080\u0099 IDs equal an ID of an already defined action, the new action replaces the existing one.)\nthe view root of the view content of the changeView() action will replace an existing view with the same id. If no view is found, or if the view root does not have an ID, the complete view tree is replaced\nThis behavior allows to alter the entire screen, or only change some single view elements.\nTo demonstrate this, let\u00e2\u0080\u0099s use our existing screen, but instead of showing a message box when a name was submitted, we change the title of the screen to show the name.\nWe will give the full code here and explain the annotated changes below:\n@RestController\n@CrossOrigin\nclass MosaikAppController {\n   @GetMapping(\"/\")\n   fun getMainPage(): MosaikApp {\n       return mosaikApp(\n           \"First Mosaik App\", // app name shown in executors\n           1 // the app version\n       ) {\n           // def..."
    }
  ],
  "qa_pairs": []
}