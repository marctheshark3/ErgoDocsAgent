{
  "title": "Transaction Chains - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/dev/scs/tx/tx-chains/",
  "summary": "In a multi-stage protocol, a transaction chain is a sequence of transactions executed in a specific order to achieve a particular outcome or goal. Each transaction in the chain depends on the successful execution of the previous one, and the overall success of the protocol relies on the successful execution of the entire chain. For example, a transaction chain in a decentralized exchange (DEX) protocol might involve several steps to execute a trade between two parties. This chain could include steps such as: In this example, each transaction depends on the successful completion of the previous one. The overall success of the trade hinges on the successful execution of the entire transaction chain.",
  "keywords": [
    "protocol",
    "transaction",
    "chain",
    "sequence",
    "order",
    "outcome",
    "goal",
    "execution",
    "success",
    "example",
    "exchange",
    "step",
    "trade",
    "party",
    "completion",
    "hinge",
    "error",
    "concept",
    "ergo",
    "dependency",
    "stage",
    "logic",
    "state",
    "utxo",
    "script",
    "rule",
    "flow",
    "datum",
    "transition",
    "si-1",
    "graph",
    "node",
    "edge",
    "contract",
    "register",
    "code",
    "propositionbytes",
    "sn-1",
    "condition",
    "output",
    "pseudocode",
    "field",
    "representation",
    "guarding",
    "ergotree",
    "repeat",
    "sn-2",
    "enforce",
    "creation",
    "sn-3",
    "practice",
    "hash",
    "out.propositionbyte",
    "state_n_code",
    "blake2b256(out.propositionbytes",
    "state_n_code_hash",
    "optimization",
    "size",
    "tree"
  ],
  "sections": [
    {
      "heading": "Transaction Chains#",
      "content": "In a multi-stage protocol, a transaction chain is a sequence of transactions executed in a specific order to achieve a particular outcome or goal. Each transaction in the chain depends on the successful execution of the previous one, and the overall success of the protocol relies on the successful execution of the entire chain.\nFor example, a transaction chain in a decentralized exchange (DEX) protocol might involve several steps to execute a trade between two parties. This chain could include steps such as:\nApproving the DEX contract to spend the required tokens from the user's wallet.\nDepositing the tokens to be traded into the DEX's smart contract box.\nPlacing an order to buy or sell tokens at a specific price.\nMatching the order with a corresponding buy or sell order from another party.\nExecuting the trade by creating a transaction that transfers the tokens and corresponding payment between the parties' boxes.\nWithdrawing the traded tokens and payment from the DEX's smart contract box back to the respective parties' wallets.\nIn this example, each transaction depends on the successful completion of the previous one. The overall success of the trade hinges on the successful execution of the entire transaction chain. If any transaction fails or encounters an error, the entire chain might fail, preventing the trade from being executed.\nTransaction chains are a fundamental concept in Ergo's multi-stage protocols. They offer a structured way to achieve specific goals by ensuring transactions execute in the correct order with the necessary dependencies between stages."
    },
    {
      "heading": "Process#",
      "content": "A transaction chain is used to create multi-stage protocols where the logic progresses sequentially through different states, represented by UTXOs (boxes). Each stage's script enforces the rules for transitioning to the next stage.\nA transaction chain representing a multi-stage protocol can be conceptualized as follows:"
    },
    {
      "heading": "1: Represent Stages as Nodes#",
      "content": "Represent the execution flow as a sequence of n states (S0, S1, ..., Sn). Each state corresponds to a UTXO protected by a specific script and containing relevant data. A transaction (Txi) acts as the transition between state Si-1 and state Si, consuming the box representing Si-1 and creating the box representing Si. This forms a directed graph where states are nodes and transactions are edges. For example, a 3-stage contract (like the ICO example) can be visualized as:\nEach state (box) contains data (in registers) and is protected by script code (propositionBytes)."
    },
    {
      "heading": "2: Enforce Transitions#",
      "content": "To ensure the protocol progresses correctly, the script guarding state Sn-1 must enforce conditions on the transaction (Txn) that spends it. Specifically, it must require that Txn creates an output box representing state Sn with the correct script and data. This is often done by checking the propositionBytes and relevant registers of the output box. An example is shown in the following pseudocode within the script for state Sn-1:\n// Ensure the output box has the same ErgoScript code as the state box and the same R4 data\n// This is used to propagate data from the state box to the output box\nout.propositionBytes == state_n_code &&\nout.R4[Int].get == SELF.R4[Int].get\nThe code above uses the propositionBytes field of a box, which contains the serialized binary representation of its guarding script (ErgoTree)."
    },
    {
      "heading": "3: Chain the Stages#",
      "content": "Repeat Step 2 for all transitions in the chain: the script for Sn-2 enforces the creation of Sn-1, the script for Sn-3 enforces the creation of Sn-2, and so on, back to the initial state S0.\nTo avoid embedding potentially large script code within the previous stage's script, it's common practice to work with hashes. Instead of checking out.propositionBytes == state_n_code, the script checks blake2b256(out.propositionBytes) == state_n_code_hash, where state_n_code_hash is a known constant hash of the expected script for the next stage. This optimization significantly reduces script size.\nNext, we will look at Transaction Trees"
    }
  ],
  "qa_pairs": []
}