{
  "title": "Modifiers Processing - ErgoDocs",
  "source_url": "https://docs.ergoplatform.com/node/modifiers-processing/",
  "summary": "Ergo's modifiers processing algorithm is a universal mechanism that operates consistently across all security modes. Unlike many blockchain systems, Ergo introduces several types of modifiers, which can be broadly classified into two categories: In-memory and Persistent. In-memory modifiers are temporary and do not persist across sessions. They include: Persistent modifiers are data elements that are stored and persist across sessions. They play a crucial role in maintaining the continuity and integrity of the Ergo network.",
  "keywords": [
    "ergo",
    "modifier",
    "processing",
    "algorithm",
    "mechanism",
    "security",
    "mode",
    "blockchain",
    "system",
    "type",
    "category",
    "memory",
    "persistent",
    "session",
    "datum",
    "element",
    "role",
    "continuity",
    "integrity",
    "network",
    "blocktransaction",
    "sequence",
    "transaction",
    "block",
    "record",
    "adproof",
    "proof",
    "correctness",
    "unspent",
    "output",
    "utxo",
    "header",
    "work",
    "link",
    "state",
    "root",
    "hash",
    "payload",
    "blocktransactions",
    "adproofs",
    "interlinks",
    "backbone",
    "utxosnapshotchunk",
    "portion",
    "chunk",
    "efficiency",
    "popowproof",
    "popow",
    "evidence",
    "addition",
    "parameter",
    "regime",
    "adstate",
    "value",
    "storage",
    "requirement",
    "verifytransaction",
    "popowbootstrap",
    "bootstrap",
    "process",
    "integer",
    "number",
    "genesis",
    "minimalsuffix",
    "suffix",
    "size",
    "constant",
    "condition",
    "operation",
    "chain",
    "message",
    "peer",
    "response",
    "getpopowproof",
    "connection",
    "receipt",
    "history",
    "history.headersheight",
    "blockstokeep",
    "height",
    "state.bestheader",
    "history.bestheader",
    "action",
    "verifytransactions",
    "text",
    "loop",
    "thread",
    "function",
    "transactionidsforheader",
    "bootstrapping",
    "setup",
    "node",
    "step",
    "request",
    "component",
    "synchronization",
    "initial",
    "setting",
    "target",
    "headers",
    "full",
    "sync"
  ],
  "sections": [
    {
      "heading": "Ergo Modifiers Processing#",
      "content": "Ergo's modifiers processing algorithm is a universal mechanism that operates consistently across all security modes. Unlike many blockchain systems, Ergo introduces several types of modifiers, which can be broadly classified into two categories: In-memory and Persistent."
    },
    {
      "heading": "In-memory Modifiers#",
      "content": "In-memory modifiers are temporary and do not persist across sessions. They include:\nTransaction: A single transaction represents an in-memory modifier.\nTransactionIdsForHeader: These are identifiers associated with transactions for a specific block.\nUTXOSnapshotManifest: These are identifiers for chunks of the Unspent Transaction Output (UTXO) set."
    },
    {
      "heading": "Persistent Modifiers#",
      "content": "Persistent modifiers are data elements that are stored and persist across sessions. They play a crucial role in maintaining the continuity and integrity of the Ergo network. The following are the types of persistent modifiers:\nBlockTransactions: These are sequences of transactions, each corresponding to a single block. They provide a detailed record of all transactions within a block.\n\n\nADProofs: These are proofs that validate the correctness of transactions relative to the corresponding Unspent Transaction Output (UTXO). They ensure that all transactions are valid and consistent with the UTXO.\n\n\nHeader: This contains essential data needed to verify Proof of Work (PoW), provides a link to the previous block, and carries the state root hash and root hash to its payload (BlockTransactions, ADProofs, Interlinks, etc). It serves as the backbone of the blockchain, linking all blocks together.\n\n\nUTXOSnapshotChunk: This represents a portion of the UTXO set. It allows the UTXO set to be managed in manageable chunks, improving efficiency.\n\n\nPoPoWProof: This is a proof of Proof of Work (PoPoW) that provides evidence of the computational work done to add a new block to the blockchain.\nIn addition to these modifiers, Ergo employs certain parameters that define a specific security regime.\nThese parameters include:\nADState: A boolean value. If true, only the state root hash is kept. This parameter helps in reducing the storage requirements by only keeping the state root hash.\n\n\nVerifyTransactions: A boolean value. If true, block transactions are downloaded and verified. This parameter ensures the integrity of the transactions within the blocks. If disabled, BlocksToKeep must equal 0.\n\n\nPoPoWBootstrap: A boolean value. If true, only the PoPoW proof is downloaded. This parameter allows for a lighter bootstrap process by only downloading the PoPoW proof.\n\n\nBlocksToKeep: An integer value specifying the number of the most recent blocks to retain with their transactions. For all other ..."
    },
    {
      "heading": "Modifiers Processing#",
      "content": "This operation involves updating the headers chain to the best in the network. The process includes sending ErgoSyncInfo messages to connected peers, receiving responses with INV messages containing ids of blocks better than the current best block, requesting headers for all ids, and reacting based on the received header.\nDuring bootstrapping, headers are downloaded. If PoPoW is true, GetPoPoWProof is sent for all connections, and upon receipt, the PoPoWProof is applied to the History. Otherwise, the headers chain is updated to the best in the network.\nAdditionally, the initial state is downloaded to start processing transactions. If ADState is true, the state is initialized with the state root hash from the header of the block BlocksToKeep blocks ago. If BlocksToKeep is less than 0 or greater than History.headersHeight, the state is initialized with the genesis state. Otherwise, the full state from BlocksToKeep blocks back in history is downloaded.\nThe state is then updated to the best headers height. If State.bestHeader equals History.bestHeader, no action is taken as the state is already updated. If VerifyTransactions is false, the state root hash is simply updated to the best header in history. If VerifyTransactions is true, transaction ids are requested from all headers without transactions, and transaction processing continues as described in the original text.\nIn regular mode, two infinite loops run in different threads, each executing the following functions:\nUpdating the headers chain to the best in the network.\nDownloading and updating full blocks as needed.\nTransaction processing continues as described in the original text, with the system requesting transaction ids from all headers without transactions, receiving TransactionIdsForHeader, and performing actions based on whether transactions are successful or not.\ndef updateHeadersChainToBestInNetwork() = {\n  1.2.1. Send ErgoSyncInfo message to connected peers\n  1.2.2. Get response with INV message,\n  cont..."
    },
    {
      "heading": "Bootstrapping#",
      "content": "Bootstrapping is the initial setup process that prepares the node for transaction processing. It involves two main steps:\nDownloading Headers: The process depends on the PoPoWBootstrap parameter. If true, the node sends a GetPoPoWProof request to peers. Upon receiving the PoPoWProof, it applies it to the History component. If false, the node updates the headers chain to the best known chain in the network using the standard synchronization process.\n\n\nDownloading Initial State: The system checks the ADState and BlocksToKeep settings to determine how to initialize the state. \n\nIf ADState is true, the state is initialized with the state root hash from the header of the block BlocksToKeep blocks ago. \nIf BlocksToKeep is less than 0 (meaning keep all blocks) or greater than the current known header height (History.headersHeight), the state is initialized with the genesis state. \nOtherwise (for pruned modes with ADState = false), the system requests a historical UTXOSnapshotManifest corresponding to the state BlocksToKeep blocks back. Upon receiving the manifest, it requests each required UTXOSnapshotChunk from peers. Received chunks are applied to the State component until the full state snapshot is reconstructed.\nAfter the initial state is downloaded or initialized, it is updated to match the best known header height. Depending on whether VerifyTransactions is enabled, this involves either just updating the state root hash or requesting and processing the necessary block transactions and AD proofs to reach the target height, as described previously.\nOnce the bootstrapping process is complete, the system transitions to regular mode."
    },
    {
      "heading": "Download headers#",
      "content": "Depending on the PoPoW value, the process varies.\nIf PoPoW is true:\n1.1.1. Send GetPoPoWProof(suffix = Max(MinimalSuffix ,BlocksToKeep)) for all connections\n1.1.2. On receive PoPoWProof, apply it to History\nIf PoPoW is false, update the headers chain to the best in the network."
    },
    {
      "heading": "Download initial State to start processing transactions#",
      "content": "The system checks for the ADState and BlocksToKeep values to decide how to initialize the state.\nif(ADState == true) {\n  Initialize state with state roothash from block header BlocksToKeep ago\n} else if(BlocksToKeep < 0 || BlocksToKeep > History.headersHeight) {\n  Initialize state with genesis State\n} else {\n/*\nWe need to download full state BlocksToKeep back in history\nTODO what if we can download state only \"BlocksToKeep - N\"\nor \"BlocksToKeep + N\" blocks back?\n*/\n  2.1. Request historical UTXOSnapshotManifest for at least BlocksToKeep back\n  2.2. On receiving UTXOSnapshotManifest:\n    UTXOSnapshotManifest.chunks.foreach ( chunk => request chunk from sender()\n/*Or from random fullnode*/\n  2.3. On receiving UTXOSnapshotChunk\n  State.applyChunk(UTXOSnapshotChunk) match {\n     case Success(Some(newMinimalState)) => GOTO 3\n     case Success(None) => stay at 2.3\n     /*we need more chunks to construct state. TODO periodicaly request missed chunks*/\n     case Failure(e) => ???\n     /*UTXOSnapshotChunk or constcucted state roothash is invalid*/\n  }\n}"
    },
    {
      "heading": "Update State to best headers height#",
      "content": "Depending on the values of State.bestHeader, History.bestHeader, and VerifyTransactions, the state is updated accordingly.\nif(State.bestHeader == History.bestHeader) {\n    //Do nothing, State is already updated\n  } else if(VerifyTransactions == false) {\n/*Just update State rootshash to best header in history*/\n    State.setBestHeader(History.bestHeader)\n  } else {\n/*we have headers chain better than full block */\n    3.1.\n      assert(history contains header chain from State.bestHeader to History.bestHeaders)\n      History.continuation(from = State.bestHeader, size = ???).get.foreach { header =>\n        sendToRandomFullNode(GetBlockTransactionsForHeader(header))\n        if(ADState == true) sendToRandomFullNode(GetADProofsForHeader(header))\n      }\n    3.2. On receiving modifiers ADProofs or BlockTransactions\n      /*TODO History should return non-empty ProgressInfo\n      only if it contains both ADProofs and BlockTransactions,\n      or it contains BlockTransactions and ADState==false*/\n      if(History.apply(modifier) == Success(ProgressInfo)) {\n        if(State().apply(ProgressInfo) == Success((newState, ADProofs))) {\n          if(ADState==false) ADProofs.foreach ( ADProof => History.apply(ADProof))\n          if(BlocksToKeep>=0)\n          /*remove BlockTransactions and ADProofs older than BlocksToKeep from history*/\n        } else {\n      /*Drop Header from history,\n      because it's transaction sequence is not valid*/\n          History.drop(modifier.headerId)\n        }\n      } else {\n        blacklistPeer\n      }\n      GOTO 3\n    }"
    },
    {
      "heading": "Regular Mode#",
      "content": "In regular mode, the system operates two infinite loops in separate threads, each performing a distinct function:\nUpdating the Headers Chain: This loop continuously updates the headers chain to match the best in the network.\n\n\nDownloading and Updating Full Blocks: This loop is responsible for downloading and updating full blocks as needed.\nThe specific actions taken within these loops depend on the values of State.bestHeader, History.bestHeader, and VerifyTransactions.\nif(State.bestHeader == History.bestHeader) {\n    // No action is taken as the state is already updated\n} else if(VerifyTransactions == false) {\n    // The state root hash is updated to the best header in history\n    State.setBestHeader(History.bestHeader)\n} else {\n    // If the headers chain is better than the full block\n    // Request transaction ids from all headers without transactions\n    assert(history contains header chain from State.bestHeader to History.bestHeaders)\n    History.continuation(from = State.bestHeader, size = ???).get.foreach { header =>\n        sendToRandomFullNode(GetTransactionIdsForHeader(header))\n        if(ADState == true) sendToRandomFullNode(GetADProofsForHeader(header))\n    }\n    // On receiving TransactionIdsForHeader\n    Mempool.apply(TransactionIdsForHeader)\n    TransactionIdsForHeader.filter(txId => !MemPool.contains(txId)).foreach { txId =>\n        request transaction with txId\n    }\n    // On receiving a transaction\n    if(Mempool.apply(transaction).isSuccess) {\n        // Broadcast INV for this transaction\n        Mempool.getHeadersWithAllTransactions { BlockTransactions =>\n            // Now we have BlockTransactions\n            // Continue with the next step\n        }\n    }\n    // Continue with the process as described in the bootstrap section\n}\nIn this mode, the system is continuously updating its state and transactions, ensuring it stays in sync with the network."
    }
  ],
  "qa_pairs": []
}