{
  "title": "Indexing Strategy: Using Public Explorer APIs",
  "source_url": "docs/dev/tutorials/blockchain-indexing/explorer-apis.md",
  "summary": "---\ntags:\n  - Indexing\n  - Explorer API\n  - Public API\n  - Off-Chain\n  - REST API\n  - Examples\n  - Rate Limiting\n---\n\n# Indexing Strategy: Using Public Explorer APIs\n\nOne of the simplest ways to access indexed Ergo blockchain data for your dApp or service is by utilizing the public APIs provided by blockchain explorers. This approach avoids the need to run your own node or indexer but comes with trade-offs regarding control, performance, and flexibility. ## Concept\n\nPublic explorers like [explorer.ergoplatform.com](https://explorer.ergoplatform.com/en/), [ergexplorer.com](https://ergexplorer.com/), and [sigmaspace.io](https://sigmaspace.io/) maintain their own indexed databases of the Ergo blockchain. They expose this data through public APIs, often RESTful, allowing developers to query for information programmatically. ## How It Works\n\n1.",
  "keywords": [
    "indexing",
    "explorer",
    "chain",
    "rest",
    "examples",
    "rate",
    "limiting",
    "strategy",
    "public",
    "ergo",
    "blockchain",
    "datum",
    "dapp",
    "service",
    "approach",
    "need",
    "node",
    "indexer",
    "trade",
    "control",
    "performance",
    "flexibility",
    "explorer.ergoplatform.com](https://explorer.ergoplatform.com",
    "ergexplorer.com](https://ergexplorer.com/",
    "database",
    "developer",
    "information",
    "identify",
    "docs",
    "endpoint",
    "documentation",
    "query",
    "request",
    "response",
    "format",
    "authentication",
    "usage",
    "limitation",
    "limit",
    "api.ergoplatform.com/api/v1/docs/](https://api.ergoplatform.com/api/v1/docs/",
    "ergexplorer",
    "ergexplorer.com/api/v1/docs/](https://ergexplorer.com/api/v1/docs/",
    "application",
    "http",
    "post",
    "library",
    "axio",
    "python",
    "fetch",
    "function",
    "process",
    "json",
    "error",
    "handling",
    "network",
    "issue",
    "requests",
    "below",
    "example",
    "functionality",
    "description",
    "/api",
    "addresses/{address",
    "address",
    "summary",
    "info",
    "https://api.ergoplatform.com/api/v1/addresses/9imohi8fuvh2rdfv3yd6xjjfxz6npqejqbmxqzhbpbfe6hwxouq",
    "addresses/{address}/transaction",
    "transaction",
    "https://api.ergoplatform.com/api/v1/addresses/9imohi8fuvh2rdfv3yd6xjjfxz6npqejqbmxqzhbpbfe6hwxouq/transaction",
    "addresses/{address}/balance",
    "balance",
    "unspent",
    "byaddress/{address",
    "byergotree/{ergotree",
    "ergotree",
    "bytokenid/{tokenid",
    "https://api.ergoplatform.com/api/v1/boxes/unspent/bytokenid/03faf2cb329f2e90d6d23b58d91bbb6c046aa143261cc21f52fbe2824bfcbf04",
    "boxes/{boxid",
    "https://api.ergoplatform.com/api/v1/boxes/851dd1bdd06a0f0f8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a",
    "transactions/{txid",
    "https://api.ergoplatform.com/api/v1/transactions/851dd1bdd06a0f0f8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a",
    "tokens/{tokenid",
    "https://api.ergoplatform.com/api/v1/tokens/03faf2cb329f2e90d6d23b58d91bbb6c046aa143261cc21f52fbe2824bfcbf04",
    "blocks/{blockid",
    "block",
    "https://api.ergoplatform.com/api/v1/blocks/851dd1bdd06a0f0f8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a",
    "note",
    "replace",
    "placeholder",
    "tokenid",
    "boxid",
    "txid",
    "blockid",
    "value",
    "code",
    "javascript",
    "typescript",
    "axios",
    "import",
    "configuration",
    "const",
    "client",
    "explorerclient",
    "baseurl",
    "explorerbaseurl",
    "timeout",
    "header",
    "interceptor",
    "explorerclient.interceptors.response.use",
    "error.response",
    "server",
    "status",
    "range",
    "console.error('explorer",
    "error.response.status",
    "error.response.data",
    "setup",
    "error.message",
    "return",
    "promise.reject(error",
    "async",
    "getaddressinfo(address",
    "string",
    "response.data",
    "catch",
    "null",
    "default",
    "object",
    "getaddressbalance(address",
    "explorerclient.get(`/addresses/${address}/balance",
    "page",
    "number",
    "item",
    "array",
    "count",
    "pagination",
    "explorerclient.get(`/boxes",
    "byaddress/${address",
    "param",
    "response.data.items",
    "gettokeninfo(tokenid",
    "explorerclient.get(`/tokens/${tokenid",
    "addressinfo",
    "console.log('address",
    "unspentboxe",
    "getunspentboxes(address",
    "unspentboxes[0].assets.length",
    "unspentboxes[0].assets[0].tokenid",
    "await",
    "tokeninfo",
    "console.log('token",
    "main().catch(e",
    "console.error(\"main",
    "execution",
    "time",
    "dict",
    "list",
    "class",
    "ergoexplorerclient",
    "base_url",
    "https://api.ergoplatform.com/api/v1",
    "self.base_url",
    "self.session",
    "session",
    "self.session.headers.update",
    "user",
    "agent",
    "ergodocspythonclient/1.0",
    "practice",
    "request(self",
    "method",
    "optional[dict[str",
    "retrie",
    "logging",
    "retry_delay",
    "second",
    "attempt",
    "range(max_retries",
    "self.session.request(method",
    "kwargs",
    "response.raise_for_status",
    "httperror",
    "response.json",
    "requests.exception",
    "e.response.status_code",
    "e.response.text",
    "retry_after",
    "int(e.response.headers.get('retry",
    "buffer",
    "max_retries",
    "time.sleep(retry_delay",
    "exponential",
    "backoff",
    "none",
    "failure",
    "requestexception",
    "bool",
    "balance_type",
    "self._request(\"get",
    "f\"/addresses/{address}/balance/{balance_type",
    "offset",
    "optional[list[dict[str",
    "f\"/boxe",
    "response.get(\"item",
    "get_token_info(self",
    "token_id",
    "get_blockchain_info(self",
    "client.get_blockchain_info",
    "print(f\"current",
    "height",
    "info.get('height",
    "client.get_address_balance(address",
    "erg_balance",
    "balance_info.get('nanoergs",
    "print(f\"address",
    "erg_balance:.9f",
    "balance_info.get('token",
    "print(\"token",
    "balance_info['token",
    "amount",
    "token['amount",
    "client.get_unspent_boxes(address",
    "case",
    "boxes[0].get('asset",
    "boxes[0]['assets'][0]['tokenid",
    "token_info",
    "client.get_token_info(token_id",
    "token_id[:10",
    "name",
    "token_info.get('name",
    "decimal",
    "token_info.get('decimal",
    "best",
    "practices",
    "resource",
    "operation",
    "understand",
    "limits",
    "community",
    "implement",
    "caching",
    "cache",
    "memory",
    "duration",
    "store",
    "redis",
    "event",
    "concept",
    "cache_ttl",
    "minute",
    "getcacheddata(url",
    "date.now",
    "cache.has(url",
    "cache.get(url).timestamp",
    "cache.get(url).data",
    "fetch(url",
    "fetchwithretry",
    "response.ok",
    "error(`api",
    "response.status",
    "cache.set(url",
    "timestamp",
    "retry",
    "logic",
    "period",
    "delay",
    "handles",
    "parameter",
    "result",
    "dataset",
    "side",
    "provider",
    "traffic",
    "alternatives",
    "volume",
    "latency",
    "explore",
    "node](./node",
    "custom",
    "indexer](./custom",
    "pros",
    "cons",
    "third",
    "party",
    "reliance",
    "centralization",
    "risk",
    "prototype",
    "tool",
    "solution",
    "production"
  ],
  "sections": [
    {
      "heading": "Indexing Strategy: Using Public Explorer APIs",
      "content": "One of the simplest ways to access indexed Ergo blockchain data for your dApp or service is by utilizing the public APIs provided by blockchain explorers. This approach avoids the need to run your own node or indexer but comes with trade-offs regarding control, performance, and flexibility."
    },
    {
      "heading": "Concept",
      "content": "Public explorers like explorer.ergoplatform.com, ergexplorer.com, and sigmaspace.io maintain their own indexed databases of the Ergo blockchain. They expose this data through public APIs, often RESTful, allowing developers to query for information programmatically."
    },
    {
      "heading": "How It Works",
      "content": "Identify Explorer & API Docs: Choose an explorer whose API provides the endpoints you need. Review their API documentation carefully to understand available queries, request/response formats, authentication (if any), and usage limitations (especially rate limits).\nErgo Explorer API Docs: api.ergoplatform.com/api/v1/docs/\nErgExplorer API Docs: ergexplorer.com/api/v1/docs/\n\n\nMake API Requests: Your application makes standard HTTP requests (GET, POST, etc.) to the explorer's API endpoints using libraries like axios (JS/TS), requests (Python), or built-in fetch functions.\nProcess Response: Your application parses the JSON (or other format) response from the API and uses the data. Implement robust error handling for network issues, API errors (like 404 Not Found or 429 Too Many Requests), and unexpected response formats."
    },
    {
      "heading": "Common API Endpoints",
      "content": "Below are examples of common endpoints available from the main Ergo Explorer API (api.ergoplatform.com). Other explorers often provide similar functionality, but check their specific documentation."
    },
    {
      "heading": "Ergo Explorer API (api.ergoplatform.com)",
      "content": "| Endpoint                                      | Description                      | Example URL                                                                                                |\n| :-------------------------------------------- | :------------------------------- | :--------------------------------------------------------------------------------------------------------- |\n| /api/v1/addresses/{address}                 | Get address summary info         | https://api.ergoplatform.com/api/v1/addresses/9iMoHi8FUVh2RdFv3YD6xjjfxZ6nPqEjQbmxQzHbpBFE6hWxouq          |\n| /api/v1/addresses/{address}/transactions    | Get address transactions         | https://api.ergoplatform.com/api/v1/addresses/9iMoHi8FUVh2RdFv3YD6xjjfxZ6nPqEjQbmxQzHbpBFE6hWxouq/transactions |\n| /api/v1/addresses/{address}/balance/confirmed | Get confirmed balance            | https://api.ergoplatform.com/api/v1/addresses/9iMoHi8FUVh2RdFv3YD6xjjfxZ6nPqEjQbmxQzHbpBFE6hWxouq/balance/confirmed |\n| /api/v1/boxes/unspent/byAddress/{address}   | Get unspent boxes by address     | https://api.ergoplatform.com/api/v1/boxes/unspent/byAddress/9iMoHi8FUVh2RdFv3YD6xjjfxZ6nPqEjQbmxQzHbpBFE6hWxouq |\n| /api/v1/boxes/unspent/byErgoTree/{ergoTree} | Get unspent boxes by ErgoTree    | https://api.ergoplatform.com/api/v1/boxes/unspent/byErgoTree/{ergoTreeHex}                               |\n| /api/v1/boxes/unspent/byTokenId/{tokenId}   | Get unspent boxes containing token | https://api.ergoplatform.com/api/v1/boxes/unspent/byTokenId/03faf2cb329f2e90d6d23b58d91bbb6c046aa143261cc21f52fbe2824bfcbf04 |\n| /api/v1/boxes/{boxId}                       | Get box by ID                    | https://api.ergoplatform.com/api/v1/boxes/851dd1bdd06a0f0f8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a |\n| /api/v1/transactions/{txId}                 | Get transaction by ID            | https://api.ergoplatform.com/api/v1/transactions/851dd1bdd06a0f0f8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a |\n| /api/v1/tokens/{tokenId}     ..."
    },
    {
      "heading": "JavaScript/TypeScript (with Axios)",
      "content": "```typescript\nimport axios from 'axios';\n// Configuration\nconst explorerBaseUrl = 'https://api.ergoplatform.com/api/v1';\n// Create a reusable client with error handling\nconst explorerClient = axios.create({\n  baseURL: explorerBaseUrl,\n  timeout: 10000, // 10 second timeout\n  headers: {\n    'Accept': 'application/json',\n  }\n});\n// Add response interceptor for detailed error logging\nexplorerClient.interceptors.response.use(\n  response => response,\n  error => {\n    if (error.response) {\n      // Request made and server responded with a status code outside 2xx range\n      console.error('Explorer API Error:', error.response.status, error.response.data);\n    } else if (error.request) {\n      // Request made but no response received\n      console.error('Explorer API No Response:', error.request);\n    } else {\n      // Error setting up the request\n      console.error('Explorer API Request Setup Error:', error.message);\n    }\n    return Promise.reject(error); // Propagate the error\n  }\n);\n// Get address information\nasync function getAddressInfo(address: string) {\n  try {\n    const response = await explorerClient.get(/addresses/${address});\n    return response.data;\n  } catch (error) {\n    console.error(Failed to get info for address ${address});\n    // Optionally return null or a default object instead of throwing\n    return null; \n  }\n}\n// Get address balance (confirmed)\nasync function getAddressBalance(address: string) {\n  try {\n    const response = await explorerClient.get(/addresses/${address}/balance/confirmed);\n    return response.data;\n  } catch (error) {\n    console.error(Failed to get balance for address ${address});\n    return null;\n  }\n}\n// Get unspent boxes for an address (first page)\nasync function getUnspentBoxes(address: string, limit: number = 50) {\n  try {\n    // API might use 'items' array and 'total' count for pagination\n    const response = await explorerClient.get(/boxes/unspent/byAddress/${address}, { params: { limit } });\n    return response.data.items..."
    },
    {
      "heading": "Python Example",
      "content": "```python\nimport requests\nimport time\nfrom typing import Dict, List, Any, Optional\nclass ErgoExplorerClient:\n    \"\"\"A simple client for interacting with the Ergo Explorer API v1.\"\"\"\ndef __init__(self, base_url: str = \"https://api.ergoplatform.com/api/v1\"):\n    self.base_url = base_url\n    self.session = requests.Session()\n    self.session.headers.update({\n        \"Accept\": \"application/json\",\n        \"User-Agent\": \"ErgoDocsPythonClient/1.0\" # Good practice to identify your client\n    })\n\ndef _request(self, method: str, endpoint: str, **kwargs) -> Optional[Dict[str, Any]]:\n    \"\"\"Internal method to handle API requests with retries and error logging.\"\"\"\n    url = f\"{self.base_url}/{endpoint.lstrip('/')}\"\n    max_retries = 3\n    retry_delay = 1  # seconds\n\n    for attempt in range(max_retries):\n        try:\n            response = self.session.request(method, url, timeout=10, **kwargs) # 10 second timeout\n            response.raise_for_status() # Raises HTTPError for bad responses (4xx or 5xx)\n            return response.json()\n        except requests.exceptions.HTTPError as e:\n            print(f\"HTTP Error: {e.response.status_code} for URL {url}. Response: {e.response.text}\")\n            if e.response.status_code == 429: # Rate limited\n                retry_after = int(e.response.headers.get('Retry-After', retry_delay))\n                print(f\"Rate limited. Retrying after {retry_after} seconds...\")\n                time.sleep(retry_after)\n                retry_delay = retry_after + 1 # Add buffer\n            elif attempt < max_retries - 1:\n                print(f\"Retrying in {retry_delay} seconds...\")\n                time.sleep(retry_delay)\n                retry_delay *= 2 # Exponential backoff\n            else:\n                print(f\"Request failed after {max_retries} attempts.\")\n                return None # Return None on final failure\n        except requests.exceptions.RequestException as e:\n            print(f\"Request failed: {e}. Attempt {attempt + 1}/{max_retri..."
    },
    {
      "heading": "Example usage",
      "content": "if name == \"main\":\n    client = ErgoExplorerClient()\n    address = \"9iMoHi8FUVh2RdFv3YD6xjjfxZ6nPqEjQbmxQzHbpBFE6hWxouq\" # Example address\ninfo = client.get_blockchain_info()\nif info:\n    print(f\"Current Height: {info.get('height', 'N/A')}\")\n\nbalance_info = client.get_address_balance(address)\nif balance_info:\n    erg_balance = balance_info.get('nanoErgs', 0) / 1e9\n    print(f\"Address Balance: {erg_balance:.9f} ERG\")\n    if balance_info.get('tokens'):\n        print(\"Tokens:\")\n        for token in balance_info['tokens']:\n             print(f\"  ID: {token['tokenId'][:10]}..., Amount: {token['amount']}\")\n\nboxes = client.get_unspent_boxes(address)\nif boxes is not None: # Check for None in case of API failure\n    print(f\"Found {len(boxes)} unspent boxes (first page).\")\n    if boxes and boxes[0].get('assets'):\n        token_id = boxes[0]['assets'][0]['tokenId']\n        token_info = client.get_token_info(token_id)\n        if token_info:\n            print(f\"First token info ({token_id[:10]}...): Name: {token_info.get('name', 'N/A')}, Decimals: {token_info.get('decimals', 'N/A')}\")\n```"
    },
    {
      "heading": "Rate Limiting and Best Practices",
      "content": "Public APIs are shared resources. To ensure reliable operation and avoid being blocked, follow these best practices:\nUnderstand Rate Limits: Check the API documentation or community resources for stated rate limits (e.g., requests per second per IP). The main Ergo Explorer API often has limits around 10-20 req/sec. Exceeding limits can lead to 429 Too Many Requests errors or temporary IP bans.\n\nImplement Caching: Avoid fetching the same data repeatedly. Cache responses locally (in memory for short durations, or using persistent stores like Redis for longer) with appropriate Time-To-Live (TTL) values. Re-fetch only when the cache expires or specific events indicate data might have changed.\n    ```javascript\n    // Simple in-memory cache concept (JS)\n    const cache = new Map();\n    const CACHE_TTL = 60000; // 1 minute\nasync function getCachedData(url) {\n  const now = Date.now();\n  if (cache.has(url) && (now - cache.get(url).timestamp < CACHE_TTL)) {\n    return cache.get(url).data;\n  }\n  // Fetch fresh data if not cached or expired\n  const response = await fetch(url); // Use fetchWithRetry here\n  if (!response.ok) throw new Error(API Error: ${response.status});\n  const data = await response.json();\n  cache.set(url, { data, timestamp: now });\n  return data;\n}\n*   **Use Retry Logic with Exponential Backoff:** If a request fails (especially due to rate limiting or transient network issues), don't immediately retry. Wait for a short period and increase the delay exponentially for subsequent retries. Respect the `Retry-After` header if provided in a `429` response.python\nConceptual retry logic within the Python client's _request method (see above)\nHandles retries with increasing delay for transient errors and respects Retry-After\n``\n*   **Be Specific:** Request only the data you need. Use API parameters (limit,offset, specific endpoints) to narrow down results instead of fetching large datasets and filtering client-side.\n*   **Identify Your Client:** Use a descriptiveUser-..."
    },
    {
      "heading": "Handles retries with increasing delay for transient errors and respects Retry-After",
      "content": "``\n*   **Be Specific:** Request only the data you need. Use API parameters (limit,offset, specific endpoints) to narrow down results instead of fetching large datasets and filtering client-side.\n*   **Identify Your Client:** Use a descriptiveUser-Agent` header in your requests so API providers can identify your application's traffic if issues arise.\n*   Consider Alternatives: If your application requires high volume, low latency, or complex queries, relying solely on public APIs might not be sustainable. Explore querying your own node or building a custom indexer."
    },
    {
      "heading": "Pros & Cons Summary",
      "content": "Pros: Simple to start, convenient endpoints.\nCons: Third-party reliance, rate limits, limited query flexibility, potential latency, centralization risk."
    },
    {
      "heading": "When to Use",
      "content": "Simple applications, prototypes, low-volume tools.\nWhen reliance on a third party is acceptable.\nWhen required data fits well with available API endpoints.\nWhile convenient, the limitations often lead developers towards more robust solutions for production applications."
    }
  ],
  "qa_pairs": []
}