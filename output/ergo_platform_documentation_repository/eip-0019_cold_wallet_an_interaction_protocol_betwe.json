{
  "title": "EIP-0019 Cold Wallet: an interaction protocol between Hot and Cold mobile wallets",
  "source_url": "docs/dev/wallet/standards/eip19.md",
  "summary": "---\ntags:\n  - EIP\n---\n\n# EIP-0019 Cold Wallet: an interaction protocol between Hot and Cold mobile wallets\n\n> \ud83d\udd17 From [EIP-0019](https://github.com/ergoplatform/eips/blob/master/eip-0019.md) * Author: @MrStahlfelge,@aslesarenko\n* Status: Proposed\n* Created: 18-August-2021\n* License: CC0\n* Forking: not needed \n\n## Contents\n- [EIP-0019 Cold Wallet: an interaction protocol between Hot and Cold mobile wallets](#eip-0019-cold-wallet-an-interaction-protocol-between-hot-and-cold-mobile-wallets)\n  - [Contents](#contents)\n  - [Description](#description)\n  - [Background And Motivation](#background-and-motivation)\n  - [Cold Signing Problem](#cold-signing-problem)\n  - [Simplified Signing using ReducedTransaction](#simplified-signing-using-reducedtransaction)\n  - [Transaction Interchange](#transaction-interchange)\n    -",
  "keywords": [
    "cold",
    "wallet",
    "interaction",
    "protocol",
    "eip-0019](https://github.com",
    "ergoplatform",
    "blob",
    "master",
    "eip-0019.md",
    "author",
    "@mrstahlfelge,@aslesarenko",
    "status",
    "august-2021",
    "license",
    "forking",
    "content",
    "eip-0019",
    "mobile",
    "contents](#contents",
    "background",
    "motivation](#background",
    "motivation",
    "signing",
    "problem](#cold",
    "problem",
    "simplified",
    "reducedtransaction",
    "transaction",
    "interchange](#transaction",
    "interchange",
    "coldsigningrequest](#coldsigningrequest",
    "coldsigningresponse:](#coldsigningresponse",
    "format](#interchange",
    "format",
    "reference",
    "implementation",
    "wallet](#reference",
    "benefits](#benefits",
    "description",
    "standard",
    "online",
    "ergo",
    "android",
    "wallet](https://github.com",
    "mrstahlfelge",
    "mnemonic",
    "device",
    "oses",
    "desktop",
    "internet",
    "apple",
    "attack",
    "secret",
    "stolen](https://latesthackingnews.com/2021/07/06",
    "user",
    "facebook",
    "system",
    "datum",
    "hardware",
    "wallets](https://www.ledger.com/",
    "option",
    "security",
    "connectivity",
    "access",
    "candidate",
    "factory",
    "setup",
    "raspberry",
    "application",
    "code",
    "case",
    "file",
    "simplicity",
    "text",
    "restriction",
    "transportation",
    "method",
    "sign",
    "button",
    "byte",
    "screen",
    "design",
    "contract",
    "implementation](#reference",
    "section",
    "solution",
    "role",
    "hotwallet",
    "coldwallet",
    "android](https://github.com",
    "model",
    "condition",
    "spending",
    "context",
    "variable",
    "number",
    "output",
    "registers](registers.md",
    "structure",
    "input",
    "prover",
    "signature",
    "overview",
    "scorexfoundation",
    "sigmastate",
    "language",
    "process",
    "detail",
    "state",
    "blockchain",
    "header",
    "height",
    "nodes",
    "network",
    "connection",
    "time",
    "limit",
    "size",
    "contexts",
    "data",
    "serialization",
    "unsignedtx",
    "unsignedtransaction",
    "reducedinputs",
    "seq[reducedinputdata",
    "seq[unsignedinput",
    "datainput",
    "seq[datainput",
    "outputcandidates",
    "unsignedinput",
    "boxid",
    "extension",
    "contextextension",
    "reducedinputdata",
    "reductionresult",
    "instance",
    "value",
    "sigmaboolean",
    "cost",
    "object",
    "additionaltokens",
    "additionalregister",
    "property",
    "interpreter",
    "blob/4533b6a7ae86ada20f3136c70a67a920ae7c43e1",
    "scala",
    "ergotree](https://github.com",
    "blob/1a1b003bc30e490d8b5af30e7670227e54e682c2",
    "values.scala#l1014",
    "reduction",
    "part",
    "context](https://github.com",
    "e5127f6743db824f7280881cd5c4ecd336075e2f",
    "ergolikecontext.scala#l51",
    "prove](https://github.com",
    "f24833d8d4572d77e4a93e5b69360335cb2d7dc1",
    "proverinterpreter.scala#l104",
    "proof",
    "ergotree",
    "sigma",
    "proposition",
    "step",
    "blockchaincontext",
    "unsignedix",
    "amounttosend",
    "asset",
    "ctx.newproverbuilder.build",
    "reducedtx",
    "serialize",
    "bytes",
    "reducedtransactionserializer.frombytes(reducedtxbytes",
    "coldblockchaincontext",
    "ctx.newproverbuilder.withsecretstorage(\"storage.json\").build",
    "signedtx",
    "prover.signreduced(reducedtx",
    "script",
    "evaluation",
    "usability",
    "coldsigningresponse",
    "json",
    "base64",
    "sender",
    "p2pk",
    "address",
    "list",
    "signedtransaction",
    "length",
    "chunk",
    "layer",
    "information",
    "page",
    "index",
    "container",
    "example",
    "csr\":\"{\\\"reducedtx\\\":\\\"",
    "\\\",\\\"sender\\\":\\\"9",
    "\\\",\\\"inputs\\\":[\\\"",
    "following",
    "own)\",\"n\":3,\"p\":1",
    "addition",
    "requirement",
    "wallets",
    "coldsigningrequest",
    "coldergoclient",
    "operation",
    "node",
    "explorer",
    "client",
    "wifi",
    "bluetooth",
    "cellular",
    "appkit",
    "benefit",
    "feature",
    "alternative",
    "fund"
  ],
  "sections": [
    {
      "heading": "EIP-0019 Cold Wallet: an interaction protocol between Hot and Cold mobile wallets",
      "content": "\ud83d\udd17 From EIP-0019\nAuthor: @MrStahlfelge,@aslesarenko\nStatus: Proposed\nCreated: 18-August-2021\nLicense: CC0\nForking: not needed"
    },
    {
      "heading": "Contents",
      "content": "EIP-0019 Cold Wallet: an interaction protocol between Hot and Cold mobile wallets\nContents\nDescription\nBackground And Motivation\nCold Signing Problem\nSimplified Signing using ReducedTransaction\nTransaction Interchange\nColdSigningRequest\nColdSigningResponse:\nInterchange format\n\n\nReference Implementation of Hot Wallet\nReference Implementation of Cold Wallet\nBenefits"
    },
    {
      "heading": "Description",
      "content": "This EIP defines a standard for cross-device interaction between \"Hot\" (online)\nand \"Cold\" (offline) wallets for signing Ergo transactions."
    },
    {
      "heading": "Background And Motivation",
      "content": "Mobile wallets (like Ergo Android\nWallet) typically store\nprivate keys (aka mnemonics) on the device.\nHowever, modern mobile OSes (Android, iOS) as well as desktop PCs are always connected to the internet\nand can be\nhacked\nand secrets stolen.\nScreenreading and keystroke logging are system-independant ways to steal user data.\nThat is why specialized hardware wallets are\nconsidered much more secure to store private keys.\nAnother option for more security is to use \"Cold\" wallet - a device which is not connected\nto the internet or better, with all connectivity turned-off and internet access blocked.\nCandidates could be outdated (but still functioning) mobile devices with clean\nfactory setup or a Raspberry Pi with a fresh Raspbian setup and only Cold Wallet application installed.\nAs long as the device never connects to the internet, it is guaranteed that no secrets left the device.\nInteraction with the Cold Wallet device can be done via QR codes (in case of mobile devices)\nor by transferring files (in case of Raspberry Pi). For simplicity, only QR code is mentioned in the \nfollowing text. This does not mean any restriction of the transportation method.\nA user creates a transaction in the Hot Wallet application and then presses a \"Sign With Cold Wallet\" button\nThe Hot Wallet application shows a QR code with serialized transaction bytes on the screen\nUser scans the QR code using the Cold Wallet device, signs the transaction after which QR code of the signed transaction is displayed.\nThen user scans the QR code of the signed transaction and sends it to blockchain.\nThe design of Ergo contracts allows for a simple and universal implementation\nwhich we describe in Reference Implementation\nsection.\nIn the following sections we:\ndescribe the main problem we need to solve; \ndescribe a solution;  \nspecify a protocol with two roles: HotWallet and ColdWallet which must be implemented by complying Wallet applications and \ndescribe a reference implementation of both Hot and Cold roles..."
    },
    {
      "heading": "Cold Signing Problem",
      "content": "In the Ergo's eUTXO model a box can be protected by an arbitrary complex\ncontract (aka spending condition) and the spending transaction should satisfy\nthat condition by adding required context variables, creating expected number of\noutputs with specific registers etc. i.e. a special data structure called\nContext. The Context should be created for each input of the transaction\nand then passed to the Prover which will generate a signature for that input.\nSee general overview of signing and\nverification\nprocess in Ergo for details.\nIn general, the Context represents the current state of the blockchain and\nincludes current header, previous 10 headers, current height etc. This data can\nbe retrieved from blockchain nodes. This is possible on Hot Wallet device, but\nis not possible on Cold Wallet device (there is no network connection).\nAt the same time the prover need to know both the Context data and the private\nkeys, which are stored on the Cold Wallet device, and so the Prover must run on\nthe Cold Wallet device.\nAnd finally, which is the problem, we cannot transfer unsigned transaction along\nwith all the contexts for each input to the Cold Wallet via QR code.\nQR codes have limit of 4K bytes on the maximum size of serialized data. Most of\nthe transactions with required Contexts will exceed this limit."
    },
    {
      "heading": "Simplified Signing using ReducedTransaction",
      "content": "To solve the problem of cold signing we need a new data structure and\nserialization format called ReducedTransaction.\n```\nReducedTransaction:\n  - unsignedTx: UnsignedTransaction\n  - reducedInputs: Seq[ReducedInputData]\n  - txCost: Int\nUnsignedTransaction:\n  - inputs: Seq[UnsignedInput],\n  - dataInputs: Seq[DataInput],\n  - outputCandidates: Seq[ErgoBoxCandidate]\nUnsignedInput:\n  - boxId: BoxId\n  - extension: ContextExtension\n```\nReducedInputData:\n  - reductionResult: ReductionResult \nThus, the ReducedTransaction instance contains unsigned transaction augmented with\none ReductionResult for each UnsignedInput.\nReductionResult:\n  - value: SigmaBoolean\n  - cost: Long\nNote that UnsignedInput object doesn't contain ergoTree, additionalTokens,\nadditionalRegisters and other properties of\nErgoBox\nwhich are necessary to perform\nErgoTree\nreduction and which are part of the\nContext\ndata structure required by the\nprove\nmethod.\nThis is because those context data is not required to generate proof (aka signature)\nonce ErgoTree is reduced to ReductionResult containing sigma proposition.\nHaving the ReducedTransaction data structure the full transaction signing\nconsists of three steps\n1) Create unsigned transaction and then reduce it in the current\nblockchain context, which has connection to one of the network nodes. This step\nis performed on Hot Wallet and produces ReducedTransaction without requiring\nsecret keys.\nval ctx: BlockchainContext = ...\nval unsignedIx = createTransaction(ctx, from, to, amountToSend, assets)\nval prover = ctx.newProverBuilder.build // prover without secrets\nval reducedTx: ReducedTransaction = prover.reduce(unsigned, 0)\n2) Serialize ReducedTransaction data structure to bytes and then pass it to\nthe Cold Wallet via QR code.\n3) Once scanned in the Cold Wallet, the ReducedTransaction object can be\ndeserialized back from bytes and then signed using prover configured with local\nsecrets.\nval reducedTx = ReducedTransactionSerializer.fromBytes(reducedTxBytes)\nval ctx: ..."
    },
    {
      "heading": "Transaction Interchange",
      "content": "For better security and usability additional data can be transfered between Hot\nand Cold wallets via QR codes. Hot Wallet passes data to the Cold Wallet using\nColdSigningRequest data format and Cold Wallet replies back with ColdSigningResponse."
    },
    {
      "heading": "ColdSigningRequest",
      "content": "Json format, holding\n* reducedTx (mandatory): Base64-encoded ReducedTransaction as defined above\n* sender (optional): P2PK address sending the transaction, can be used by cold wallets to determine which secret to use for signing the transaction\n* inputs (mandatory): List of base64-encoded serialized input boxes, can be used by cold wallets to show the user which boxes are burnt"
    },
    {
      "heading": "ColdSigningResponse:",
      "content": "Json format, holding\n* signedTx (mandatory): Base64-encoded SignedTransaction"
    },
    {
      "heading": "Interchange format",
      "content": "As QR codes are length-limited and it could be needed to transfer the data in chunks, it is needed to wrap the actual data sent by a small layer containing information about number of chunk pages and page index of a chunk. This is done by wrapping it in another JSON container with three properties:\nThe actual chunk data, named CSR for ColdSigningRequest or CSTX for ColdSigningResponse\nproperty \"p\", 1-based page index of current chunk (optional if there is only one page)\nproperty \"n\", number of pages (optional if there is only one page)\nExamples:\nThe QR code for a complete ColdSigningRequest contains the following data:\n{\"CSR\":\"{\\\"reducedTx\\\":\\\"....\\\",\\\"sender\\\":\\\"9...\\\",\\\"inputs\\\":[\\\"...\\\"]}\"}\nThe QR code for the first chunk of a ColdSigningResponse with 3 pages total looks like the following:\n{\"CSTX\":\"{\\\"signedTx\\\":\\\"... (actual data, no valid JSON on its own)\",\"n\":3,\"p\":1}\nIn addition to using the above formats the following requirements are imposed on\nHot Wallet and Cold Wallets:\n1) There should be a way for a given unsigned transaction on the HotWallet to\nshow QR code of ColdSigningRequest on the screen, and then scan the QR code of\nthe corresponding ColdSigningResponse.\n2) There should be a way on ColdWallet to scan QR code of ColdSigningRequest,\nshow transaction details on the screen and allow user to either sign or reject.\nIf signed, the QR code of ColdSigningResponse should be shown."
    },
    {
      "heading": "Reference Implementation of Hot Wallet",
      "content": "https://github.com/ergoplatform/ergo-wallet-android"
    },
    {
      "heading": "Reference Implementation of Cold Wallet",
      "content": "https://github.com/ergoplatform/ergo-wallet-android\nA special ColdErgoClient instance can be created to perform signing\noperations. ColdErgoClient don't have connections to Ergo nodes and explorer,\nmoreover for better security, cold client can forbig operations if any\ndevice connectivity is turned-on, such as WiFi, Bluetooth, NFC, Cellular etc.\nNote, using ColdErgoClient is not strictly required and ordinary client can be\nused instead, however ColdErgoClient allows this EIP to be easily supported in an\nimplementation of Cold Wallet application based on Appkit."
    },
    {
      "heading": "Benefits",
      "content": "Any wallet can become compatible with this EIP by implementing HotWallet\nrole in addition to basic wallet features. \nAny Hot wallet implementation can interact with any Cold wallet implementation.\nUsers have an alternative to specialized hardware wallets and can gain more security \nfor their funds stored on the Ergo Blockchain."
    }
  ],
  "qa_pairs": []
}