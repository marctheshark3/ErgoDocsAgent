{
  "title": "Context Enrichment",
  "source_url": "docs/dev/scs/tx/context-enrichment.md",
  "summary": "# Context Enrichment\n\n\nIn Bitcoin and other existing UTXO systems, the *context* is just the UTXO being processed. In order for a UTXO-based system to support transaction trees, the context must be rich enough to contain at least the entire spending transaction. More formally, for any UTXO based blockchain, we can define the following levels of context, each extending the previous:\n\n- **Level 1**: current UTXO, height and timestamp\n- **Level 2**: current transaction (inputs and outputs)\n- **Level 3**: current block header and block solution\n- **Level 4**: current block (other sibling transactions)\n \nAny platform at Level 2 and above is suitable for transaction trees. In this regard, Bitcoin operates at Level 1 and Ergo at Level 3. Note that in Level 4 we cannot check validity of transactions independently of other transactions in the block.",
  "keywords": [
    "context",
    "enrichment",
    "bitcoin",
    "utxo",
    "system",
    "order",
    "transaction",
    "tree",
    "spending",
    "blockchain",
    "level",
    "height",
    "timestamp",
    "input",
    "output",
    "block",
    "header",
    "solution",
    "platform",
    "regard",
    "ergo",
    "validity",
    "work",
    "example",
    "ethereum",
    "contract",
    "model",
    "rock",
    "paper",
    "scissors",
    "game",
    "initial",
    "coin",
    "offering",
    "campaign",
    "primitive",
    "address",
    "fund",
    "levels",
    "script",
    "code",
    "predicate",
    "object",
    "output(0).value",
    "proof",
    "automation",
    "reduction",
    "rule",
    "contribution",
    "stage",
    "protocol",
    "multistage",
    "property",
    "out.propositionbyte",
    "state_n_code",
    "r4[int].get",
    "self.r4[int].get",
    "datum",
    "condition",
    "propositionbyte",
    "register",
    "self",
    "check",
    "data",
    "value"
  ],
  "sections": [
    {
      "heading": "Context Enrichment",
      "content": "In Bitcoin and other existing UTXO systems, the context is just the UTXO being processed.\nIn order for a UTXO-based system to support transaction trees, the context must be rich enough to contain at least the entire spending transaction.\nMore formally, for any UTXO based blockchain, we can define the following levels of context, each extending the previous:\nLevel 1: current UTXO, height and timestamp\nLevel 2: current transaction (inputs and outputs)\nLevel 3: current block header and block solution\nLevel 4: current block (other sibling transactions)\nAny platform at Level 2 and above is suitable for transaction trees. In this regard, Bitcoin operates at Level 1 and Ergo at Level 3.\nNote that in Level 4 we cannot check validity of transactions independently of other transactions in the block. Hence it is more complex to implement Level 4.\nIn this work we show via examples how to create efficient Ethereum-like contracts in the UTXO model using transaction trees. The examples include a Rock-Paper-Scissors game, an Initial Coin Offering (ICO) campaign and a new primitive called reversible addresses for securely storing funds."
    },
    {
      "heading": "Enriched Context Levels",
      "content": "Script code can have predicates on objects in context. \nExample OUTPUT(0).value >= 1000\n\n\nIt is known that Level 2 can emulate Turing complete (hence Ethereum)\nHowever, the proof uses Rule 110 cellular automation. Reduction is not efficient\nWe need something more efficient than Rule 110. This is our contribution."
    },
    {
      "heading": "How to ensure that each stage follows protocol?",
      "content": "Code in context Level 2 and higher allows multistage protocols\nSpending transactions must create another UTXO with the required properties.\nscala\nout.propositionBytes == state_n_code && \nout.R4[Int].get == SELF.R4[Int].get // ensure data is propagated\nThis code is checking two conditions:\nWhether the propositionBytes of the out box is equal to state_n_code.\nWhether the R4 register of the out box is equal to the R4 register of the current SELF box.\nThe first condition checks if the script of the output box matches the expected script (as represented by state_n_code). If this condition is not satisfied, the script will reject the transaction.\nThe second condition ensures that a certain data value stored in the R4 register is propagated from the current box to the output box. If this condition is not satisfied, the script will reject the transaction."
    }
  ],
  "qa_pairs": []
}