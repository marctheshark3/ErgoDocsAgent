{
  "title": "Multi-Signature Wallet",
  "source_url": "docs/dev/wallet/minotaur-multisig.md",
  "summary": "# Multi-Signature Wallet\n\n## Introduction\n\nMinotaur wallet is a multi-platform wallet developed by *minotaur-ergo* using TypeScript. In this project, the wallet is extended to support multiple signatures. A multi-signature (*multi-sig*) wallet uses more than one private key to authorize transactions. Such a wallet can be managed by a single user holding multiple private keys, multiple users holding a single key each, or any combination of the two scenarios. In a multi-sig wallet with *M* private keys, depending on its configurations, any transaction may require *N* signatures, where *1<=N<=M*.",
  "keywords": [
    "multi",
    "signature",
    "wallet",
    "introduction",
    "minotaur",
    "ergo",
    "typescript",
    "project",
    "transaction",
    "user",
    "combination",
    "scenario",
    "configuration",
    "accomplishment",
    "user(s",
    "balance",
    "software",
    "transfer",
    "method",
    "communication",
    "holder",
    "explanation",
    "blockchain",
    "step",
    "pool",
    "commitment",
    "11](https://github.com",
    "ergoplatform",
    "pull/8",
    "word",
    "signer",
    "procedure",
    "example",
    "alice",
    "carol",
    "dani",
    "order",
    "part",
    "process",
    "manner",
    "design",
    "details",
    "creation",
    "implementation",
    "type",
    "copy",
    "device",
    "name",
    "number",
    "sign",
    "value",
    "convenience",
    "solution",
    "case",
    "address",
    "display",
    "parts",
    "functionality",
    "fund",
    "information",
    "history",
    "asset",
    "dapps",
    "derivation",
    "modal",
    "fact",
    "account",
    "algorithm",
    "path",
    "list",
    "contract",
    "scala",
    "atleast",
    "coll",
    "pk(address1",
    "pk(addressm",
    "result",
    "second",
    "sigma",
    "rust",
    "library",
    "node",
    "criterion",
    "signing",
    "problem",
    "array",
    "byte",
    "length",
    "quantity",
    "integer",
    "time",
    "08cd",
    "representation",
    "index",
    "constant",
    "times",
    "password",
    "form",
    "json",
    "string",
    "clipboard",
    "button",
    "moment",
    "input",
    "partialtx",
    "proposition",
    "generation",
    "cosigning",
    "server",
    "server](https://github.com",
    "lazypinkpatrick",
    "datum",
    "minute",
    "/put",
    "store",
    "m/44'/429'/0'/0/0",
    "pair",
    "data",
    "category",
    "sender",
    "message",
    "user2",
    "/get",
    "triplet",
    "parent",
    "option",
    "party",
    "member",
    "count",
    "format",
    "base64",
    "generator",
    "ergohack",
    "chain",
    "signer(s",
    "generating",
    "commitment(s",
    "error",
    "failure",
    "detail",
    "code",
    "repository",
    "code](https://github.com",
    "tree",
    "hack",
    "some",
    "incompatibility",
    "channel",
    "transition",
    "workflow",
    "identity",
    "processing",
    "stage",
    "setup",
    "person",
    "page",
    "change",
    "point"
  ],
  "sections": [
    {
      "heading": "Introduction",
      "content": "Minotaur wallet is a multi-platform wallet developed by minotaur-ergo using TypeScript.\nIn this project, the wallet is extended to support multiple signatures.\nA multi-signature (multi-sig) wallet uses more than one private key to authorize transactions.\nSuch a wallet can be managed by a single user holding multiple private keys, multiple users holding a single key each, or any combination of the two scenarios.\nIn a multi-sig wallet with M private keys, depending on its configurations, any transaction may require N signatures, where 1<=N<=M.\nThe project accomplishments are as follows:\nThe end user(s):\ncan easily create a multi-signature wallet,\ncan see their wallet balance,\ncan sign their transactions in the wallet.\nThe software provides an automatic transfer method that safely processes all signatures and communications between private-key holders."
    },
    {
      "heading": "Explanation",
      "content": "In Ergo blockchain, a transaction is prepared in two steps before being submitted to the\ntransaction pool:\nrequired commitments are generated\nThe transaction is signed using the commitments\nThese steps are performed automatically and transparently (hidden from the user) in any wallet. However, signing a multi-sig transaction involves more sophisticated steps, as explained in EIP 11.\nIn other words, the steps mentioned above cannot be performed transparently since the commitments and signatures must be shared between all signers.\nThe procedure can be explained more clearly using the following example:\nConsider a 3-out-of-4 wallet, and let us name the 4 private-key holders Alice, Bob, Carol, and Dani.\nThe wallet has been configured so that at least 3 signers must sign a transaction.\nSuppose that Alice, Bob, and Carol agree to sign a transaction.\nIn order to do so,\nAlice creates an unsigned transaction and generates her commitment.\nThen, she sends the transaction and the public part of her commitment to Bob.\nBob generates his commitment and appends its public parts to Alice's commitment.\nThen, He forwards the transaction and the two-part commitment to Carol.\nCarol generates her commitment. At this step, all 3 required commitments are available.\nTherefore, Carol adds her signature to the transaction and sends it back to Bob.\nSimilarly, Bob adds his signature to the transaction and forwards it to Alice.\nFinally, Alice completes the transaction signing by adding her signature to it.\nNow she can submit the signed transaction to the transaction pool.\nThe minotaur multi-sig wallet facilitates the whole process in a user-friendly manner."
    },
    {
      "heading": "Wallet Creation",
      "content": "Implementation of this project introduces a new type of wallet, the so-called multi-sig wallet, to the Minotaur wallet.\nIn order to create a new functional multi-sig wallet,\neach signer must configure a copy of it on his/her device by applying the following four steps:\nA proper name is entered for the personal copy of the multi-sig wallet.\nNames entered by different signers can be different.\n\n\nThe total number of signers, M, and also the number of required signs, N, are entered.\nM can be maximally 20. All signers must enter the same values for these two numbers.\n\n\nEach signer must enter his/her private key and the public key of all other signers in the multi-sig wallet.\nFor convenience, it is supposed that each signer already has a normal wallet in Minotaur so that his/her public/private key can be retrieved.\nFor all other signers, either of the following solutions may be applied:\nTheir extended public keys are entered. In this case, signers can derive the address of the multi-sig wallet.\nTheir addresses are entered.\nIn this case, it is not possible for signers to derive the address of the multi-sig wallet.\n\n\nThe address of the multi-sig wallet is displayed to each signer.\n  The signer's copy of the multi-sig wallet is created as soon as he/she approves the address."
    },
    {
      "heading": "Wallet Display Parts.",
      "content": "Since the implementation is based on a standard wallet, the following functionalities of the underlying standard wallet already work in the multi-sig wallet too:\nExtracting fund information from the Ergo blockchain\nDisplaying transaction history\nCreating unsigned transaction\nDisplaying addresses\nDisplaying assets\nConnecting to dApps\nHowever, two principal parts must be implemented: the address derivation and the \"sign transaction\" modal."
    },
    {
      "heading": "Address Derivation",
      "content": "When deriving new addresses, two important facts must be taken into account.\nFirst, to guarantee a unique address for the multi-sig wallet to be derived on all signer copies, a unique address-derivation algorithm must be applied everywhere.\nThe applied algorithm is as follows:\nFor a specified path, using each signer's extended public key, an address is derived for that signer.\nThe list of derived addresses for all signers is used to compile a multi-sig contract like:\nscala\natLeast(\n  N,\n  Coll(\n    PK(Address1),\n    PK(Address2),\n    .\n    .\n    .\n    PK(AddressM)\n  )\n)\nThe contract mentioned above results in distinguishable (different) addresses when two signer addresses swap. In order to prevent this, the list of signers' addresses are always sorted before being used in the contract.\nSecond, the Sigma-rust library cannot compile any contract. One might think of Node as a solution, but it does not fulfil the project criteria since it disables cold signing. Our solution to this problem is to manually create the required ergiTree array as follows:\nThe first byte in the array has a value of 10.\nThe number of constant values in the contract.\nThis number equals M+1 and is encoded as a variable-length quantity (VLQ).\n\n\nThe number of required signs, N.\nThis number starts with a byte with value 04 that denotes the integer type, followed by the value of N encoded as a VLQ.\n\n\nFor each public key (M times), 35 bytes are used: 2 bytes with value 08cd, followed by 33 bytes representing the public key\nA byte with value 98, indicating \"atLeast\"\nTwo bytes, with values 73 and 00, respectively.\nThe value 00 indicates the VLQ representation of the index of value N in the list of constants.\n\n\nA constant byte with value 83, followed by the VLQ representation of M, and a constant byte with value 08\nFor each public key (M times), a byte with value 73, followed by the VLQ representation of the index of the public key in the list of constants"
    },
    {
      "heading": "\"Sign transaction\" modal",
      "content": "After an unsigned transaction is created, the Minotaur wallet displays a modal so the user can confirm his/her password and sign the transaction.\nSimilarly, the same modal is displayed for a multi-sig wallet too.\nWhen a user enters his/her password into the modal, a commitment is generated, whose private part is stored locally, and then the following information is displayed in the form of a JSON string:\nJSON\nMCR-{\n  \"tx\": <reduced transaction bytes>,\n  \"boxes\": [<encoded boxes>],\n  \"commitments\": <commitments encoded>\n}\nA user must share this string with other wallets through any communication.\nFor convenience, a copy to clipboard button has been provided in the modal.\nAs soon as any other signer enters the JSON string into his/her wallet, the wallet displays information regarding the transaction.\nThe signer generates personal commitment by entering his/her password and approving the transaction.\nThe newly created commitment is merged with the received one, and a new JSON string is presented.\nThis new string must be passed to the next signer.\nThe process repeats until the last required signer generates his/her commitment.\nAt this moment, the last signer signs the transaction and creates a JSON string containing the following information:\nJSON\n{\n  \"tx\": <reduced transaction bytes>,\n  \"boxes\": [<encoded boxes>],\n  \"commitments\": <commitments encoded>,\n  \"simulated\": [<list of simulated public keys for all inputs>]\n  \"signed\": [<list of all signed public keys for all inputs + my own public keys for all inputs>]\n  \"partialTx\": <partially signed tx proposition bytes>\n}\nSimilar to the process of commitment generation,\nevery other signer must enter the received JSON string in his/her wallet, sign the transaction, generate a new JSON string, and pass it to the next signer.\nAfter signing the transaction, the last signer can submit it to the blockchain."
    },
    {
      "heading": "CoSigning Server",
      "content": "A cosigning server was designed and implemented in order to simplify communications between wallets.\nThe server can store data for any specific address.\nMoreover, for any address, associated data stored on the server can be requested.\nThe server keeps data for 10 minutes only.\nThis server has two APIs:"
    },
    {
      "heading": "/put",
      "content": "Stores data on the server for any specific address:\nWe assume that each wallet uses the address derived from the path m/44'/429'/0'/0/0.\nThe JSON string passed to this API is something like the example below, where the \"type\": <value> pair is used to specify the data category:\nJSON\n{\n    \"sender\": \"me\",\n    \"message\": \"\",\n    \"type\": \"create\",\n    \"receiver\": [\"user1\", \"user2\"]\n}"
    },
    {
      "heading": "/get",
      "content": "Gets a list of requested data for a specified address:\nFor a given triplet of (ID, address, value), this API gets, from the server, all messages with an ID greater than the given one and returns data associated with the given address that would have a type of value.\nIn this implementation, we assume that a new transaction is highlighted with the \"type\": \"create\" pair,\nwhile all sub-messages are linked to their parent transaction using the transaction ID as their type value, i.e., \"type\": <txId>\nOur implemented scenario for signing a transaction using this server is as follows:\nThe first signer creates an unsigned transaction.\nIf the user selects the \"sign via cosigning server\" option, he/she sends the following JSON string to all other signers in the multi-sig wallet:\nJSON\n{\n  \"type\": \"create\",\n  \"tx\": <reduced tx>\n  \"boxes\": [<encoded boxes>]\n}\nOther signers receive this JSON string and generate a party for it.\nThe first signer also creates his/her commitment and sends the following JSON to all other party members:\nJSON\n{\n  \"type\": \"commitment\",\n  \"commitments\": [<my encoded commitment for all inputs>]\n}\nEvery other signer generates a commitment by entering his/her password.\n  At the same time, entering the password by the signer indicates to the wallet that he/she accepts the transaction and is willing to sign it.\nWhen the number of commitments reaches the required count,\n  every wallet signs the transaction and sends it to all other signers in the following format:\njson\n{\n  \"type\": \"sign\"\n  \"simulated\": [<list of simulated public keys; the first signer generated this list, and no one has changed it yet.>]\n  \"signed\": [<list of signatures in this transaction; everyone must append his/her public key to this list.>]\n  \"partial\": <partially signed tx in the base64 format>.\n}\nEvery wallet, when it receives a new partially-signed transaction, checks the number of signatures on it:\nIf the wallet has not already signed the transaction, it is signed and published\nIf the n..."
    },
    {
      "heading": "Introduction",
      "content": "Minotaur is the first multi-signature wallet developed for Ergo. A multi-signature wallet, or multi-sig wallet, uses more than one private key to authorize transactions. Such a wallet can be managed by a single user holding multiple private keys, multiple users holding a single key each, or any combination of the two scenarios. In a multi-sig wallet with M private keys, depending on its configurations, any transaction may require N signatures, where 1 <= N <= M.\nSigning any multi-sig transaction on the Ergo chain consists of two major steps that must be completed by any N signer(s) among the M key-holders:\nGenerating required commitment(s) and sharing them with all other signers (N times).\nSigning the transaction using gathered commitments (N times).\nIn Minotaur, an N-sig transaction is performed as follows:\nThe first signer, i.e., a key-holder who creates the transaction, generates his/her own commitment(s) and, including all other required data, sends it to a second signer.\nA second signer receives the transaction data, appends his/her own commitment(s) to it, and sends it to a third signer.\nThe process is repeated by all other signers, except the last one.\nThe last signer receives commitments of all other signers. He/She generates his/her own commitment(s) and appends it to the transaction data, and finally signs the transaction. Then, the partially signed transaction is sent to another signer.\nAny middle signer signs the transaction and passes it to another one.\nThe last one who adds the last signature to the transaction publishes the fully-signed transaction.\nThe process is error-prone. In fact, any human error in sending commitment(s) and using invalid commitment sets results in an invalid, and thus incomplete, transaction. Such failures have been reported frequently.\nIn order to solve this problem, we introduce the Minotaur Signing Server, which manages the signing process and ensures a valid and completed transaction.\nFor more details and to access the code,..."
    },
    {
      "heading": "The Minotaur Signing Server",
      "content": "The Minotaur Signing Server (MSS) manages the steps of transaction signing. The MSS provides a safe, reliable, secure, and error-free channel for data transition among signers. Therefore, it can guarantee that every signer receives and uses correct transaction data.\nThe workflow of the MSS is as follows:\nFirst, each of the wallet key-holders must generate an asymmetric key-pair for communication with the server. We refer to these keys as the communication private and public keys. The MSS expects every signer to sign his/her communication public key with his/her transaction-signing key in order to confirm the signer's identity.\nThe MSS needs the multi-sig wallet details, including the extended public key of each signer and also the number of required signatures. Any of the key-holders can provide the MSS with this data. It is only after receiving this data that the MSS allows for the processing of any transaction.\nAt this stage, the multi-sig wallet setup is completed, and any number of transactions can be started. A new transaction is started as follows:\nThe person who creates the transaction sends it to the MSS. From now on, each of the wallet holders will see the transaction on their multi-sig communication page of their connected Minotaur. The representation of data on the page has not been altered by the introduction of MSS, and the user may not sense any UI change.\nAny of the signers can select the desired transaction and generate their commitment(s) for it. By doing so, the private part of the commitment(s) is stored in Minotaur, and its public part is sent to the MSS.\nAnyone who receives the transaction also receives all previous public commitments. He/She can add his/her own commitment(s) as described above.\nAs soon as the server receives all N commitments, the transaction is automatically sent for signing. In case any simulated signatures are required, they are created by the MSS. Moreover, any commitments that arrive after this point are rejected.\nAt this ..."
    }
  ],
  "qa_pairs": []
}