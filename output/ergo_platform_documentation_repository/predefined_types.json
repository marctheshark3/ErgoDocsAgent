{
  "title": "Predefined types",
  "source_url": "docs/dev/scs/ergotree/types.md",
  "summary": "$$\n\\newcommand{\\TEnv}{\\Gamma}\n\\newcommand{\\Der}[2]{#1~\\vdash~#2}\n\\newcommand{\\DerV}[2]{#1~\\vdash^{\\text{\\lst{v}}}~#2}\n\\newcommand{\\DerC}[2]{#1~\\vdash^{\\text{\\lst{c}}}~#2}\n\\newcommand{\\DerEnv}[1]{\\Der{\\TEnv}{#1}}\n\\newcommand{\\DerEnvV}[1]{\\DerV{\\TEnv}{#1}}\n\\newcommand{\\DerEnvC}[1]{\\DerC{\\TEnv}{#1}}\n\\newcommand{\\lst}[1]{#1}\n\\newcommand{\\Tup}[1]{(#1)}\n\\newcommand{\\Apply}[2]{#1\\langle#2\\rangle}\n\\newcommand{\\MSig}[3]{\\text{def}~#1(#2): #3}\n\\newcommand{\\Ov}[1]{\\overline{#1}}\n\\newcommand{\\TyLam}[3]{\\lambda(\\Ov{#1:#2}).#3}\n\\newcommand{\\Trait}[2]{\\text{trait}~#1~\\{ #2 \\}}\n\\newcommand{\\To}{\\mapsto}\n\\newcommand{\\Low}[1]{\\mathcal{L}{[\\![#1]\\!]}}\n\\newcommand{\\Lam}[2]{\\lambda#1.#2}\n\\newcommand{\\IfThenElse}[3]{\\text{if}~(#1)~#2~\\text{else}~#3}\n\\newcommand{\\False}{\\text{false}}\n\\newcommand{\\True}{\\text{true}}\n\\newcommand{\\langname}{ErgoTree}\n\\newcommand{\\corelang}{Core-\\lambda}\n\\newcommand{\\Denot}[1]{[\\![#1]\\!]}\n\\newcommand{\\Set}[1]{\\{ #1 \\}}\n$$\n\n# Predefined types\n\n\n### Boolean\n\n### Byte \n\n#### Byte.toByte (106.1)\n\n- *Description*: Converts this numeric value to **Byte**, throwing an exception on overflow. - *Signature*: **`def toByte: Byte`**\n- *Serialized as:* Downcast\n\n#### Byte.toShort (106.2)\n\n- *Description*: Converts this numeric value to **Short**, throwing an exception on overflow. - *Signature*: **`def toShort: Short`**\n- *Serialized as:* Upcast\n\n#### Byte.toInt (106.3)\n\n- *Description*: Converts this numeric value to **Int**, throwing an exception on overflow. - *Signature*: **`def toInt: Int`**\n- *Serialized as:* Upcast\n\n#### Byte.toLong (106.4)\n\n- *Description*: Converts this numeric value to **Long**, throwing an exception on overflow. - *Signature*: **`def toLong: Long`**\n- *Serialized as:* Upcast\n\n#### Byte.toBigInt (106.5)\n\n- *Description*: Converts this numeric value to **BigInt**.\n- *Signature*: **`def toBigInt: BigInt`**\n- *Serialized as:* Upcast\n\n\n### Short \n\n#### Short.toByte (106.1)\n\n- *Description*: Converts this numeric value to **Byte**, throwing an exception on overflow.",
  "keywords": [
    "\\newcommand{\\tenv}{\\gamma",
    "\\newcommand{\\der}[2]{#1~\\vdash~#2",
    "\\newcommand{\\derenv}[1]{\\der{\\tenv}{#1",
    "\\newcommand{\\derenvv}[1]{\\derv{\\tenv}{#1",
    "\\newcommand{\\derenvc}[1]{\\derc{\\tenv}{#1",
    "\\newcommand{\\lst}[1]{#1",
    "\\newcommand{\\tup}[1]{(#1",
    "\\newcommand{\\msig}[3]{\\text{def}~#1(#2",
    "\\newcommand{\\ov}[1]{\\overline{#1",
    "\\newcommand{\\tylam}[3]{\\lambda(\\ov{#1:#2}).#3",
    "\\newcommand{\\low}[1]{\\mathcal{l}{[\\![#1]\\",
    "\\newcommand{\\lam}[2]{\\lambda#1.#2",
    "\\newcommand{\\ifthenelse}[3]{\\text{if}~(#1)~#2~\\text{else}~#3",
    "\\newcommand{\\false}{\\text{false",
    "\\newcommand{\\true}{\\text{true",
    "\\newcommand{\\langname}{ergotree",
    "\\newcommand{\\set}[1]{\\",
    "type",
    "description",
    "convert",
    "value",
    "byte",
    "exception",
    "overflow",
    "signature",
    "downcast",
    "byte.toshort",
    "toshort",
    "short",
    "upcast",
    "byte.toint",
    "toint",
    "byte.tolong",
    "tolong",
    "tobigint",
    "bigint",
    "short.tobyte",
    "short.toshort",
    "short.toint",
    "short.tolong",
    "int.toshort",
    "int.toint",
    "long.tobyte",
    "long.toint",
    "long.tobigint",
    "bigint.tobigint",
    "groupelement",
    "return",
    "encoding",
    "point",
    "getencoded",
    "coll[byte",
    "propertycall",
    "number",
    "group",
    "element",
    "power",
    "exp(k",
    "parameters",
    "exponentiate",
    "groupelement.multiply",
    "operation",
    "multiplication",
    "multiply(other",
    "multiplygroup",
    "negate",
    "sigmaprop",
    "hold",
    "sigma",
    "proposition",
    "protocol",
    "expression",
    "primitive",
    "provedlog",
    "constant",
    "threshold",
    "syntax",
    "mnemonic",
    "|--||--|--|----|",
    "tree",
    "\\lst{trivial(b)}$",
    "\\lst{trivialprop}$",
    "\\lst{b}$",
    "\\mid$",
    "\\lst{dlog(ge)}$",
    "knowledge",
    "logarithm",
    "\\lst{ge}$",
    "\\lst{dhtuple(g",
    "v)}$",
    "\\lst{provedhtuple}$",
    "diffie",
    "hellman",
    "tuple",
    "\\lst{threshold}(k",
    "t_1,\\dot",
    "t_n)$",
    "secret",
    "\\lst{or}(t_1,\\dot",
    "\\lst{or}$",
    "\\lst{and}(t_1,\\dot",
    "\\lst{and}$",
    "\\lst{sigmaprop}$",
    "notation",
    "evaluation",
    "section](evaluation.md",
    "denotation",
    "\\denot{\\lst{sigmaprop",
    "\\set{t",
    "tree}$$",
    "method",
    "instance",
    "sigmaprop.propbyte",
    "ergotree",
    "result",
    "verifie",
    "frontend",
    "list",
    "appendix",
    "scorexfoundation",
    "sigmastate",
    "interpreter",
    "fada073b82a16a928c457693b888da4c0310aca6",
    "docs",
    "spec",
    "spec.pdf#appendix",
    "\\lst{long}$",
    "extractamount",
    "box.propositionbyte",
    "bytes",
    "guarding",
    "script",
    "box.byte",
    "content",
    "extractbytes",
    "box.byteswithoutref",
    "transactionid",
    "output",
    "index",
    "extractbyteswithnoref",
    "box.id",
    "blake2b256",
    "hash",
    "extractid",
    "box.creationinfo",
    "height",
    "transaction",
    "block",
    "identifier",
    "\\lst{(int",
    "coll[byte])}$",
    "extract",
    "some(value",
    "register",
    "none",
    "int}$",
    "\\lst{option[t]}$",
    "extractregisteras",
    "collection",
    "token",
    "\\lst{coll[(coll[byte],long)]}$",
    "property",
    "extractscriptbytes",
    "propositionbyte",
    "tokenid",
    "amount",
    "extracttokens",
    "creation",
    "information",
    "txid",
    "extractcreationinfo",
    "datum",
    "storage",
    "digest",
    "state",
    "root",
    "avltree.enabledoperation",
    "flag",
    "enabledoperation",
    "0x01",
    "0x02",
    "0x04",
    "\\lst{int}$",
    "avltree.valuelengthopt",
    "\\lst{boolean}$",
    "avltree.updateoperation",
    "methodcall",
    "avltree.contain",
    "avltree.get",
    "\\lst{coll[option[coll[byte]]]}$",
    "avltree.insert",
    "\\lst{option[avltree]}$",
    "avltree.remove",
    "preheader",
    "context",
    "coll",
    "option"
  ],
  "sections": [
    {
      "heading": "Byte.toByte (106.1)",
      "content": "Description: Converts this numeric value to Byte, throwing an exception on overflow.\nSignature: def toByte: Byte\nSerialized as: Downcast"
    },
    {
      "heading": "Byte.toShort (106.2)",
      "content": "Description: Converts this numeric value to Short, throwing an exception on overflow.\nSignature: def toShort: Short\nSerialized as: Upcast"
    },
    {
      "heading": "Byte.toInt (106.3)",
      "content": "Description: Converts this numeric value to Int, throwing an exception on overflow.\nSignature: def toInt: Int\nSerialized as: Upcast"
    },
    {
      "heading": "Byte.toLong (106.4)",
      "content": "Description: Converts this numeric value to Long, throwing an exception on overflow.\nSignature: def toLong: Long\nSerialized as: Upcast"
    },
    {
      "heading": "Byte.toBigInt (106.5)",
      "content": "Description: Converts this numeric value to BigInt.\nSignature: def toBigInt: BigInt\nSerialized as: Upcast"
    },
    {
      "heading": "Short.toByte (106.1)",
      "content": "Description: Converts this numeric value to Byte, throwing an exception on overflow.\nSignature: def toByte: Byte\nSerialized as: Downcast"
    },
    {
      "heading": "Short.toShort (106.2)",
      "content": "Description: Converts this numeric value to Short, throwing an exception on overflow.\nSignature: def toShort: Short\nSerialized as: Downcast"
    },
    {
      "heading": "Short.toInt (106.3)",
      "content": "Description: Converts this numeric value to Int, throwing an exception on overflow.\nSignature: def toInt: Int\nSerialized as: Downcast"
    },
    {
      "heading": "Short.toLong (106.4)",
      "content": "Description: Converts this numeric value to Long, throwing an exception on overflow.\nSignature: def toLong: Long\nSerialized as: Upcast"
    },
    {
      "heading": "Short.toBigInt (106.5)",
      "content": "Description: Converts this numeric value to BigInt.\nSignature: def toBigInt: BigInt\nSerialized as: Upcast"
    },
    {
      "heading": "Int.toByte (106.1)",
      "content": "Description: Converts this numeric value to Byte, throwing an exception on overflow.\nSignature: def toByte: Byte\nSerialized as: Downcast"
    },
    {
      "heading": "Int.toShort (106.2)",
      "content": "Description: Converts this numeric value to Short, throwing an exception on overflow.\nSignature: def toShort: Short\nSerialized as: Downcast"
    },
    {
      "heading": "Int.toInt (106.3)",
      "content": "Description: Converts this numeric value to Int, throwing an exception on overflow.\nSignature: def toInt: Int\nSerialized as: Downcast"
    },
    {
      "heading": "Int.toLong (106.4)",
      "content": "Description: Converts this numeric value to Long, throwing an exception on overflow.\nSignature: def toLong: Long\nSerialized as: Upcast"
    },
    {
      "heading": "Int.toBigInt (106.5)",
      "content": "Description: Converts this numeric value to BigInt.\nSignature: def toBigInt: BigInt\nSerialized as: Upcast"
    },
    {
      "heading": "Long.toByte (106.1)",
      "content": "Description: Converts this numeric value to Byte, throwing an exception on overflow.\nSignature: def toByte: Byte\nSerialized as: Downcast"
    },
    {
      "heading": "Long.toShort (106.2)",
      "content": "Description: Converts this numeric value to Short, throwing an exception on overflow.\nSignature: def toShort: Short\nSerialized as: Downcast"
    },
    {
      "heading": "Long.toInt (106.3)",
      "content": "Description: Converts this numeric value to Int, throwing an exception on overflow.\nSignature: def toInt: Int\nSerialized as: Downcast"
    },
    {
      "heading": "Long.toLong (106.4)",
      "content": "Description: Converts this numeric value to Long, throwing an exception on overflow.\nSignature: def toLong: Long\nSerialized as: Downcast"
    },
    {
      "heading": "Long.toBigInt (106.5)",
      "content": "Description: Converts this numeric value to BigInt.\nSignature: def toBigInt: BigInt\nSerialized as: Upcast"
    },
    {
      "heading": "BigInt.toBigInt (106.5)",
      "content": "Description: Converts this numeric value to BigInt.\nSignature: def toBigInt: BigInt\nSerialized as: Downcast"
    },
    {
      "heading": "GroupElement.getEncoded (7.2)",
      "content": "Description: Returns an encoding of the point value.\nSignature: def getEncoded: Coll[Byte]\nSerialized as: PropertyCall"
    },
    {
      "heading": "GroupElement.exp (7.3)",
      "content": "Description: Exponentiates this GroupElement to the given number. Returns this group element raised to the power of k.\nSignature: def exp(k: BigInt): GroupElement\nParameters: k The power\nSerialized as: Exponentiate"
    },
    {
      "heading": "GroupElement.multiply (7.4)",
      "content": "Description: Performs the group operation (multiplication) with another element.\nSignature: def multiply(other: GroupElement): GroupElement\nParameters: other The other element of the group.\nSerialized as: MultiplyGroup"
    },
    {
      "heading": "GroupElement.negate (7.5)",
      "content": "Description: Returns the inverse element in the group.\nSignature: def negate: GroupElement\nSerialized as: PropertyCall"
    },
    {
      "heading": "SigmaProp",
      "content": "Values of SigmaProp type hold sigma propositions, which can be proved and verified using Sigma protocols. Each sigma proposition is represented as an expression where sigma protocol primitives such as ProveDlog and ProveDHTuple are used as constants, and special sigma protocol connectives like AND, OR, and THRESHOLD are used as operations.\nThe abstract syntax of sigma propositions is shown below.\n| Set | | Syntax | Mnemonic | Description |\n|--||--|--|----|\n| $Tree \\ni t$  | :=    | $\\lst{Trivial(b)}$    | $\\lst{TrivialProp}$   | boolean value $\\lst{b}$ as sigma proposition\n|   | $\\mid$    | $\\lst{Dlog(ge)}$  | $\\lst{ProveDLog}$ | knowledge of discrete logarithm of $\\lst{ge}$\n|   | $\\mid$    | $\\lst{DHTuple(g,h,u,v)}$  | $\\lst{ProveDHTuple}$  | knowledge of Diffie-Hellman tuple \n|   | $\\mid$    | $\\lst{THRESHOLD}(k,t_1,\\dots,t_n)$    | $\\lst{THRESHOLD}$ | knowledge of $k$ out of $n$ secrets\n|   | $\\mid$    | $\\lst{OR}(t_1,\\dots,t_n)$ | $\\lst{OR}$    | knowledge of any one of $n$ secrets\n|   | $\\mid$    | $\\lst{AND}(t_1,\\dots,t_n)$    | $\\lst{AND}$   | knowledge of all $n$ secrets\nEvery well-formed tree of sigma proposition is a value of type $\\lst{SigmaProp}$, thus following the notation of the evaluation section we can define denotation of $\\lst{SigmaProp}$\n$$\\Denot{\\lst{SigmaProp}} = \\Set{t \\in Tree}$$\nThe following methods can be called on all instances of $\\lst{SigmaProp}$ type."
    },
    {
      "heading": "SigmaProp.propBytes (8.1)",
      "content": "Description: Returns the serialized bytes of this sigma proposition represented as ErgoTree.\nParameters: \nResult: Coll[Byte]\nSerialized as: SigmaPropBytes"
    },
    {
      "heading": "SigmaProp.isProven (8.2)",
      "content": "Description: Verifies that the sigma proposition is proven. (FRONTEND ONLY)\nParameters: \nResult: Boolean\nFor a full list of primitive operations on  $\\lst{SigmaProp}$ type, see Appendix B"
    },
    {
      "heading": "Box.value (99.1)",
      "content": "Description: Monetary value in nanoErgs.\nParameters: \nResult: $\\lst{Long}$\nSerialized as: ExtractAmount"
    },
    {
      "heading": "Box.propositionBytes (99.2)",
      "content": "Description: Serialized bytes of the guarding script. This script must evaluate to true to spend the box.\nParameters: \nResult: $\\lst{Coll[Byte]}$\nSerialized as: ExtractScriptBytes"
    },
    {
      "heading": "Box.bytes (99.3)",
      "content": "Description: Returns the serialized bytes of this box's content, including proposition bytes.\nParameters: \nResult: $\\lst{Coll[Byte]}$\nSerialized as: ExtractBytes"
    },
    {
      "heading": "Box.bytesWithoutRef (99.4)",
      "content": "Description: Returns the serialized bytes of this box's content, excluding the transactionId and output index.\nParameters: \nResult: $\\lst{Coll[Byte]}$\nSerialized as: ExtractBytesWithNoRef"
    },
    {
      "heading": "Box.id (99.5)",
      "content": "Description: Returns the Blake2b256 hash of this box's content (blake2b256(bytes)).\nParameters: \nResult: $\\lst{Coll[Byte]}$\nSerialized as: ExtractId"
    },
    {
      "heading": "Box.creationInfo (99.6)",
      "content": "Description: Returns the height and transaction/output index where the box was created. creationInfo._1 is the block height, and creationInfo._2 is the transaction identifier concatenated with the box index.\nParameters: \nResult: $\\lst{(Int,Coll[Byte])}$\nSerialized as: ExtractCreationInfo"
    },
    {
      "heading": "Box.getReg (99.7)",
      "content": "Description: Extracts register regId by ID and expected type T. Returns Some(value) if the register exists and has the specified type, None otherwise.\nParameters: $\\lst{regId : Int}$ // zero-based identifier of the register.\nResult: $\\lst{Option[T]}$\nSerialized as: ExtractRegisterAs"
    },
    {
      "heading": "Box.tokens (99.8)",
      "content": "Description: Returns the collection of secondary tokens held in the box.\nParameters: \nResult: $\\lst{Coll[(Coll[Byte],Long)]}$\nSerialized as: PropertyCall"
    },
    {
      "heading": "Box.R0 (99.9)",
      "content": "Description: Register R0: Monetary value in nanoErgs. Use ExtractAmount (value property).\nParameters: \nResult: $\\lst{Option[T]}$\nSerialized as: ExtractRegisterAs"
    },
    {
      "heading": "Box.R1 (99.10)",
      "content": "Description: Register R1: Guarding script bytes. Use ExtractScriptBytes (propositionBytes property).\nParameters: \nResult: $\\lst{Option[T]}$\nSerialized as: ExtractRegisterAs"
    },
    {
      "heading": "Box.R2 (99.11)",
      "content": "Description: Register R2: Secondary tokens [(TokenId, Amount)]. Use ExtractTokens (tokens property).\nParameters: \nResult: $\\lst{Option[T]}$\nSerialized as: ExtractRegisterAs"
    },
    {
      "heading": "Box.R3 (99.12)",
      "content": "Description: Register R3: Box creation information (height, txId, index). Use ExtractCreationInfo (creationInfo property).\nParameters: \nResult: $\\lst{Option[T]}$\nSerialized as: ExtractRegisterAs"
    },
    {
      "heading": "Box.R4 (99.13)",
      "content": "Description: Optional register R4 for arbitrary data storage. Use ExtractRegisterAs.\nParameters: \nResult: $\\lst{Option[T]}$\nSerialized as: ExtractRegisterAs"
    },
    {
      "heading": "Box.R5 (99.14)",
      "content": "Description: Optional register R5 for arbitrary data storage. Use ExtractRegisterAs.\nParameters: \nResult: $\\lst{Option[T]}$\nSerialized as: ExtractRegisterAs"
    },
    {
      "heading": "Box.R6 (99.15)",
      "content": "Description: Optional register R6 for arbitrary data storage. Use ExtractRegisterAs.\nParameters: \nResult: $\\lst{Option[T]}$\nSerialized as: ExtractRegisterAs"
    },
    {
      "heading": "Box.R7 (99.16)",
      "content": "Description: Optional register R7 for arbitrary data storage. Use ExtractRegisterAs.\nParameters: \nResult: $\\lst{Option[T]}$\nSerialized as: ExtractRegisterAs"
    },
    {
      "heading": "Box.R8 (99.17)",
      "content": "Description: Optional register R8 for arbitrary data storage. Use ExtractRegisterAs.\nParameters: \nResult: $\\lst{Option[T]}$\nSerialized as: ExtractRegisterAs"
    },
    {
      "heading": "Box.R9 (99.18)",
      "content": "Description: Optional register R9 for arbitrary data storage. Use ExtractRegisterAs.\nParameters: \nResult: $\\lst{Option[T]}$\nSerialized as: ExtractRegisterAs"
    },
    {
      "heading": "AvlTree.digest (100.1)",
      "content": "Description: Returns the digest of the state represented by this tree (root hash bytes ++ tree height).\nParameters: \nResult: $\\lst{Coll[Byte]}$\nSerialized as: PropertyCall"
    },
    {
      "heading": "AvlTree.enabledOperations (100.2)",
      "content": "Description: Returns the flags of enabled operations packed into a single byte.\nParameters: \nResult: $\\lst{Byte}$\nSerialized as: PropertyCall\nscala\nisInsertAllowed == (enabledOperations & 0x01) != 0\nisUpdateAllowed == (enabledOperations & 0x02) != 0\nisRemoveAllowed == (enabledOperations & 0x04) != 0"
    },
    {
      "heading": "AvlTree.keyLength (100.3)",
      "content": "Description: \nParameters: \nResult: $\\lst{Int}$\nSerialized as: PropertyCall"
    },
    {
      "heading": "AvlTree.valueLengthOpt (100.4)",
      "content": "Description: \nParameters: \nResult: $\\lst{Coll[Byte]}$\nSerialized as: PropertyCall"
    },
    {
      "heading": "AvlTree.isInsertAllowed (100.5)",
      "content": "Description: \nParameters: \nResult: $\\lst{Coll[Byte]}$\nSerialized as: PropertyCall"
    },
    {
      "heading": "AvlTree.isUpdateAllowed (100.6)",
      "content": "Description: \nParameters: \nResult: $\\lst{Boolean}$\nSerialized as: PropertyCall"
    },
    {
      "heading": "AvlTree.isRemovedAllowed (100.7)",
      "content": "Description: \nParameters: \nResult: $\\lst{Boolean}$\nSerialized as: PropertyCall"
    },
    {
      "heading": "AvlTree.updateOperations (100.8)",
      "content": "Description: \nParameters: \nResult: $\\lst{AvlTree}$\nSerialized as: MethodCall"
    },
    {
      "heading": "AvlTree.contains (100.9)",
      "content": "Description: \nParameters: \nResult: $\\lst{Boolean}$\nSerialized as: MethodCall"
    },
    {
      "heading": "AvlTree.get (100.10)",
      "content": "Description: \nParameters: \nResult: $\\lst{Option[Coll[Byte]]}$\nSerialized as: MethodCall"
    },
    {
      "heading": "AvlTree.getMeny (100.11)",
      "content": "Description: \nParameters: \nResult: $\\lst{Coll[Option[Coll[Byte]]]}$\nSerialized as: MethodCall"
    },
    {
      "heading": "AvlTree.insert (100.12)",
      "content": "Description: \nParameters: \nResult: $\\lst{Option[AvlTree]}$\nSerialized as: MethodCall"
    },
    {
      "heading": "AvlTree.update (100.13)",
      "content": "Description: \nParameters: \nResult: $\\lst{Option[AvlTree]}$\nSerialized as: MethodCall"
    },
    {
      "heading": "AvlTree.remove (100.14)",
      "content": "Description:\nParameters: \nResult: $\\lst{Option[AvlTree]}$\nSerialized as: MethodCall"
    },
    {
      "heading": "AvlTree.updateDigest (100.15)",
      "content": "Description: \nParameters: \nResult: $\\lst{AvlTree}$\nSerialized as: MethodCall"
    }
  ],
  "qa_pairs": []
}