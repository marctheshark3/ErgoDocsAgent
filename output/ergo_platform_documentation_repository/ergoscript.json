{
  "title": "ErgoScript",
  "source_url": "docs/dev/scs/ergoscript.md",
  "summary": "---\ntags:\n  - ErgoScript\n  - Smart Contracts\n  - Sigma Protocols\n---\n\n# ErgoScript\n\n## Overview\n\n**ErgoScript** is a powerful, developer-friendly programming language designed specifically for writing [smart contracts](contracts.md) on the [Ergo blockchain](protocol-overview.md). Think of it as a specialized language that allows you to create complex [financial contracts](contracts.md) and applications with unprecedented flexibility and [security](security.md). Designed as a subset of Scala, it allows developers to define complex conditions for spending funds. ErgoScript code is translated into a lower-level representation called [**ErgoTree**](ergotree.md) before being stored on the [blockchain](protocol-overview.md). During [transaction validation](validation.md), ErgoTree is interpreted using cryptographic protocols based on [Sigma Protocols](sigma.md).",
  "keywords": [
    "ergoscript",
    "smart",
    "contracts",
    "sigma",
    "protocols",
    "overview",
    "developer",
    "programming",
    "language",
    "contracts](contracts.md",
    "ergo",
    "blockchain](protocol",
    "application",
    "flexibility",
    "subset",
    "scala",
    "condition",
    "fund",
    "code",
    "level",
    "representation",
    "ergotree**](ergotree.md",
    "transaction",
    "validation](validation.md",
    "ergotree",
    "protocol",
    "protocols](sigma.md",
    "architecture",
    "functionality",
    "ring",
    "signatures](ring.md",
    "threshold",
    "signatures](threshold.md",
    "scripting",
    "core",
    "change",
    "admonition",
    "type",
    "support",
    "protocols**](sigma.md",
    "schnorr",
    "proof",
    "feature",
    "building",
    "block",
    "knowledge",
    "proofs](zkp.md",
    "proofs](schnorr.md",
    "diffie",
    "hellman",
    "tuples](diffie.md",
    "default",
    "potential",
    "community",
    "forks](soft",
    "fork.md",
    "security",
    "principle",
    "bitcoin",
    "contract",
    "script",
    "ability",
    "blockchain",
    "state",
    "logic",
    "turing",
    "complete",
    "computation",
    "interactions](multi.md",
    "////",
    "detail",
    "background",
    "reading",
    "info",
    "model",
    "comparison",
    "eutxo",
    "ethereum",
    "account",
    "paradigm",
    "coin",
    "balance",
    "storage",
    "utxos](eutxo.md",
    "scalability",
    "validity",
    "check",
    "chain",
    "execution",
    "transactions](transactions.md",
    "validation",
    "load",
    "nodes](modes.md",
    "nature",
    "graph",
    "optimization",
    "throughput",
    "design",
    "facilitate",
    "verifying",
    "nodes**](nipopow_nodes.md",
    "nipopows](nipopows.md",
    "network",
    "scalability](scaling.md",
    "accessibility",
    "share",
    "interaction",
    "system",
    "utxo",
    "concept",
    "environment",
    "simplifie",
    "development",
    "clients](light",
    "node.md",
    "expressive",
    "power",
    "limitation",
    "bloat",
    "cost",
    "limit",
    "complexity",
    "model](eutxo.md",
    "stage",
    "txs.md",
    "predictability",
    "simple",
    "example",
    "alice",
    "height",
    "alicepubkey",
    "bobpubkey",
    "context",
    "variable",
    "height](block",
    "header.md",
    "signature",
    "check](signing.md",
    "concepts",
    "ergoscript](ergoscript",
    "concepts.md",
    "data",
    "inputs",
    "note",
    "approach",
    "datum",
    "boxes](box.md",
    "inputs.md",
    "access",
    "information",
    "oracle",
    "price",
    "feeds](oracles.md",
    "parameter",
    "node",
    "distinction",
    "here](ergotree.md",
    "tooling",
    "simplicity",
    "inspection",
    "testing",
    "tool",
    "process",
    "guide](debugging.md",
    "practice",
    "technique",
    "simulator](https://github.com",
    "spectrum",
    "finance",
    "simulator",
    "playground](https://wallet.plutomonkey.com",
    "p2s/",
    "experiment",
    "addresses](address.md",
    "escript.online](https://escript.online/",
    "editor",
    "compiler",
    "scastie](scastie.md",
    "online",
    "snippet",
    "kiosk](stack",
    "kiosk.md",
    "puppet](puppet.md",
    "experimentation",
    "patterns",
    "tutorials",
    "implementation",
    "pattern",
    "finite",
    "machines",
    "behavior",
    "merkleized",
    "abstract",
    "syntax",
    "trees",
    "mast)](mast",
    "explore",
    "privacy",
    "efficiency",
    "spending",
    "branch",
    "common",
    "cases",
    "multi",
    "wallets](threshold.md",
    "wallet",
    "party",
    "time",
    "locked",
    "define",
    "conditional",
    "input",
    "atomic",
    "swaps",
    "trustless",
    "peer",
    "exchange",
    "asset",
    "crowdfunding",
    "campaign",
    "complex",
    "financial",
    "derivative",
    "build",
    "instrument",
    "best",
    "primitives](crypto.md",
    "test",
    "playground",
    "framework",
    "reason",
    "path",
    "exploit",
    "leverage",
    "inputs](read",
    "pitfalls",
    "overcomplicating",
    "performance",
    "implication",
    "neglecting",
    "error",
    "handling",
    "edge",
    "case",
    "nuance",
    "lifecycle",
    "transition",
    "insecure",
    "secret",
    "assumption",
    "component",
    "learning",
    "paths",
    "next",
    "step",
    "beginner",
    "concepts](ergoscript",
    "study",
    "intermediate",
    "patterns](multi.md",
    "tutorial",
    "appkit](appkit.md",
    "fleet](fleet.md",
    "sigmarust](sigma",
    "understand",
    "compilation",
    "serialization](ergotree.md",
    "protocols](crypto.md",
    "source",
    "project",
    "dapp",
    "join",
    "discussion",
    "discord](https://discord.gg",
    "platform-668903786361651200",
    "rust",
    "fleet",
    "ergo_dev",
    "forum](https://www.ergoforum.org/",
    "question",
    "collaborate",
    "advanced",
    "cryptography",
    "structures",
    "foundation",
    "primitive",
    "structure",
    "consideration",
    "merkle",
    "trees](",
    "/data",
    "tree.md",
    "integrity",
    "extension",
    "verification",
    "function",
    "relie",
    "root",
    "mast",
    "pattern](tx",
    "tree",
    "executefromvar",
    "usage",
    "documentation](",
    "technical",
    "resources",
    "documentation](ergotree.md",
    "overview](sigma.md",
    "signatures](schnorr.md",
    "light",
    "nodes](nipopow_nodes.md",
    "explanation](eutxo.md",
    "whitepaper](https://ergoplatform.org",
    "specification](lang",
    "spec.md",
    "reference",
    "tutorial](https://ergoplatform.org",
    "docs",
    "advancedergoscripttutorial.pdf",
    "comparative",
    "analysis",
    "completeness",
    "risk",
    "costs](min",
    "fee.md",
    "minimize",
    "computation](ergoscript.md",
    "graph](transactions.md",
    "complete](multi",
    "base",
    "infinite",
    "loop",
    "interpreter",
    "style",
    "guide](https://github.com",
    "sigmastate",
    "blob",
    "develop",
    "perf"
  ],
  "sections": [
    {
      "heading": "Overview",
      "content": "ErgoScript is a powerful, developer-friendly programming language designed specifically for writing smart contracts on the Ergo blockchain. Think of it as a specialized language that allows you to create complex financial contracts and applications with unprecedented flexibility and security. Designed as a subset of Scala, it allows developers to define complex conditions for spending funds.\nErgoScript code is translated into a lower-level representation called ErgoTree before being stored on the blockchain. During transaction validation, ErgoTree is interpreted using cryptographic protocols based on Sigma Protocols. This unique architecture enables Ergo to support advanced cryptographic functionalities like ring signatures and threshold signatures directly within the scripting language, without requiring special core protocol changes.\n/// admonition | Sigma Protocols\n    type: tip\nErgo's support for Sigma Protocols (aka generalized Schnorr proofs) is a key feature, providing efficient and composable building blocks for zero-knowledge proofs. Schnorr proofs and proofs of Diffie-Hellman tuples are supported by default, with the potential for the community to add more through soft forks.\n///\nErgoScript builds upon the security principles of Bitcoin while enabling much more complex financial contracts. Unlike Bitcoin Script, ErgoScript supports features necessary for advanced applications, including the ability to reference blockchain state and implement complex logic, effectively enabling Turing-Complete computations through multi-stage contract interactions.\n//// details | Background Reading\n    {type: info, open: false}\n/// details | Contract Model Comparison: Ergo (eUTXO) vs. Ethereum (Account)\n    {type: info, open: false}"
    },
    {
      "heading": "Paradigm",
      "content": "The account model (used by Ethereum) is imperative: sending coins involves changing balances in a global storage state. Ergo's eUTXO-based programming model is declarative: ErgoScript contracts specify conditions under which funds (UTXOs) can be spent, rather than dictating state changes."
    },
    {
      "heading": "Scalability",
      "content": "In the account model, both storage changes and validity checks happen on-chain during contract execution. In Ergo, transactions are typically created off-chain, and only the validation checks occur on-chain. This significantly reduces the computational load on validating nodes. The immutable nature of the transaction graph also allows for various optimizations to improve throughput. Furthermore, Ergo's design facilitates light verifying nodes (via NIPoPoWs), enhancing network scalability and accessibility."
    },
    {
      "heading": "Shared State",
      "content": "The account-based model relies on a shared mutable state, which can lead to complex interactions and subtle bugs in concurrent systems. Ergo's model, based on Bitcoin's UTXO concept, uses an immutable graph of transactions, which is inherently more suitable for distributed environments and simplifies the development of light clients."
    },
    {
      "heading": "Expressive Power",
      "content": "While Ethereum's Turing-complete language offers theoretical flexibility, it has practical limitations like blockchain bloat, complex bugs, unpredictable gas costs, and limits on contract complexity. Ergo achieves similar expressive power through its eUTXO model and multi-stage contracts, but intentionally keeps the core ErgoScript language itself non-Turing-complete to enhance security and predictability.\n///\n/// admonition | Simple Example\n    type: info\nscala\n// This script locks funds in a box.\n// It allows Alice to spend the funds before block 100,000,\n// OR Bob to spend them at or after block 100,000.\n{\n  (HEIGHT < 100000 && alicePubKey) ||\n  (HEIGHT >= 100000 && bobPubKey)\n}\n(HEIGHT is a context variable representing the current block height. alicePubKey and bobPubKey represent proof of knowledge of their respective secret keys, typically via a signature check).\n///\n/// admonition | Key Concepts\n    type: info\nExplore the Core Concepts of ErgoScript.\n///\n/// admonition | Data Inputs\n    type: note\nErgo offers a unique approach to smart contracts by allowing them to access data from other boxes on the blockchain without spending them, using data inputs. This enables efficient access to shared information like oracle price feeds or DAO parameters.\n///\n/// admonition | ErgoScript vs ErgoTree\n    type: note\nErgoScript is the high-level, developer-friendly language. It gets compiled into ErgoTree, a lower-level, serialized representation stored on the blockchain and interpreted by nodes. Explore the distinction here.\n///\n////"
    },
    {
      "heading": "Experimenting & Tooling",
      "content": "While ErgoScript aims for simplicity and security, debugging complex contracts can still be challenging. Currently, developers often rely on manual inspection and testing using the tools below. Tools are emerging to improve this process:\nDebugging Guide: Covers current best practices, tools, and techniques for debugging ErgoScript.\nErgoscript Simulator: A community-developed tool that allows simulating ErgoScript execution.\nErgoScript P2S Playground: Experiment and generate Ergo addresses.\nescript.online: Online editor and compiler.\nScastie: Online Scala compiler suitable for ErgoScript snippets.\nKiosk: Web-based UI to explore ErgoScript.\nErgo-Puppet: Advanced tool for off-chain experimentation and testing."
    },
    {
      "heading": "Advanced Patterns & Tutorials",
      "content": "ErgoScript's features enable the implementation of complex contract patterns:\nFinite State Machines (FSMs): Learn how to model multi-stage contracts where behavior depends on the current state encoded within a box.\nMerkleized Abstract Syntax Trees (MAST): Explore techniques to improve privacy and efficiency for contracts with many spending conditions by revealing only the executed script branch."
    },
    {
      "heading": "Common Use Cases",
      "content": "ErgoScript's flexibility enables various applications:\nMulti-Signature Wallets: Create wallets requiring multiple parties to approve transactions.\nTime-Locked Contracts: Define contracts that can only be executed after a specific time or block height.\nConditional Spending: Set complex conditions for spending funds based on various parameters (e.g., oracle data, specific inputs).\nAtomic Swaps: Facilitate trustless peer-to-peer exchange of different assets across blockchains or within Ergo.\nCrowdfunding: Implement secure and transparent crowdfunding campaigns.\nComplex Financial Derivatives: Build sophisticated financial instruments on the blockchain."
    },
    {
      "heading": "Best Practices",
      "content": "Keep contracts simple and readable.\nUse built-in cryptographic primitives where possible.\nAlways consider transaction validation overhead and potential costs.\nTest contracts thoroughly using playgrounds and SDK testing frameworks.\nReason carefully about all possible execution paths and potential economic exploits.\nLeverage data inputs for accessing shared state efficiently."
    },
    {
      "heading": "Common Pitfalls to Avoid",
      "content": "Overcomplicating contract logic unnecessarily.\nIgnoring performance implications and transaction costs.\nNeglecting comprehensive error handling and edge cases in off-chain code interacting with contracts.\nNot fully understanding the nuances of the eUTXO model (e.g., box lifecycle, state transitions).\nInsecure handling of secrets or assumptions about context in off-chain components."
    },
    {
      "heading": "Learning Paths & Next Steps",
      "content": "Beginner:\nUnderstand the Core Concepts.\nExperiment with the P2S Playground.\nStudy simple example contracts.\n\n\nIntermediate:\nLearn about Sigma Protocols.\nExplore Multi-Stage Contract patterns.\nWork through SDK tutorials (AppKit, Fleet, SigmaRust).\n\n\nAdvanced:\nUnderstand ErgoTree Compilation & Serialization.\nExplore advanced cryptographic protocols.\nContribute to open-source projects or build your own dApp.\nJoin community discussions on Discord (#ergoscript, #sigma-rust, #appkit, #fleet), Telegram, or the Ergo Forum to ask questions and collaborate."
    },
    {
      "heading": "Advanced Cryptography & Structures",
      "content": "ErgoScript's foundation on Sigma Protocols allows for powerful cryptographic primitives. However, some advanced structures have specific considerations:\nMerkle Trees: While Merkle Trees are fundamental to Ergo's data integrity (e.g., for transactions and extension data), direct verification of arbitrary Merkle proofs within an ErgoScript contract is not natively supported by a single built-in function. Verification typically happens off-chain or relies on specific protocol designs where roots are checked. The MAST pattern leverages Merkle trees conceptually, often using executeFromVar for on-chain execution of proven branches rather than full proof verification within the script. Developers interested in the general concept and off-chain usage should consult the main Merkle Tree documentation."
    },
    {
      "heading": "Related Technical Resources",
      "content": "ErgoTree Documentation\nSigma Protocols Overview\nSchnorr Signatures\nLight Verifying Nodes\neUTXO Model Explanation\nErgo Whitepaper\nErgoScript Language Specification (Detailed reference)\nAdvanced ErgoScript Tutorial"
    },
    {
      "heading": "Comparative Analysis",
      "content": "ErgoScript stands out by:\nEnabling complex logic via the eUTXO model without full on-chain Turing-completeness risks.\nNatively supporting advanced cryptographic protocols (Sigma Protocols).\nAllowing complex financial contracts with predictable execution costs.\nMaintaining a declarative, secure programming model based on UTXOs."
    },
    {
      "heading": "Performance Considerations",
      "content": "Off-chain transaction creation minimizes on-chain computation.\nOn-chain validation focuses only on script conditions.\nImmutable transaction graph allows for optimizations.\nNative support for light verifying nodes enhances accessibility.\nNon-Turing complete base language prevents infinite loops and simplifies cost analysis.\nSee the Interpreter Performance Style Guide for tips on writing efficient scripts."
    }
  ],
  "qa_pairs": []
}