{
  "title": "Serialization",
  "source_url": "docs/dev/scs/ergotree/serialization.md",
  "summary": "$$\n\\newcommand{\\TEnv}{\\Gamma}\n\\newcommand{\\Der}[2]{#1~\\vdash~#2}\n\\newcommand{\\DerV}[2]{#1~\\vdash^{\\text{\\lst{v}}}~#2}\n\\newcommand{\\DerC}[2]{#1~\\vdash^{\\text{\\lst{c}}}~#2}\n\\newcommand{\\DerEnv}[1]{\\Der{\\TEnv}{#1}}\n\\newcommand{\\DerEnvV}[1]{\\DerV{\\TEnv}{#1}}\n\\newcommand{\\DerEnvC}[1]{\\DerC{\\TEnv}{#1}}\n\\newcommand{\\lst}[1]{#1}\n\\newcommand{\\Tup}[1]{(#1)}\n\\newcommand{\\Apply}[2]{#1\\langle#2\\rangle}\n\\newcommand{\\MSig}[3]{\\text{def}~#1(#2): #3}\n\\newcommand{\\Ov}[1]{\\overline{#1}}\n\\newcommand{\\TyLam}[3]{\\lambda(\\Ov{#1:#2}).#3}\n\\newcommand{\\Trait}[2]{\\text{trait}~#1~\\{ #2 \\}}\n\\newcommand{\\To}{\\mapsto}\n\\newcommand{\\Low}[1]{\\mathcal{L}{[\\![#1]\\!]}}\n\\newcommand{\\Lam}[2]{\\lambda#1.#2}\n\\newcommand{\\IfThenElse}[3]{\\text{if}~(#1)~#2~\\text{else}~#3}\n\\newcommand{\\False}{\\text{false}}\n\\newcommand{\\True}{\\text{true}}\n\\newcommand{\\langname}{ErgoTree}\n\\newcommand{\\corelang}{Core-\\lambda}\n\\newcommand{\\MaxVlqSize}{VLQ_{max}}\n\\newcommand{\\MaxBits}{Bits_{max}}\n\\newcommand{\\MaxBytes}{Bytes_{max}}\n\\newcommand{\\MaxTypeSize}{T_{max}}\n\\newcommand{\\MaxDataSize}{D_{max}}\n\\newcommand{\\MaxBox}{Box_{max}}\n\\newcommand{\\MaxSigmaProp}{SigmaProp_{max}}\n\\newcommand{\\MaxAvlTree}{AvlTree_{max}}\n\\newcommand{\\MaxConstSize}{C_{max}}\n\\newcommand{\\MaxExprSize}{Expr_{max}}\n\\newcommand{\\MaxErgoTreeSize}{ErgoTree_{max}}\n\\newcommand{\\Denot}[1]{[\\![#1]\\!]}\n\\newcommand{\\ASDag}{ErgoTree}\n$$\n\n# Serialization\n\nThis page defines the binary format used to store ErgoTree contracts in persistent stores, transfer them over the wire, and enable cross-platform interoperation. ## Overview\n\nThe terms of the [ErgoTree language](ergotree-lang.md) can be serialized into an array of bytes for storage in the Ergo blockchain (e.g., in the `propositionBytes` field of a `Box`). When the guarding script of a transaction's input box is validated, the `propositionBytes` array is deserialized into an **ErgoTree Intermediate Representation (IR)** (represented by the `ErgoTree` class in the reference implementation), which can then be [evaluated](evaluation.md). The serialization procedure is specified in general terms. The serialization format for ErgoTree types (specified by the `SType` class hierarchy) and expression nodes (specified by the `Value` class hierarchy) is defined in [section 5.1](#table-1-serialization-limits) and",
  "keywords": [
    "\\newcommand{\\tenv}{\\gamma",
    "\\newcommand{\\der}[2]{#1~\\vdash~#2",
    "\\newcommand{\\derenv}[1]{\\der{\\tenv}{#1",
    "\\newcommand{\\derenvv}[1]{\\derv{\\tenv}{#1",
    "\\newcommand{\\derenvc}[1]{\\derc{\\tenv}{#1",
    "\\newcommand{\\lst}[1]{#1",
    "\\newcommand{\\tup}[1]{(#1",
    "\\newcommand{\\msig}[3]{\\text{def}~#1(#2",
    "\\newcommand{\\ov}[1]{\\overline{#1",
    "\\newcommand{\\tylam}[3]{\\lambda(\\ov{#1:#2}).#3",
    "\\newcommand{\\low}[1]{\\mathcal{l}{[\\![#1]\\",
    "\\newcommand{\\lam}[2]{\\lambda#1.#2",
    "\\newcommand{\\ifthenelse}[3]{\\text{if}~(#1)~#2~\\text{else}~#3",
    "\\newcommand{\\false}{\\text{false",
    "\\newcommand{\\true}{\\text{true",
    "\\newcommand{\\langname}{ergotree",
    "\\newcommand{\\maxvlqsize}{vlq_{max",
    "\\newcommand{\\maxbits}{bits_{max",
    "\\newcommand{\\maxtypesize}{t_{max",
    "\\newcommand{\\maxdatasize}{d_{max",
    "\\newcommand{\\maxbox}{box_{max",
    "\\newcommand{\\maxsigmaprop}{sigmaprop_{max",
    "\\newcommand{\\maxavltree}{avltree_{max",
    "\\newcommand{\\maxconstsize}{c_{max",
    "\\newcommand{\\maxexprsize}{expr_{max",
    "\\newcommand{\\maxergotreesize}{ergotree_{max",
    "\\newcommand{\\asdag}{ergotree",
    "serialization",
    "page",
    "format",
    "ergotree",
    "contract",
    "store",
    "wire",
    "interoperation",
    "term",
    "lang.md",
    "array",
    "byte",
    "storage",
    "ergo",
    "blockchain",
    "propositionbytes",
    "field",
    "guarding",
    "script",
    "transaction",
    "input",
    "intermediate",
    "representation",
    "class",
    "reference",
    "implementation",
    "procedure",
    "type",
    "stype",
    "hierarchy",
    "expression",
    "node",
    "value",
    "section",
    "limit",
    "appendix",
    "table",
    "size",
    "deserialization",
    "attack",
    "description",
    "|---|---|---|",
    "maximum",
    "sequence",
    "data",
    "instance",
    "const",
    "expr",
    "name",
    "number",
    "stream",
    "bytes",
    "two's",
    "complement",
    "integer",
    "\\lst{short}$",
    "endian",
    "\\lst{int}$",
    "\\lst{long}$",
    "\\lst{ubyte}$",
    "\\lst{ushort}$",
    "\\lst{uint}$",
    "\\lst{ulong}$",
    "\\lst{vlq(uint)}$",
    "\\lst{vlq(ulong)}$",
    "\\maxvlqsize]$",
    "|$\\lst{bits}$",
    "collection",
    "|$\\lst{bytes}$",
    "\\maxbytes]$",
    "\\maxtypesize]$",
    "serialized",
    "|$\\lst{data}$",
    "\\maxdatasize]$",
    "|$\\lst{groupelement}$",
    "element",
    "curve",
    "group",
    "sigma",
    "proposition",
    "|$\\lst{avltree}$",
    "digest",
    "|$\\lst{constant}$",
    "\\maxconstsize]$",
    "\\langname$",
    "constant",
    "|$\\lst{expr}$",
    "\\maxexprsize]$",
    "|$\\lst{ergotree}$",
    "\\maxergotreesize]$",
    "notation",
    "datum",
    "case",
    "logic",
    "pseudo",
    "language",
    "operator",
    "specification",
    "structure",
    "slot",
    "fragment",
    "\\denot{t}$",
    "pattern",
    "pair",
    "unit",
    "\\denot{unit})$",
    "\\lst{for}$",
    "\\lst{to}$",
    "~\\lst{serialize(}$v_i$\\lst{)}$",
    "\\lst{end",
    "for}$",
    "\\lst{serialize}$",
    "function",
    "output",
    "invocation",
    "statement",
    "branch",
    "condition",
    "\\lst{if}$",
    "\\lst{serialize1(}$v_1$\\lst",
    "\\lst{else",
    "if}$$",
    "--todo",
    "lst--",
    "basis",
    "tree",
    "motivation",
    "encoding",
    "d.1](https://raw.githubusercontent.com",
    "scorexfoundation",
    "sigmastate",
    "interpreter/4daec63275fd4e1364cf7a1132f3e7be6157bb5c",
    "docs",
    "spec",
    "distribution",
    "code",
    "space",
    "interval",
    "\\lst{notype}$",
    "\\asdag$",
    "\\lst{0x01",
    "0x6f(111)}$",
    "option",
    "future",
    "\\lst{0x70(112",
    "\\lst{t1",
    "t2}$",
    "codes~\\footnote{note",
    "version",
    "protocol",
    "development",
    "types",
    "extension",
    "range",
    "embeddable",
    "|-|-|",
    "java.math",
    "biginteger",
    "groupelement",
    "org.bouncycastle.math.ec",
    "ecpoint",
    "sigmaprop",
    "char",
    "constructor",
    "0x01",
    "0x0b(11",
    "0x0c(12",
    "coll",
    "boolean",
    "0x0d(13",
    "0x17(23",
    "coll[byte",
    "coll[int",
    "coll[coll",
    "nested",
    "coll[coll[(int",
    "coll[coll[byte",
    "coll[coll[int",
    "option[(int",
    "0x2f(47",
    "option[int",
    "0x30(48",
    "option[coll",
    "option[coll[(int",
    "0x3b(59",
    "option[coll[int",
    "0x3c(60",
    "0x3d(61",
    "0x48(72",
    "triple",
    "quadruple",
    "0x55(85",
    "0x5f(95",
    "symmetric",
    "0x60(96",
    "tuple",
    "item",
    "avltree",
    "context",
    "string",
    "typevar",
    "header",
    "preheader",
    "0x6a(106",
    "global",
    "0x6b(107)-0x6e(110",
    "0x6f(111",
    "user",
    "schema",
    "base",
    "multiple",
    "example",
    "parameter",
    "coll[(byte",
    "descent",
    "operation",
    "domain",
    "total",
    "d\u221712+r+112",
    "index",
    "recursive",
    "argument",
    "child",
    "parent",
    "coll[(int",
    "emit",
    "comments",
    "|---|-|-|---|--|---|",
    "option[byte",
    "option[coll[byte",
    "int=>boolean",
    "int)=>int",
    "115=0",
    "box)=>boolean",
    "func",
    "runtime",
    "reification*](https://en.wikipedia.org",
    "wiki",
    "reification_(computer_science",
    "descriptor",
    "content",
    "object",
    "deserialize",
    "component",
    "leave",
    "figure",
    "--todo--",
    "org.bouncycastle.math.ec.custom.sec",
    "package",
    "point",
    "compression",
    "x9.62",
    "sigmaboolean.serializer",
    "avltreedata.serializer",
    "self",
    "serializer",
    "expressions",
    "utxo",
    "level",
    "interpretation",
    "meaning",
    "possibility",
    "forkability",
    "default",
    "behavior",
    "ergotreeserializer",
    "consistency",
    "inconsistency",
    "exception",
    "segregation",
    "constantplaceholder",
    "placeholder"
  ],
  "sections": [
    {
      "heading": "Serialization",
      "content": "This page defines the binary format used to store ErgoTree contracts in persistent stores, transfer them over the wire, and enable cross-platform interoperation."
    },
    {
      "heading": "Overview",
      "content": "The terms of the ErgoTree language can be serialized into an array of bytes for storage in the Ergo blockchain (e.g., in the propositionBytes field of a Box).\nWhen the guarding script of a transaction's input box is validated, the propositionBytes array is deserialized into an ErgoTree Intermediate Representation (IR) (represented by the ErgoTree class in the reference implementation), which can then be evaluated.\nThe serialization procedure is specified in general terms. The serialization format for ErgoTree types (specified by the SType class hierarchy) and expression nodes (specified by the Value class hierarchy) is defined in section 5.1 and Appendix C, respectively.\nTable 1 shows the size limits checked during contract deserialization, which are important for resisting malicious script attacks."
    },
    {
      "heading": "Table 1: Serialization limits",
      "content": "| Constant | Value | Description |\n|---|---|---|\n| VLQ  max  | 10 | Maximum size of VLQ encoded byte sequence (See VLQ formats E.1) |\n| T  max  | 100 | Maximum size of serialized type term (see Type format 5.1) |\n| D  max  | 4Kb | Maximum size of serialized data instance (see Data format 5.2) |\n| C  max  | = T  max  + D  max  | Maximum size of serialized data instance (see Const format 5.3) |\n| Expr  max  | 4Kb | Maximum size of serialized ErgoTree term (see Expr format 5.4) |\n| ErgoTree  max  | 4Kb | Maximum size of serialized ErgoTree contract (see ErgoTree format 5.5) |\nAll the serialization formats used and defined throughout this section are listed in Table 2, which introduces a name for each format and shows the number of bytes each format may occupy in the byte stream."
    },
    {
      "heading": "Table 2: Serialization formats",
      "content": "|   Format          | #bytes          | Description |\n|---|---|---|\n|   $\\lst{Byte}$    | $1$            | 8-bit signed two's-complement integer |\n|   $\\lst{Short}$ | $2$ | 16-bit signed two's-complement integer (big-endian) |\n|   $\\lst{Int}$ | $4$ | 32-bit signed two's-complement integer (big-endian) |\n|   $\\lst{Long}$ | $8$ | 64-bit signed two's-complement integer (big-endian) |\n|   $\\lst{UByte}$ | $1$ | 8-bit unsigned integer |\n|   $\\lst{UShort}$ | $2$ | 16-bit unsigned integer (big-endian) |\n|   $\\lst{UInt}$ | $4$ | 32-bit unsigned integer (big-endian) |\n|   $\\lst{ULong}$ | $8$ | 64-bit unsigned integer (big-endian) |\n|   $\\lst{VLQ(UShort)}$ | $[1..3]$ | Encoded unsigned $\\lst{Short}$ value using VLQ. |\n|   $\\lst{VLQ(UInt)}$ | $[1..5]$ | Encoded unsigned 32-bit integer using VLQ. |\n|   $\\lst{VLQ(ULong)}$ | $[1..\\MaxVlqSize]$ | Encoded unsigned 64-bit integer using VLQ. |\n|$\\lst{Bits}$ | $[1..\\MaxBits]$ | A collection of bits packed in a sequence of bytes. |\n|$\\lst{Bytes}$ | $[1..\\MaxBytes]$ | A sequence of bytes, whose size is stored elsewhere or well-known. |\n|$\\lst{Type}$ | $[1..\\MaxTypeSize]$ | Serialized type terms of $\\langname$. |\n|$\\lst{Data}$ | $[1..\\MaxDataSize]$ | Serialized data values of $\\langname$. |\n|$\\lst{GroupElement}$ | $33$ | Serialized elements of elliptic curve group. |\n|$\\lst{SigmaProp}$ | $[1..\\MaxSigmaProp]$ | Serialized sigma propositions. |\n|$\\lst{AvlTree}$ | $44$ | Serialized dynamic dictionary digest. |\n|$\\lst{Constant}$ | $[1..\\MaxConstSize]$ | Serialized $\\langname$ constants (values with types). |\n|$\\lst{Expr}$ | $[1..\\MaxExprSize]$ | Serialized expression terms of $\\langname$. |\n|$\\lst{ErgoTree}$ | $[1..\\MaxErgoTreeSize]$ | Serialized instances of $\\langname$ contracts. |\nWe use the [1..n] notation when serialization may produce from 1 to n bytes (depending on the actual data).\nThe serialization format of ErgoTree is optimized for compact storage and rapid deserialization.\nIn many cases, the serialization procedure is data depende..."
    },
    {
      "heading": "Table 3: Serialization Notation",
      "content": "|   Notation   | Description |\n|---|---|\n$\\Denot{T}$ where $T$ - type | Denotes a set of values of type $T$  |\n$v \\in \\Denot{T}$ | The value $v$ belongs to the set $\\Denot{T}$ |\n$v : T$ | Same as $v \\in \\Denot{T}$ |\n$\\lst{match}$ $(t, v)$ | Pattern match on pair $(t, v)$ where $t, v$ - values |\n$\\lst{with}$ $(Unit, v \\in \\Denot{Unit})$ | Pattern case |\n$\\lst{for}$ i=1 $\\lst{to}$ len \\ $~\\lst{serialize(}$v_i$\\lst{)}$ \\ $\\lst{end for}$ | Call the given $\\lst{serialize}$ function repeatedly. The output bytes of all invocations are concatenated and become the output of the $\\lst{for}$ statement. |\n$$\\lst{if}~$condition$~$\\lst{then}$ | Serialize one of the branches depending on the condition. The output bytes of the executed branch become the output of the $\\lst{if}$ statement. |\n$\\lst{serialize1(}$v_1$\\lst{)} |  \\lst{else} | ~~\\lst{serialize2(}$v_2$\\lst{)} | \\lst{end if}$$ |\nIn the next section, we describe how types (Int, Coll[Byte], etc.) are serialized; then, we define the serialization of typed data.\nThis will give us a basis to describe the serialization of Constant nodes of ErgoTree. After that, we will proceed to the serialization of arbitrary ErgoTree trees."
    },
    {
      "heading": "Type Serialization",
      "content": "For the motivation behind this type of encoding, please see Appendix D.1."
    },
    {
      "heading": "Distribution of type codes",
      "content": "The whole space of 256 one-byte codes is divided, as shown in Table 4."
    },
    {
      "heading": "Table 4: Distribution of type codes between Data and Function types",
      "content": "|   Value/Interval   | Distribution |\n|---|---|\n$\\lst{0x00}$ | special value to represent undefined type ($\\lst{NoType}$ in $\\ASDag$) |\n$\\lst{0x01 - 0x6F(111)}$ | data types including primitive types, arrays, options aka nullable types, classes (in future), 111 = 255 - 144 different codes |\n$\\lst{0x70(112) - 0xFF(255)}$ | function types $\\lst{T1 => T2}$, 144 = 12 x 12 different codes~\\footnote{Note that the function types are never serialized in version 1 of the Ergo protocol, this encoding is reserved for future development of the protocol.} |"
    },
    {
      "heading": "Encoding of Data Types",
      "content": "There are eight different values for embeddable types, and three more are reserved for future extensions. Each embeddable type has a type code in the range 1,...,11 as shown in Table 5."
    },
    {
      "heading": "Table 5: Embeddable Types",
      "content": "| Code | Type |\n|-|-|\n| 1 | Boolean |\n| 2 | Byte |\n| 3 | Short (16-bit) |\n| 4 | Int (32 bit) |\n| 5 | Long (64-bit) |\n| 6 | BigInt (represented by java.math.BigInteger) |\n| 7 | GroupElement (represented by org.bouncycastle.math.ec.ECPoint) |\n| 8 | SigmaProp |\n| 9 | reserved for Char |\n| 10 | reserved |\n| 11 | reserved |"
    },
    {
      "heading": "Table 6: Code Ranges of Data Types",
      "content": "| Interval | Constructor | Description |\n|---|---|---|\n| 0x01 - 0x0B(11) | | embeddable types (including 3 reserved) |\n| 0x0C(12) | Coll[] | | Collection of non-embeddable types (Coll[(Int,Boolean)]) |\n| 0x0D(13) - 0x17(23) | Coll[] | Collection of embeddable types (Coll[Byte], Coll[Int], etc.) |\n| 0x18(24) | Coll[Coll[]] | Nested collection of non-embeddable types (Coll[Coll[(Int,Boolean)]]) |\n| 0x19(25) - 0x23(35) | Coll[Coll[]] | Nested collection of embeddable types (Coll[Coll[Byte]], Coll[Coll[Int]]) |\n| 0x24(36) | Option[] | Option of non-embeddable type (Option[(Int, Byte)]) |\n| 0x25(37) - 0x2F(47) | Option[] | Option of embeddable type (Option[Int]) |\n| 0x30(48) | Option[Coll[]] | Option of Coll of non-embeddable type (Option[Coll[(Int, Boolean)]]) |\n| 0x31(49) - 0x3B(59) | Option[Coll[]] | Option of Coll of embeddable type (Option[Coll[Int]]) |\n| 0x3C(60) | (,) | Pair of non-embeddable types (((Int, Byte), (Boolean,Box)), etc.) |\n| 0x3D(61) - 0x47(71) | (, Int) | Pair of types where first is embeddable ((, Int)) |\n| 0x48(72) | (,,) | Triple of types |\n| 0x49(73) - 0x53(83) | (Int, ) | Pair of types where second is embeddable ((Int, )) |\n| 0x54(84) | (,,,) | Quadruple of types |\n| 0x55(85) - 0x5F(95) | (, ) | Symmetric pair of embeddable types ((Int, Int), (Byte,Byte), etc.) |\n| 0x60(96) | (,...,_) | Tuple type with more than 4 items (Int, Byte, Box, Boolean, Int) |\n| 0x61(97) |  Any | Any type |\n| 0x62(98) |  Unit | Unit type |\n| 0x63(99) |  Box | Box type |\n| 0x64(100) |  AvlTree | AvlTree type |\n| 0x65(101) |  Context | Context type |\n| 0x66(102) | | reserved for String |\n| 0x67(103) | | reserved for TypeVar |\n| 0x68(104) |  Header | Header type |\n| 0x69(105) |  PreHeader | PreHeader type |\n| 0x6A(106) |  Global | Global type |\n| 0x6B(107)-0x6E(110) | | reserved for future use |\n| 0x6F(111) | | Reserved for future Class type (e.g. user-defined types) |\nWe use the encoding schema defined below for each type constructor, like Coll or Option.\nA type construc..."
    },
    {
      "heading": "Encoding of Function Types",
      "content": "We use 12 different values for both domain and range types of functions.\nThis gives us 144 (12\u221712) function types in total and allows us to represent 121 (11\u221711) functions over primitive types using just a single byte.\nEach code F in the range of function types (i.e., F \u2208 {112, . . . , 255}) can be represented as F = D\u221712+R+112, where D, R \u2208 {0, . . . , 11} are the indices of domain and range types correspondingly, and 112 is the first code in the interval of function types.\nIf D = 0, the domain type is not embeddable, and recursive descent is necessary to write/read the domain type.\nIf R = 0, then the range type is not embeddable, and recursive descent is necessary to write/read the range type."
    },
    {
      "heading": "Recursive Descent",
      "content": "When an argument of a type constructor is not a primitive type, we fall back to the simple encoding schema. In this case, we emit the separate code for the type constructor according to the table above and descend recursively to every child node of the type tree.\nWe perform this descent only for those children whose code cannot be embedded in the parent code.\nFor example, serialization of Coll[(Int,Boolean)] proceeds as follows:\nEmit 0x0C because the element type of the collection is not embeddable.\nRecursively serialize (Int, Boolean).\nEmit 0x41(=0x3D+4) because the first type of the pair is embeddable, and its code is 4.\nRecursively serialize Boolean.\nEmit 0x02 - the code for the embeddable type Boolean.\nMore examples of type serialization are shown in Table 7.\n| Type | D | R | Serialized Bytes | #Bytes | Comments |\n|---|-|-|---|--|---|\n| Byte | | | 2 | 1 | simple embeddable type |\n| Coll[Byte] | | |  12 + 2 = 14 | 1 | embeddable type in Coll |\n| Coll[Coll[Byte]] | | |  24 + 2 = 26 | 1 | embeddable type in nested Coll |\n| Option[Byte] | | |  36 + 2 = 38 | 1 | embeddable type in Option |\n| Option[Coll[Byte]] | | |  48 + 2 = 50 | 1 | embeddable type in Coll nested in Option |\n| (Int,Int) | | |  84 + 4 = 88 | 1 | symmetric pair of embeddable type |\n| Int=>Boolean | 4 |1 |    161 = 412+1+112 | 1 | embeddable domain and range |\n| (Int,Int)=>Int | 0 |4|    115=012+4+112, 88 | 2 | embeddable range, then symmetric pair |\n| (Int,Boolean) | | |  60 + 4, 1 | 2 | Int embedded in pair, then Boolean |\n| (Int,Box)=>Boolean |0 |1 |    0*12+1+112, 60+4, 99 | 3 | func with embedded range, then Int embedded, then Box |"
    },
    {
      "heading": "Data Serialization",
      "content": "In ErgoTree, all runtime data values have an associated type also available at runtime (this is called type reification).\nHowever, the serialization format separates data values from their type descriptors. This saves space when, for example, a collection of items is serialized. This is done so that a type tree can fully describe the contents of a typed data structure.\nFor example, having a typed data object d: (Int, Coll[Byte], Boolean), we can tell, by examining the structure of the type, that d is a tuple with three items; the first item contains a 32-bit integer, the second a collection of bytes, and the third a logical true/false value.\nTo serialize/deserialize typed data, we need to know its type descriptor (type tree). The data serialization procedure is recursive over the type tree and the corresponding sub-components of the data object. For primitive types (the leaves of the type tree), the format is fixed. The data values of ErgoTree types are serialized according to the predefined recursive function shown in Figure 5, which uses the notation from Table 3.\nFigure 5: Data serialization format"
    },
    {
      "heading": "GroupElement serialization",
      "content": "A value of the GroupElement type is represented in the reference implementation using the SecP256K1Point class of the org.bouncycastle.math.ec.custom.sec package and serialized using ASN.1 encoding.\nDifferent encodings are considered during deserialization, including point compression for Fp (see X9.62 sec. 4.2.1 pg. 17).\nFigure 6: GroupElement serialization format"
    },
    {
      "heading": "SigmaProp serialization",
      "content": "In the reference implementation, values of the SigmaProp type are serialized using SigmaBoolean.serializer."
    },
    {
      "heading": "AvlTree serialization",
      "content": "In the reference implementation, values of the AvlTree type are serialized using AvlTreeData.serializer.\nFigure 8: AvlTree serialization format"
    },
    {
      "heading": "Constant Serialization",
      "content": "The Constant format is simple and self-sufficient to represent any data value. Serialized bytes in the Constant format contain both the type bytes and the data bytes; thus, they can be stored or transferred over the wire and then later unambiguously interpreted. The format is shown in Figure 9.\nFigure 9: Constant serialization format\nTo parse the Constant format, first, use the type serializer from section 5.1 and read the type. Then use the parsed type as an argument of the data serializer given in section 5.2."
    },
    {
      "heading": "Expression Serialization",
      "content": "Expressions of ErgoTree are serialized as tree data structures using the recursive procedure described in Figure 10. Expression nodes are represented in the reference implementation using the Value class hierarchy."
    },
    {
      "heading": "ErgoTree serialization",
      "content": "The ErgoTree propositions stored in UTXO boxes are represented in the reference implementation using the ErgoTree class. The class is serialized using the ErgoTree serialization format shown in Figure 11.\nFigure 11: ErgoTree serialization format\nSerialized instances of the ErgoTree class are self-sufficient and can be stored and passed around.\nThe ErgoTree format defines the top-level serialization format of ErgoTree scripts. The interpretation of the byte array depends on the first header byte(s), which use VLQ encoding (up to 30 bits are reserved). We currently define meaning only for the first byte, which may be extended in future versions. The meaning of the bits is shown in Figure 12.\nFigure 12: ErgoTree header bits\nCurrently, we don\u2019t specify interpretation for the second and other bytes of the header. We reserve the possibility to extend the header by using Bit 7 == 1 and chaining additional bytes as in VLQ.\nOnce new bytes are required, a new language version should be created and implemented via soft-forkability. That new language will give an interpretation for the new bytes.\nThe default behavior of ErgoTreeSerializer is to preserve the original structure of ErgoTree and check consistency. In case of any inconsistency, the serializer throws an exception.\nIf the constant segregation bit (Bit 4) is set to 1, then the constants collection contains the constants for which there may be ConstantPlaceholder nodes in the tree. However, if the constant segregation bit is 0, then the constants collection should be empty, and any placeholder in the tree will lead to an exception."
    }
  ],
  "qa_pairs": []
}