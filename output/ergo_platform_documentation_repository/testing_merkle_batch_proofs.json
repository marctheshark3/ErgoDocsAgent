{
  "title": "Testing Merkle Batch Proofs",
  "source_url": "docs/dev/data-model/structures/merkle/merkle-batch-testing.md",
  "summary": "---\ntags:\n  - Merkle\n---\n\n# Testing Merkle Batch Proofs\n\nTesting Merkle Batch Proofs is crucial to ensure the correctness of their implementation in the Ergo blockchain. This section provides examples of how to write tests for Merkle Batch Proofs using both Rust (`sigma-rust`) and Scala (`scrypto`). These tests cover the creation, verification, serialization, and deserialization of batch Merkle proofs. ### Rust (`sigma-rust`) Testing\n\nIn Rust, the `sigma-rust` library provides the necessary tools to create and test Merkle Batch Proofs. Below is a series of tests written using the Rust testing framework.",
  "keywords": [
    "merkle",
    "batch",
    "proof",
    "testing",
    "proofs",
    "correctness",
    "implementation",
    "ergo",
    "blockchain",
    "section",
    "example",
    "test",
    "rust",
    "sigma",
    "scala",
    "creation",
    "verification",
    "serialization",
    "deserialization",
    "library",
    "tool",
    "below",
    "series",
    "framework",
    "cfg(test",
    "sigma_merkle_tree::merklenode",
    "blake2::blake2b256",
    "test_merkle_tree_creation",
    "data_2",
    "node_1",
    "merklenode::from_bytes(data_1",
    "node_2",
    "merklenode::from_bytes(data_2",
    "merklenode::from_bytes(data_3",
    "tree",
    "merkletree::new(vec![node_1",
    "node_3",
    "root",
    "hash",
    "test_batch_merkle_proof_generation",
    "tree.proof_by_indices(&[0",
    "index",
    "test_batch_merkle_proof_verification",
    "test_batch_merkle_proof_serialization_deserialization",
    "serialized_proof",
    "proof.scorex_serialize_bytes().unwrap",
    "deserialized_proof",
    "batchmerkleproof::scorex_parse_bytes(&serialized_proof).unwrap",
    "assert_eq!(proof",
    "code",
    "references",
    "merkletree.rs`](https://github.com",
    "ergoplatform",
    "blob",
    "develop",
    "merkletree.rs",
    "batchmerkleproof",
    "batchmerkleproof.rs`](https://github.com",
    "methods",
    "scorex_serializable.rs",
    "case",
    "scalatest",
    "generation",
    "import",
    "org.scalatest.flatspec",
    "anyflatspec",
    "org.scalatest.matchers.should",
    "matcher",
    "scorex.crypto.authds.merkle.{merkletree",
    "scorex.crypto.authds.merkle.serialization",
    "scorex.crypto.hash.{blake2b256",
    "digest32",
    "scorex.util",
    "random",
    "class",
    "merklebatchproofspec",
    "matchers",
    "blake2b256",
    "leaf",
    "data",
    "tree.roothash",
    "tree.proofbyindices(seq(0",
    "generate",
    "element",
    "proof.indices.length",
    "serializer",
    "batchmerkleproofserializer[digest32",
    "blake2b256.type",
    "serializedproof",
    "deserializedproof",
    "serializer.deserialize(serializedproof).get",
    "merkletree.scala`](https://github.com",
    "input",
    "output",
    "scrypto",
    "master",
    "scorex",
    "crypto",
    "authds",
    "merkletree.scala",
    "batchmerkleproof.scala`](https://github.com",
    "batchmerkleproof.scala",
    "batchmerkleproofserializer.scala`](https://github.com",
    "batchmerkleproofserializer.scala",
    "explanation",
    "datum",
    "merkletree",
    "validity",
    "inclusion",
    "ability",
    "form",
    "integrity",
    "operation",
    "functionality",
    "developer",
    "confidence",
    "application"
  ],
  "sections": [
    {
      "heading": "Testing Merkle Batch Proofs",
      "content": "Testing Merkle Batch Proofs is crucial to ensure the correctness of their implementation in the Ergo blockchain. This section provides examples of how to write tests for Merkle Batch Proofs using both Rust (sigma-rust) and Scala (scrypto). These tests cover the creation, verification, serialization, and deserialization of batch Merkle proofs."
    },
    {
      "heading": "Rust (sigma-rust) Testing",
      "content": "In Rust, the sigma-rust library provides the necessary tools to create and test Merkle Batch Proofs. Below is a series of tests written using the Rust testing framework.\n```rust"
    },
    {
      "heading": "[cfg(test)]",
      "content": "mod tests {\n    use sigma_merkle_tree::merkletree::MerkleTree;\n    use sigma_merkle_tree::MerkleNode;\n    use sigma_merkle_tree::batchmerkleproof::BatchMerkleProof;\n    use sigma_ser::ScorexSerializable;\n    use blake2::Blake2b256;\n#[test]\nfn test_merkle_tree_creation() {\n    let data_1 = [1u8; 32];\n    let data_2 = [2u8; 32];\n    let data_3 = [3u8; 32];\n\n    let node_1 = MerkleNode::from_bytes(data_1);\n    let node_2 = MerkleNode::from_bytes(data_2);\n    let node_3 = MerkleNode::from_bytes(data_3);\n\n    let tree = MerkleTree::new(vec![node_1, node_2, node_3]);\n    assert!(tree.root_hash().is_some(), \"Merkle tree root hash should be generated\");\n}\n\n#[test]\nfn test_batch_merkle_proof_generation() {\n    let data_1 = [1u8; 32];\n    let data_2 = [2u8; 32];\n    let data_3 = [3u8; 32];\n\n    let node_1 = MerkleNode::from_bytes(data_1);\n    let node_2 = MerkleNode::from_bytes(data_2);\n    let node_3 = MerkleNode::from_bytes(data_3);\n\n    let tree = MerkleTree::new(vec![node_1, node_2, node_3]);\n    let proof = tree.proof_by_indices(&[0, 2]).unwrap();\n\n    assert_eq!(proof.indices.len(), 2, \"Batch proof should include two indices\");\n}\n\n#[test]\nfn test_batch_merkle_proof_verification() {\n    let data_1 = [1u8; 32];\n    let data_2 = [2u8; 32];\n    let data_3 = [3u8; 32];\n\n    let node_1 = MerkleNode::from_bytes(data_1);\n    let node_2 = MerkleNode::from_bytes(data_2);\n    let node_3 = MerkleNode::from_bytes(data_3);\n\n    let tree = MerkleTree::new(vec![node_1, node_2, node_3]);\n    let proof = tree.proof_by_indices(&[0, 2]).unwrap();\n\n    assert!(proof.valid(tree.root_hash().as_ref()), \"Merkle proof should be valid\");\n}\n\n#[test]\nfn test_batch_merkle_proof_serialization_deserialization() {\n    let data_1 = [1u8; 32];\n    let data_2 = [2u8; 32];\n    let data_3 = [3u8; 32];\n\n    let node_1 = MerkleNode::from_bytes(data_1);\n    let node_2 = MerkleNode::from_bytes(data_2);\n    let node_3 = MerkleNode::from_bytes(data_3);\n\n    let tree = MerkleTree::new(vec![node_1, node_2, node_3])..."
    },
    {
      "heading": "Code References",
      "content": "MerkleTree: merkletree.rs\nBatchMerkleProof: batchmerkleproof.rs\nSerialization Methods: scorex_serializable.rs"
    },
    {
      "heading": "Scala (scrypto) Testing",
      "content": "For Scala, the scrypto library is used to test Merkle Batch Proofs. Below are the test cases using ScalaTest, covering tree creation, proof generation, verification, and serialization.\n```scala\nimport org.scalatest.flatspec.AnyFlatSpec\nimport org.scalatest.matchers.should.Matchers\nimport scorex.crypto.authds.merkle.{MerkleTree, BatchMerkleProof}\nimport scorex.crypto.authds.merkle.serialization.BatchMerkleProofSerializer\nimport scorex.crypto.hash.{Blake2b256, Digest32}\nimport scorex.utils.Random\nclass MerkleBatchProofSpec extends AnyFlatSpec with Matchers {\n  implicit val hf = Blake2b256\n\"Merkle Tree\" should \"be created correctly\" in {\n    val leafData = Seq.fill(3)(Random.randomBytes(32)) // Generate random leaf data\n    val tree = MerkleTree(leafData.map(Digest32 @@ _)) // Create a Merkle Tree\ntree.rootHash should not be null\n}\n\"Batch Merkle Proof\" should \"be generated correctly\" in {\n    val leafData = Seq.fill(3)(Random.randomBytes(32)) // Generate random leaf data\n    val tree = MerkleTree(leafData.map(Digest32 @@ _)) // Create a Merkle Tree\nval proof = tree.proofByIndices(Seq(0, 2)).get // Generate batch proof for elements at index 0 and 2\nproof.indices.length shouldEqual 2\n}\nit should \"verify correctly\" in {\n    val leafData = Seq.fill(3)(Random.randomBytes(32)) // Generate random leaf data\n    val tree = MerkleTree(leafData.map(Digest32 @@ _)) // Create a Merkle Tree\nval proof = tree.proofByIndices(Seq(0, 2)).get // Generate batch proof for elements at index 0 and 2\nproof.valid(tree.rootHash) shouldBe true // Verify the proof against the tree's root hash\n}\nit should \"serialize and deserialize correctly\" in {\n    val leafData = Seq.fill(3)(Random.randomBytes(32)) // Generate random leaf data\n    val tree = MerkleTree(leafData.map(Digest32 @@ _)) // Create a Merkle Tree\nval proof = tree.proofByIndices(Seq(0, 2)).get // Generate batch proof for elements at index 0 and 2\nval serializer = new BatchMerkleProofSerializer[Digest32, Blake2b256.type] // Serializer for ..."
    },
    {
      "heading": "Code References",
      "content": "MerkleTree: MerkleTree.scala\nBatchMerkleProof: BatchMerkleProof.scala\nBatchMerkleProofSerializer: BatchMerkleProofSerializer.scala"
    },
    {
      "heading": "Explanation:",
      "content": "Merkle Tree Creation: The test generates random leaf data and creates a MerkleTree. This ensures that the tree is correctly constructed and the root hash is generated.\nBatch Merkle Proof Generation: The test creates a batch proof for selected elements (indices 0 and 2) of the Merkle Tree.\nProof Verification: The test verifies the validity of the generated batch proof against the Merkle root, ensuring the proof correctly represents the inclusion of those elements in the tree.\nSerialization and Deserialization: The test checks the ability to serialize a batch proof, then deserialize it back to its original form, confirming the integrity of the proof after these operations.\nThese tests collectively ensure that the core functionality of Merkle Batch Proofs in scrypto operates correctly, providing developers with confidence in using this library for cryptographic proofs in their applications."
    }
  ],
  "qa_pairs": []
}