{
  "title": "Plasma",
  "source_url": "docs/dev/lib/plasma.md",
  "summary": "---\ntags:\n  - Plasma\n  - AVL Trees\n  - Layer 2\n  - Library\n  - GetBlok\n---\n\n# Plasma\n\n[GetBlok Plasma](https://github.com/GetBlok-io/GetBlok-Plasma) is a library on top of Ergo [Appkit](appkit.md) that provides an abstraction layer to simplify the process of integrating AVL Trees (AKA Plasma) into off-chain code. The goal is to give developers an easy way to use this Layer-2 scaling solution in contracts, off-chain code, and distributed systems managing the Plasma itself. GetBlok Plasma uses the default versioned storage implementation powered by LevelDB, with another SwayDB implementation in the works. **This allows for distributed systems to keep track of the key-value pairs held in digests stored on-chain.",
  "keywords": [
    "plasma",
    "trees",
    "layer",
    "library",
    "getblok",
    "plasma](https://github.com",
    "ergo",
    "abstraction",
    "process",
    "chain",
    "code",
    "goal",
    "developer",
    "layer-2",
    "scale",
    "solution",
    "contract",
    "system",
    "default",
    "storage",
    "implementation",
    "leveldb",
    "swaydb",
    "work",
    "track",
    "value",
    "pair",
    "digest",
    "document",
    "ergoscript",
    "basic",
    "tips",
    "design",
    "patterns](https://github.com",
    "blob",
    "master",
    "avl_trees",
    "mining",
    "pool",
    "2](https://github.com",
    "smartpool_plasma",
    "detail",
    "tree",
    "maps",
    "scala",
    "surface",
    "change",
    "import",
    "io.getblok.getblok_plasma",
    "plasmaparameter",
    "io.getblok.getblok_plasma.collection",
    "plasmamap",
    "ergoid",
    "sigmastate.{avltreeflags",
    "ergotrees",
    "plasmamap[ergoid",
    "values",
    "ergotree](avltreeflags",
    "plasmaparameters.default",
    "byte",
    "blake2b256",
    "hashing",
    "class",
    "implicit",
    "byteconversion",
    "sigmastate",
    "byteconversions",
    "ergotree",
    "convertsid",
    "byteconversion[ergoid",
    "override",
    "converttobytes(t",
    "array[byte",
    "t.getbyte",
    "convertfrombytes(byte",
    "ergoid(byte",
    "convertsergotree",
    "byteconversion[value",
    "t.byte",
    "ergotreeserializer",
    "defaultserializer.deserializeergotree(byte",
    "custom",
    "definition",
    "flexibility",
    "com.google.common.primitives.{int",
    "long",
    "org.bouncycastle.util.encoders",
    "org.ergoplatform.appkit.{ergotype",
    "ergovalue",
    "sigmastate.eval",
    "coll",
    "special.collection",
    "case",
    "statescore(score",
    "boolean",
    "tobyte",
    "longs.tobytearray(score",
    "getpaid(byte",
    "match",
    "exception(\"a",
    "payment",
    "byteconversion[statescore",
    "statescore",
    "t.tobyte",
    "statescore(longs.frombytearray(bytes.slice(0",
    "getpaid(bytes.slice(8",
    "operation",
    "opresult",
    "field",
    "opresult`s",
    "provenresult",
    "proof",
    "object",
    "order",
    "plasmaparameters",
    "io.getblok.getblok_plasma.collections.{opresult",
    "byteconversion.convertslongval",
    "avltreeflag",
    "tokenmap",
    "long](avltreeflags",
    "cometid",
    "ergoid.create(\"0cd8c9f416e5b1ca9f986a7f10a84191dfb85941619e49e53c0dc30ebf83324b",
    "tokendata",
    "seq[(ergoid",
    "seq(cometid",
    "100l",
    "result",
    "provenresult[long",
    "tokenmap.insert(tokendata",
    "result.response",
    "result.proof",
    "function",
    "type",
    "appkit",
    "interaction",
    "org.ergoplatform.appkit.{ergoclient",
    "ergocontract",
    "parameters",
    "ergoclient",
    "mycontract",
    "mymap",
    "myproof",
    "ergoclient.execute",
    "outb",
    "txb.outboxbuilder",
    "outbox",
    ".value(parameters",
    ".contract(mycontract",
    ".registers(mymap.ergovalue",
    "myproof.ergovalue",
    "localplasmamap",
    "scorex.crypto.authds.avltree.batch",
    "versionedldbavlstorage",
    "scorex.crypto.hash.{blake2b256",
    "digest32",
    "ldbversionedstore",
    "ldbstore",
    "ldbversionedstore(new",
    "file(\"./level",
    "avlstorage",
    "versionedldbavlstorage[digest32](ldbstore",
    "plasmaparameters.default.tonodeparams)(blake2b256",
    "localmap",
    "localplasmamap[long",
    "ergotree](avlstorage",
    "avltreeflags",
    "proxyplasmamap",
    "context",
    "transaction",
    "error",
    "example",
    "latency",
    "connection",
    "node",
    "problem",
    "none",
    "commitchange",
    "queue",
    "queued",
    "io.getblok.getblok_plasma.collections.{localplasmamap",
    "proxymap",
    "long](avlstorage",
    "ergopadid",
    "tokendataergopad",
    "seq(ergopadid",
    "proxymap.insert(tokendataergopad",
    "initiate",
    "proxymap.initiate",
    "application",
    "persistence",
    "proxymap.commitchange",
    "tokendatacomet",
    "proxymap.insert(tokendatacomet",
    "proxymap.commitnextoperation",
    "proxymap.dropchange",
    "resource",
    "bank",
    "2](https://www.ergoforum.org",
    "offchain",
    "layer-2/3367",
    "smartpool",
    "paideia",
    "staking](https://github.com",
    "paideia_contract"
  ],
  "sections": [
    {
      "heading": "Plasma",
      "content": "GetBlok Plasma is a library on top of Ergo Appkit that provides an abstraction layer to simplify the process of integrating AVL Trees (AKA Plasma) into off-chain code. The goal is to give developers an easy way to use this Layer-2 scaling solution in contracts, off-chain code, and distributed systems managing the Plasma itself. GetBlok Plasma uses the default versioned storage implementation powered by LevelDB, with another SwayDB implementation in the works. This allows for distributed systems to keep track of the key-value pairs held in digests stored on-chain.\nSee these documents to get started;\nAVL Trees / Plasma In ErgoScript: Basics, Tips, and Design Patterns\nMining Pool Operating At Layer 2"
    },
    {
      "heading": "Details",
      "content": "Creating and managing AVL Trees is greatly simplified when using the library. To create a normal,\nun-stored / temporary AVL Tree, we use Plasma Maps. Plasma Maps look similar to normal Scala maps on the surface\nwith a few changes that make them compatible with on-chain AVL Trees.\nscala\nimport io.getblok.getblok_plasma.PlasmaParameters\nimport io.getblok.getblok_plasma.collections.PlasmaMap\nimport org.ergoplatform.appkit.ErgoId\nimport sigmastate.{AvlTreeFlags, Values}\n// Plasma Map that uses ErgoId's as keys, and ErgoTrees as values\nval plasmaMap = new PlasmaMap[ErgoId, Values.ErgoTree](AvlTreeFlags.AllOperationsAllowed, PlasmaParameters.default)\nAll Plasma Maps use 32 byte digests and Blake2b256 hashing. Any class may be inserted into a Plasma Map\nso long as there is a corresponding implicit ByteConversion for that class.\n```scala\nimport io.getblok.getblok_plasma.ByteConversion\nimport org.ergoplatform.appkit.ErgoId\nimport sigmastate.Values\nimport sigmastate.serialization.ErgoTreeSerializer\n// Default ByteConversions for ErgoId and ErgoTree\nimplicit val convertsId: ByteConversion[ErgoId] = new ByteConversion[ErgoId] {\n  override def convertToBytes(t: ErgoId): Array[Byte] = t.getBytes\noverride def convertFromBytes(bytes: Array[Byte]): ErgoId = new ErgoId(bytes)\n}\nimplicit val convertsErgoTree: ByteConversion[Values.ErgoTree] = new ByteConversion[Values.ErgoTree] {\n  override def convertToBytes(t: Values.ErgoTree): Array[Byte] = t.bytes\noverride def convertFromBytes(bytes: Array[Byte]): Values.ErgoTree = ErgoTreeSerializer.DefaultSerializer.deserializeErgoTree(bytes)\n}\n```\nCustom classes may also be used with their own definitions to allow for flexibility in contracts:\n```scala\nimport com.google.common.primitives.{Ints, Longs}\nimport io.getblok.getblok_plasma.ByteConversion\nimport org.bouncycastle.util.encoders.Hex\nimport org.ergoplatform.appkit.{ErgoType, ErgoValue}\nimport sigmastate.eval.Colls\nimport special.collection.Coll\ncase class StateScore(score: Long, paid: Boo..."
    },
    {
      "heading": "LocalPlasmaMap",
      "content": "Interacting with a locally stored Plasma Map is done in a similar way, except that you must use the\nLocalPlasmaMap class instead.\n```scala\nimport io.getblok.getblok_plasma.PlasmaParameters\nimport io.getblok.getblok_plasma.collections.LocalPlasmaMap\nimport io.getblok.getblok_plasma.ByteConversion.convertsLongKey\nimport scorex.crypto.authds.avltree.batch.VersionedLDBAVLStorage\nimport scorex.crypto.hash.{Blake2b256, Digest32}\nimport scorex.db.LDBVersionedStore\nimport sigmastate.{AvlTreeFlags, Values}\nimport java.io.File\nval ldbStore = new LDBVersionedStore(new File(\"./level\"), 10)\nval avlStorage = new VersionedLDBAVLStorageDigest32(Blake2b256)\nval localMap = new LocalPlasmaMapLong, Values.ErgoTree\n```"
    },
    {
      "heading": "ProxyPlasmaMap",
      "content": "It can be useful to apply changes to a tree without necessarily committing to them. This is especially\ntrue in the context of chained transactions or unexpected errors. For example, if changes are applied to the\ntree but latency causes connection to the node to be lost, then the locally stored tree may have changes\nthat do not exist on-chain!\nTo deal with this problem, you can use a ProxyPlasmaMap. This PlasmaMap applies changes on a temporary\ntree which allows you to receive proofs for the operations you perform. However, none of these changes\nare saved to storage until the commitChanges() function is called. This ensures that unexpected errors\ncan be dealt with easily.\nWhen dealing with the ProxyPlasmaMap, changes must first be explicitly enabled by calling\ninitiate(). This function initializes the internal temporary map. Following this, operations\nmay be performed on the map. All operations are applied to the temporary map, but are also kept\ntrack of inside an internal Queue. Once commitChanges() is called, the Queued operations are applied\nto persistent storage, and the temporary map is destroyed.\n```scala\nimport io.getblok.getblok_plasma.PlasmaParameters\nimport io.getblok.getblok_plasma.collections.{LocalPlasmaMap, ProxyPlasmaMap}\nimport org.ergoplatform.appkit.ErgoId\nimport scorex.crypto.authds.avltree.batch.VersionedLDBAVLStorage\nimport scorex.crypto.hash.{Blake2b256, Digest32}\nimport scorex.db.LDBVersionedStore\nimport sigmastate.{AvlTreeFlags, Values}\nimport io.getblok.getblok_plasma.ByteConversion.convertsLongVal\nimport java.io.File\nval ldbStore = new LDBVersionedStore(new File(\"./level\"), 10)\nval avlStorage = new VersionedLDBAVLStorageDigest32(Blake2b256)\nval proxyMap = new ProxyPlasmaMapErgoId, Long\nval ergopadId: ErgoId = ErgoId.create(\"d71693c49a84fbbecd4908c94813b46514b18b67a99952dc1e6e4791556de413\")\nval tokenDataErgoPad: Seq[(ErgoId, Long)] = Seq(ergopadId -> 100L)\n// This will fail due to the ProxyMap being un-initiated\nproxyMap.insert(tokenDataErgoP..."
    },
    {
      "heading": "Resources",
      "content": "Plasma Example: Off-chain Bank operating at Layer 2\nGetBlok Plasma\nGetBlok: SmartPool Plasma\nPaideia - Plasma Staking"
    }
  ],
  "qa_pairs": []
}