{
  "title": "Signature Scheme Internals on Ergo",
  "source_url": "docs/sig-scheme.md",
  "summary": "---\ntags:\n  - Signature Schemes\n---\n\n\n# Signature Scheme Internals on Ergo\n\nThis document provides an in-depth look at the signature schemes used in the Ergo blockchain. The security and functionality of transactions on the Ergo platform heavily rely on cryptographic signatures, which ensure that only authorized parties can approve transactions and that the data integrity is maintained. This document outlines the internal workings of these signature schemes, focusing on the algorithms, protocols, and their implementation within the Ergo ecosystem, particularly within the [`sigmastate-interpreter`](https://github.com/ScorexFoundation/sigmastate-interpreter) and [`sigma-rust`](https://github.com/ergoplatform/sigma-rust) repositories. ## Overview\n\nIn the Ergo blockchain, signature schemes are used to validate that a transaction was indeed created by the owner of the associated private key. This is crucial for preventing unauthorized spending of funds and ensuring the security of smart contracts.",
  "keywords": [
    "signature",
    "scheme",
    "internals",
    "ergo",
    "document",
    "depth",
    "look",
    "blockchain",
    "security",
    "functionality",
    "transaction",
    "platform",
    "party",
    "datum",
    "integrity",
    "working",
    "algorithm",
    "protocol",
    "implementation",
    "ecosystem",
    "sigmastate",
    "interpreter`](https://github.com",
    "scorexfoundation",
    "interpreter",
    "sigma",
    "rust`](https://github.com",
    "ergoplatform",
    "rust",
    "repository",
    "overview",
    "owner",
    "spending",
    "fund",
    "contract",
    "schnorr",
    "focus",
    "scala",
    "ergotree",
    "interpretation",
    "verification",
    "primitive",
    "wasm",
    "application",
    "signatures",
    "part",
    "toolkit",
    "simplicity",
    "efficiency",
    "advantage",
    "ecdsa",
    "elliptic",
    "curve",
    "digital",
    "work",
    "generation",
    "user",
    "number",
    "generator",
    "point",
    "secret_key.rs`](https://github.com",
    "blob",
    "develop",
    "wallet",
    "secret_key.rs",
    "file",
    "management",
    "place",
    "signing",
    "message",
    "nonce",
    "process",
    "signing.rs`](https://github.com",
    "dlogprotocol`](https://github.com",
    "dlogprotocol.scala",
    "verifier",
    "compute",
    "check",
    "logic",
    "dlogprotocol.scala`](https://github.com",
    "crypto",
    "assumption",
    "hardness",
    "logarithm",
    "problem",
    "overhead",
    "batch",
    "protocols",
    "class",
    "prover",
    "value",
    "statement",
    "privacy",
    "feature",
    "components",
    "commitment",
    "challenge",
    "response",
    "knowledge",
    "secret",
    "function",
    "sigmapropprover`](https://github.com",
    "sigmapropprover.scala",
    "creation",
    "validation",
    "mechanism",
    "prover_result.rs`](https://github.com",
    "chain",
    "input",
    "prover_result.rs",
    "proof",
    "construction",
    "schemes",
    "core",
    "framework",
    "language",
    "condition",
    "version",
    "utxo",
    "integration",
    "complex",
    "conditions",
    "time",
    "lock",
    "multi",
    "support",
    "script",
    "requirement",
    "role",
    "ergolikeinterpreter`](https://github.com",
    "ergolikeinterpreter.scala",
    "ergotrees",
    "contract.rs`](https://github.com",
    "contract.rs",
    "layer",
    "flexibility",
    "execution",
    "sigserializer.scala",
    "serialization",
    "deserialization",
    "environment",
    "operation",
    "considerations",
    "developer",
    "pitfall",
    "randomness",
    "consideration",
    "test",
    "signingspecification`](https://github.com",
    "signingspecification.scala",
    "cases",
    "applications",
    "range",
    "confidential",
    "transactions",
    "information",
    "wallets",
    "voting",
    "system",
    "anonymity",
    "voter",
    "result",
    "smart",
    "contracts",
    "conclusion",
    "foundation",
    "detail",
    "ergoscript"
  ],
  "sections": [
    {
      "heading": "Signature Scheme Internals on Ergo",
      "content": "This document provides an in-depth look at the signature schemes used in the Ergo blockchain. The security and functionality of transactions on the Ergo platform heavily rely on cryptographic signatures, which ensure that only authorized parties can approve transactions and that the data integrity is maintained. This document outlines the internal workings of these signature schemes, focusing on the algorithms, protocols, and their implementation within the Ergo ecosystem, particularly within the sigmastate-interpreter and sigma-rust repositories."
    },
    {
      "heading": "Overview",
      "content": "In the Ergo blockchain, signature schemes are used to validate that a transaction was indeed created by the owner of the associated private key. This is crucial for preventing unauthorized spending of funds and ensuring the security of smart contracts. Ergo uses several cryptographic protocols to achieve this, including Schnorr signatures and Sigma protocols.\nThe implementation of these cryptographic protocols is spread across two main repositories:\nsigmastate-interpreter: Focuses on Scala-based ErgoTree interpretation and verification.\nsigma-rust: Provides a Rust-based implementation of the cryptographic primitives, enabling WASM and other Rust-native applications."
    },
    {
      "heading": "1. Schnorr Signatures",
      "content": "Schnorr Signatures are a fundamental part of Ergo\u2019s cryptographic toolkit. They are known for their simplicity, efficiency, and security, offering several advantages over other signature schemes such as ECDSA (Elliptic Curve Digital Signature Algorithm)."
    },
    {
      "heading": "How Schnorr Signatures Work:",
      "content": "Key Generation: \nA user generates a private key ( x ) (a random number) and computes the corresponding public key ( P = xG ), where ( G ) is a generator point on the elliptic curve used by Ergo.\nIn the Rust implementation, key generation is handled within the secret_key.rs file, where cryptographic key management and generation take place.\n\n\nSigning: \nTo sign a message ( m ), the user generates a random nonce ( k ) and computes ( R = kG ). The signature ( (s, e) ) is then computed as:\n  [\n  e = H(R || P || m)\n  ]\n  [\n  s = k + ex\n  ]\nThe Schnorr signing process is implemented in signing.rs within the sigma-rust repository, and in the Scala-based DLogProtocol file within the sigmastate-interpreter.\n\n\nVerification: \nTo verify the signature ( (s, e) ), the verifier computes:\n  [\n  R' = sG - eP\n  ]\n  and checks if:\n  [\n  e = H(R' || P || m)\n  ]\nThe verification logic is implemented in the same files: signing.rs for Rust and DLogProtocol.scala for Scala."
    },
    {
      "heading": "Advantages of Schnorr Signatures:",
      "content": "Security: Schnorr signatures are provably secure under the assumption of the hardness of the discrete logarithm problem.\nEfficiency: They produce smaller signatures and require less computational overhead than many other signature schemes.\nSimplicity: The signing and verification processes are straightforward, making them easy to implement and verify.\nBatch Verification: Multiple signatures can be verified simultaneously, which is particularly useful in blockchain applications where numerous transactions need to be validated quickly."
    },
    {
      "heading": "2. Sigma Protocols",
      "content": "Sigma Protocols are a class of cryptographic protocols that allow a prover to convince a verifier that they know a value ( x ) such that a statement about ( x ) is true, without revealing ( x ) itself. Ergo heavily relies on Sigma protocols for its privacy-preserving features and complex smart contracts."
    },
    {
      "heading": "Key Components of Sigma Protocols:",
      "content": "Commitment: The prover sends a commitment to the verifier without revealing the secret value.\nChallenge: The verifier sends a random challenge to the prover.\nResponse: The prover responds in a way that proves the knowledge of the secret while maintaining its privacy.\nThe Sigma protocol is implemented in both the sigmastate-interpreter and sigma-rust repositories:\nIn Scala, the Sigma protocol's cryptographic functions are handled by the SigmaPropProver class, which provides proof creation and validation mechanisms.\nIn Rust, the proof generation and verification can be found in prover_result.rs, which handles proof construction during transactions."
    },
    {
      "heading": "3. ErgoTree and Signature Schemes",
      "content": "ErgoTree is the core of Ergo's smart contract framework. It is a versatile and expressive language that uses Sigma protocols and Schnorr signatures to create conditions for spending boxes (Ergo's version of UTXOs)."
    },
    {
      "heading": "Signature Scheme Integration in ErgoTree:",
      "content": "Complex Spending Conditions: ErgoTree allows users to define sophisticated spending conditions that can include multiple signatures, time-based locks, and other cryptographic conditions.\nMulti-Signature Support: ErgoTree natively supports multi-signature schemes, allowing multiple parties to authorize a transaction.\nScript Validation: During transaction validation, the ErgoTree interpreter evaluates the conditions defined in the script, ensuring that the signatures match the requirements before the transaction is considered valid.\nThe Scala-based sigmastate-interpreter plays a crucial role in interpreting ErgoTree scripts:\nThe ErgoLikeInterpreter file in sigmastate-interpreter provides the main ErgoTree validation logic, where both Schnorr and Sigma signatures are verified.\nIn Rust, the validation and interpretation of ErgoTrees are found in the contract.rs file, which handles contract conditions and their associated proofs."
    },
    {
      "heading": "4. Implementation in Ergo",
      "content": "The signature schemes are implemented across different layers of the Ergo protocol, ensuring both security and flexibility in how transactions are constructed and validated.\nsigmastate-interpreter: Implements the core cryptographic primitives, including Schnorr signatures and Sigma protocols, within the Scala-based ErgoTree interpreter. This includes the construction, validation, and execution of ErgoTree scripts.\nThe ErgoLikeInterpreter provides the core verification logic for ErgoTrees.\nThe SigSerializer manages serialization and deserialization of proofs.\nThe DLogProtocol handles Sigma protocol proof construction based on discrete logarithms.\nsigma-rust: Provides a Rust-based implementation of the same cryptographic features, allowing for integration into Rust-based environments and cross-platform applications via WASM.\nsigning.rs handles Schnorr signature operations.\nprover_result.rs deals with Sigma proofs and transactions."
    },
    {
      "heading": "5. Security Considerations",
      "content": "The security of Ergo\u2019s signature schemes is rooted in well-established cryptographic assumptions, such as the hardness of the discrete logarithm problem for Schnorr signatures. However, the security of these schemes also depends on correct implementation and proper use in scripts. Developers and users must ensure that their ErgoTree scripts are designed to avoid common pitfalls, such as using weak randomness or failing to verify critical conditions.\nIn particular, the sigmastate-interpreter ensures that security\nconsiderations are rigorously handled through comprehensive tests, such as those found in the SigningSpecification."
    },
    {
      "heading": "6. Use Cases and Applications",
      "content": "Ergo's signature schemes enable a wide range of applications within the blockchain ecosystem, including:\nConfidential Transactions: Leveraging Sigma protocols for privacy-preserving transactions that do not reveal sensitive information.\nMulti-Signature Wallets: Creating wallets that require multiple signatures to authorize a transaction, increasing security.\nDecentralized Voting: Implementing voting systems where the anonymity of voters is preserved while ensuring the integrity of the results.\nSmart Contracts: Developing complex smart contracts that require advanced cryptographic conditions for execution."
    },
    {
      "heading": "Conclusion",
      "content": "Ergo\u2019s signature schemes, built on robust cryptographic foundations like Schnorr signatures and Sigma protocols, are central to the platform\u2019s security and functionality. These schemes are implemented across both the sigmastate-interpreter and sigma-rust repositories, which handle the cryptographic primitives, serialization, verification, and execution of ErgoTree scripts. This allows for flexible, secure, and privacy-preserving transactions, making Ergo a powerful platform for decentralized applications and digital contracts.\nFor more information and technical details, refer to the ErgoScript documentation and the sigma-rust repository."
    }
  ],
  "qa_pairs": []
}