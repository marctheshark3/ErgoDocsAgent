{
  "title": "Cryptographic",
  "source_url": "docs/crypto.md",
  "summary": "---\ntags:\n  - Sigma Protocols\n---\n\n$$\n\\newcommand{\\lst}[1]{#1}\n\\newcommand{\\Tup}[1]{(#1)}\n\\newcommand{\\Apply}[2]{#1\\langle#2\\rangle}\n\\newcommand{\\MSig}[3]{\\text{def}~#1(#2): #3}\n\\newcommand{\\Ov}[1]{\\overline{#1}}\n\\newcommand{\\TyLam}[3]{\\lambda(\\Ov{#1:#2}).#3}\n\\newcommand{\\Trait}[2]{\\text{trait}~#1~\\{ #2 \\}}\n\\newcommand{\\To}{\\mapsto}\n\\newcommand{\\Low}[1]{\\mathcal{L}{[\\![#1]\\!]}}\n\\newcommand{\\Lam}[2]{\\lambda#1.#2}\n\\newcommand{\\IfThenElse}[3]{\\text{if}~(#1)~#2~\\text{else}~#3}\n\\newcommand{\\False}{\\text{false}}\n\\newcommand{\\True}{\\text{true}}\n\\newcommand{\\langname}{ErgoTree}\n\\newcommand{\\corelang}{Core-\\lambda}\n$$\n\n\n# Cryptographic \n\nThis document provides an in-depth look at the cryptographic schemes, protocols, and data structures used in the Ergo blockchain. Ergo\u2019s security model relies heavily on advanced cryptographic protocols that ensure the integrity of transactions, protect user privacy, and enforce complex spending conditions within smart contracts. This document outlines the internal workings of these cryptographic schemes, focusing on their implementation within Ergo, particularly through the [`sigmastate-interpreter`](https://github.com/ScorexFoundation/sigmastate-interpreter), [`sigma-rust`](https://github.com/ergoplatform/sigma-rust), and [`Scrypto`](https://github.com/input-output-hk/scrypto) repositories. ## Overview\n\n\nErgo\u2019s cryptographic toolkit is built around **composable Sigma protocols**, which allow for flexible, secure, and efficient proofs of knowledge and cryptographic operations within its smart contract framework. These Sigma protocols are the foundation of Ergo\u2019s cryptographic security, and they enable privacy-preserving applications like multi-signature wallets, ring signatures, and threshold signatures.",
  "keywords": [
    "sigma",
    "protocols",
    "\\newcommand{\\lst}[1]{#1",
    "\\newcommand{\\tup}[1]{(#1",
    "\\newcommand{\\msig}[3]{\\text{def}~#1(#2",
    "\\newcommand{\\ov}[1]{\\overline{#1",
    "\\newcommand{\\tylam}[3]{\\lambda(\\ov{#1:#2}).#3",
    "\\newcommand{\\low}[1]{\\mathcal{l}{[\\![#1]\\",
    "\\newcommand{\\lam}[2]{\\lambda#1.#2",
    "\\newcommand{\\ifthenelse}[3]{\\text{if}~(#1)~#2~\\text{else}~#3",
    "\\newcommand{\\false}{\\text{false",
    "\\newcommand{\\true}{\\text{true",
    "\\newcommand{\\langname}{ergotree",
    "document",
    "depth",
    "look",
    "scheme",
    "protocol",
    "datum",
    "structure",
    "ergo",
    "blockchain",
    "security",
    "model",
    "integrity",
    "transaction",
    "user",
    "privacy",
    "spending",
    "condition",
    "contract",
    "working",
    "implementation",
    "sigmastate",
    "interpreter`](https://github.com",
    "scorexfoundation",
    "interpreter",
    "rust`](https://github.com",
    "ergoplatform",
    "rust",
    "scrypto`](https://github.com",
    "output",
    "scrypto",
    "repository",
    "overview",
    "toolkit",
    "proof",
    "knowledge",
    "operation",
    "framework",
    "foundation",
    "application",
    "wallet",
    "ring",
    "signature",
    "threshold",
    "cryptographic",
    "hash",
    "functions",
    "sha-256](https://github.com",
    "blob",
    "master",
    "scala",
    "scorex",
    "crypto",
    "sha256.scala",
    "blake2b](https://github.com",
    "blake2b.scala",
    "digest",
    "encoding",
    "base58",
    "format",
    "signing",
    "algorithms",
    "ecdsa",
    "secp256k1",
    "schnorr",
    "secrets",
    "diffie",
    "hellman",
    "tuple",
    "secret",
    "proofs",
    "fiat",
    "shamir",
    "transformation",
    "environment",
    "detail",
    "function",
    "ergoscript",
    "functions](dev",
    "functions.md#cryptographic",
    "subclass",
    "system",
    "prover",
    "verifier",
    "feature",
    "work",
    "core",
    "protocols](sigma.md",
    "property",
    "discrete",
    "logarithm",
    "equality",
    "logarithms",
    "basis",
    "operator",
    "composability",
    "advantage",
    "statement",
    "subset",
    "participant",
    "construct",
    "creation",
    "powerful",
    "example",
    "ringscript",
    "atleast",
    "coll",
    "pk(\"9f8zqt1sue6w5acdmsprzshj3jjizkbyy3cetb4bisxeyk4rsnk",
    "pk(\"9hfwpyhcjcw4kqycgu4yagfc1ierakyfg24fkjljk2udga873uq",
    "pk(\"9gakeru1w4dh6adwxnnymfqjctnxnsmtym2lppmperckuscd6f3",
    "script",
    "group",
    "logic",
    "signatures",
    "part",
    "authenticity",
    "hardness",
    "problem",
    "performance",
    "process",
    "step",
    "generation",
    "\\(x\\",
    "generator",
    "curve",
    "message",
    "\\(m\\",
    "nonce",
    "\\(k\\",
    "computes",
    "verification",
    "compute",
    "verifying",
    "adaptor",
    "case",
    "multi",
    "wallets",
    "swap",
    "cryptocurrencie",
    "information",
    "verify",
    "ergoscript](https://www.ergoforum.org",
    "ergoscript/3407",
    "cryptography",
    "exchange",
    "\\quad",
    "\\text{and",
    "address",
    "mixer",
    "instance",
    "ergomix",
    "fungibility",
    "stealth",
    "addresses",
    "zerojoin",
    "mixers",
    "chain",
    "mixing",
    "token",
    "reliance",
    "party",
    "dive",
    "tuples",
    "diffie](diffie.md",
    "data",
    "structures",
    "state",
    "management",
    "avl+",
    "tree",
    "authenticated",
    "dynamic",
    "dictionary",
    "utxo",
    "change",
    "complexity",
    "insert",
    "lookup",
    "deletion",
    "scalability",
    "efficiency",
    "update",
    "network",
    "batchavlprover.scala](https://github.com",
    "input",
    "authds",
    "avltree",
    "batch",
    "batchavlverifier.scala](https://github.com",
    "merkle",
    "dataset",
    "block",
    "root",
    "node",
    "overhead",
    "here](merkle",
    "considerations",
    "assumption",
    "developer",
    "vulnerability",
    "randomness",
    "primitive",
    "test",
    "coverage",
    "signingspecification](https://github.com",
    "develop",
    "signingspecification.scala",
    "conclusion",
    "tool",
    "standard",
    "support",
    "variety",
    "primitives",
    "blake2b256",
    "algorithm",
    "interactive",
    "eip-0003",
    "deterministic",
    "standard](eip3.md",
    "page](dev",
    "description",
    "bitcoin",
    "recently](https://news.bitcoin.com",
    "cash",
    "upgrade",
    "forks",
    "instruction",
    "zcash",
    "ethereum",
    "rfcs",
    "musig](https://eprint.iacr.org/2018/068",
    "demos",
    "note",
    "basic",
    "paper",
    "contracts](https://eprint.iacr.org/2020/560",
    "trust",
    "setup",
    "efficient",
    "dht](diffie.md",
    "customer",
    "time",
    "payment",
    "store",
    "owner",
    "addresses](stealth",
    "page",
    "implementations",
    "zero",
    "treasury](zkt.md",
    "thing",
    "susy",
    "bridge",
    "scrypto](scrypto.md",
    "source"
  ],
  "sections": [
    {
      "heading": "Cryptographic",
      "content": "This document provides an in-depth look at the cryptographic schemes, protocols, and data structures used in the Ergo blockchain. Ergo\u2019s security model relies heavily on advanced cryptographic protocols that ensure the integrity of transactions, protect user privacy, and enforce complex spending conditions within smart contracts. This document outlines the internal workings of these cryptographic schemes, focusing on their implementation within Ergo, particularly through the sigmastate-interpreter, sigma-rust, and Scrypto repositories."
    },
    {
      "heading": "Overview",
      "content": "Ergo\u2019s cryptographic toolkit is built around composable Sigma protocols, which allow for flexible, secure, and efficient proofs of knowledge and cryptographic operations within its smart contract framework. These Sigma protocols are the foundation of Ergo\u2019s cryptographic security, and they enable privacy-preserving applications like multi-signature wallets, ring signatures, and threshold signatures."
    },
    {
      "heading": "Cryptographic Toolkit",
      "content": "Hash Functions: SHA-256 & Blake2b are used for generating secure cryptographic digests and ensuring data integrity.\nEncoding: Base58 encoding is used to represent binary data, such as public keys or hashes, in a more human-readable format.\nSigning Algorithms: Ergo supports both ECDSA (secp256k1) and Schnorr signatures for secure transaction signing.\nPrimitive Secrets: Schnorr signatures and Diffie-Hellman tuples are primitive secrets used in creating proofs of knowledge.\nNon-Interactive Proofs: Ergo makes cryptographic proofs non-interactive using the Fiat-Shamir transformation, making them suitable for blockchain environments.\nFor more details on cryptographic functions in ErgoScript, see ErgoScript Cryptographic Functions."
    },
    {
      "heading": "Sigma Protocols",
      "content": "Sigma protocols (\u03a3-protocols) are a subclass of cryptographic proof systems that allow a prover to convince a verifier of knowledge of a secret without revealing the secret itself. They are integral to the privacy and security features in Ergo, enabling advanced cryptographic applications such as zero-knowledge proofs, ring signatures, and threshold signatures."
    },
    {
      "heading": "How Sigma Protocols Work",
      "content": "At their core, Sigma protocols provide a secure way to prove the following properties:\nProof of Knowledge of Discrete Logarithm: Prove knowledge of the discrete logarithm of a given public key without revealing the secret key.\n\n\nProof of Equality of Discrete Logarithms (Diffie-Hellman Tuple): Prove that two discrete logarithms (e.g., over different bases) are equal without revealing the logarithms.\nThese basic Sigma protocols can be combined using logical operators, such as AND, OR, and THRESHOLD (k-out-of-n), to form complex proofs."
    },
    {
      "heading": "Composability of Sigma Protocols",
      "content": "One of the key advantages of Sigma protocols is their composability. They can be combined in flexible ways to create sophisticated cryptographic contracts:\nOR Proofs: Prove knowledge of one secret from a set of secrets (e.g., ring signatures).\nAND Proofs: Prove knowledge of all secrets in a statement (e.g., multi-signature).\nThreshold Proofs: Prove knowledge of at least k out of n secrets. This is essential for threshold signatures, where a subset of participants must cooperate to authorize a transaction.\nThese constructs enable the creation of powerful, privacy-preserving applications on Ergo."
    },
    {
      "heading": "Example: 3-out-of-5 Threshold Signature",
      "content": "Consider a 3-out-of-5 threshold signature that allows any three participants to sign a transaction. This ErgoScript implements such a scheme:\nscala\nval ringScript = s\"\"\"\n{\n  atLeast(\n    3, \n    Coll(\n      PK(\"9f8ZQt1Sue6W5ACdMSPRzsHj3jjiZkbYy3CEtB4BisxEyk4RsNk\"), \n      PK(\"9hFWPyhCJcw4KQyCGu4yAGfC1ieRAKyFg24FKjLJK2uDgA873uq\"), \n      PK(\"9fdVP2jca1e5nCTT6q9ijZLssGj6v4juY8gEAxUhp7YTuSsLspS\"), \n      PK(\"9gAKeRu1W4Dh6adWXnnYmfqjCTnxnSMtym2LPPMPErCkusCd6F3\"),\n      PK(\"9gmNsqrqdSppLUBqg2UzREmmivgqh1r3jmNcLAc53hk3YCvAGWE\")\n    )\n  )\n}\nThis script enables three participants from a group of five to cooperatively sign and authorize a transaction. It leverages the THRESHOLD (k-out-of-n) logic, which is native to Sigma protocols, ensuring that only a subset of participants is required to perform cryptographic operations."
    },
    {
      "heading": "Schnorr Signatures",
      "content": "Schnorr signatures are a key part of Ergo\u2019s cryptographic foundation, providing an efficient, simple, and secure way to verify the authenticity of transactions. The Schnorr signature scheme is based on the hardness of the discrete logarithm problem and is favored for its performance and security properties over ECDSA."
    },
    {
      "heading": "How Schnorr Signatures Work",
      "content": "The signing process in Schnorr signatures follows these steps:\nKey Generation: Generate a private key (x) and compute the corresponding public key (P = xG), where (G) is the generator of the elliptic curve (SecP256K1).\n\n\nSigning: To sign a message (m), the user:\n\nPicks a random nonce (k) and computes (R = kG),\nComputes (e = H(R || P || m)),\n\nComputes the signature as (s = k + ex).\n\n\nVerification: The verifier checks the signature by computing (R' = sG - eP) and verifying:\n   [\n   e = H(R' || P || m)\n   ]\nSchnorr signatures are widely used in Ergo for multi-signature schemes, privacy-enhancing protocols, and adaptor signatures."
    },
    {
      "heading": "Use Cases of Schnorr Signatures",
      "content": "Multi-Signature Wallets: Schnorr signatures enable efficient and secure multi-signature wallets, where multiple participants must sign a transaction collaboratively.\nAdaptor Signatures: Adaptor signatures allow for conditional private swaps, such as atomic swaps between different cryptocurrencies, without revealing sensitive information.\nFor detailed examples and implementation, see Verifying Schnorr Signatures in ErgoScript."
    },
    {
      "heading": "Diffie-Hellman Protocol",
      "content": "The Diffie-Hellman (DH) protocol is widely used in cryptography for secure key exchange. In Ergo, the Diffie-Hellman Tuple (DHT) protocol allows provers to demonstrate shared knowledge of a secret without revealing it, enabling privacy-preserving cryptographic proofs."
    },
    {
      "heading": "Diffie-Hellman Tuple (DHT)",
      "content": "In a Diffie-Hellman Tuple, a prover proves knowledge of a shared secret (x) such that:\n[\nu = g^x \\quad \\text{and} \\quad v = h^x\n]\nThis protocol can be combined with Sigma protocols to create privacy-preserving smart contracts, such as stealth addresses and mixers. For instance, ErgoMix relies on the security of the Diffie-Hellman protocol to ensure transaction fungibility and user privacy."
    },
    {
      "heading": "Use Cases of Diffie-Hellman",
      "content": "Stealth Addresses: Ensure that each transaction generates a unique address, making it difficult to link transactions to the original public address, protecting user privacy.\nZeroJoin Mixers: Enable on-chain privacy-preserving mixing of tokens, ensuring that transactions remain fungible and private without reliance on trusted third parties.\nFor a deep dive into Diffie-Hellman Tuples, refer to Diffie."
    },
    {
      "heading": "Data Structures in Ergo",
      "content": "Ergo employs specialized cryptographic data structures to ensure secure and efficient state management within its blockchain:"
    },
    {
      "heading": "AVL+ Trees",
      "content": "Ergo uses AVL+ trees as part of its Authenticated Dynamic Dictionary (ADD) to track UTXO state changes. These trees provide cryptographic proofs of state changes while maintaining logarithmic complexity for inserts, lookups, and deletions. AVL+ trees are essential for the UTXO model\u2019s scalability and efficiency, enabling fast and secure updates across the network.\nImplementation: Learn more about AVL+ trees in BatchAVLProver.scala and BatchAVLVerifier.scala."
    },
    {
      "heading": "Merkle Trees",
      "content": "Merkle trees are used in Ergo to ensure the integrity of large datasets, such as blocks of transactions, without requiring the entire dataset to be transmitted or verified. By storing only the root hash of a Merkle tree, nodes can quickly verify that individual transactions are part of the block, reducing the overhead of verification.\nLearn more about Merkle trees here."
    },
    {
      "heading": "Security Considerations",
      "content": "The cryptographic schemes in Ergo rely on the hardness of the discrete logarithm problem and other well-established cryptographic assumptions. It is critical that developers design smart contracts carefully to avoid vulnerabilities, such as weak randomness or improper use of cryptographic primitives. Ergo provides extensive test coverage for its cryptographic implementations, such as the SigningSpecification."
    },
    {
      "heading": "Conclusion",
      "content": "Ergo\u2019s cryptographic framework, built on Sigma protocols, Schnorr signatures, and Diffie-Hellman key exchanges, provides robust tools for secure and privacy-preserving decentralized applications. Its composable cryptographic proofs enable developers to create complex spending conditions, privacy-enhancing features, and flexible multi-signature schemes, all while maintaining a high standard of security.\nFor more information, visit the sigmastate-interpreter repository, sigma-rust repository, and Scrypto repository."
    }
  ],
  "qa_pairs": []
}