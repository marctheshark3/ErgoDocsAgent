{
  "title": "Using Merkle Batch Proofs on Ergo",
  "source_url": "docs/dev/data-model/structures/merkle/merkle-batch-impl.md",
  "summary": "# Using Merkle Batch Proofs on Ergo\n\n## Overview\n\nWhile full support for Merkle Trees and Batch Proofs is available in the `sigma-rust` library, which is extensively used in Rust-based Ergo applications, integration into the core JVM-based `sigmastate-interpreter` for direct use within ErgoScript remains in progress. There is an open issue in the `sigmastate-interpreter` repository to support Merkle Trees natively, which would allow for direct handling of static data within ErgoScript, enhancing efficiency in various blockchain operations, such as proof-of-transaction and securing extension block data. Until this feature is fully integrated into `sigmastate-interpreter`, developers working in JVM-based environments can leverage `scrypto`, which provides essential cryptographic functionalities, including Merkle Tree management and Batch Proof generation and verification. For more details on the ongoing integration efforts, you can refer to the [GitHub issue #296](https://github.com/ergoplatform/ergo/issues/296) in the Ergo repository. Now, let's delve into the practical steps of using Merkle Batch Proofs in Ergo.",
  "keywords": [
    "merkle",
    "batch",
    "proofs",
    "ergo",
    "overview",
    "support",
    "trees",
    "sigma",
    "rust",
    "library",
    "application",
    "integration",
    "core",
    "sigmastate",
    "interpreter",
    "ergoscript",
    "progress",
    "issue",
    "repository",
    "handling",
    "datum",
    "efficiency",
    "operation",
    "proof",
    "transaction",
    "extension",
    "block",
    "feature",
    "developer",
    "environment",
    "functionality",
    "tree",
    "management",
    "generation",
    "verification",
    "detail",
    "effort",
    "github",
    "ergoplatform",
    "issues/296",
    "step",
    "applications",
    "tool",
    "below",
    "guide",
    "code",
    "example",
    "bash",
    "clone",
    "https://github.com/ergoplatform/sigma-rust.git",
    "install",
    "instruction",
    "lang.org](https://www.rust",
    "lang.org",
    "project",
    "cargo",
    "build",
    "merkletree",
    "structure",
    "sigma_merkle_tree::merklenode",
    "create_merkle_tree",
    "data_2",
    "node_1",
    "merklenode::from_bytes(data_1",
    "node_2",
    "merklenode::from_bytes(data_2",
    "merklenode::from_bytes(data_3",
    "merkletree::new(vec![node_1",
    "node_3",
    "root",
    "tree.root_hash",
    "reference",
    "merkletree.rs`](https://github.com",
    "blob",
    "develop",
    "merkletree.rs",
    "file",
    "leave",
    "inclusion",
    "element",
    "sigma_merkle_tree::batchmerkleproof::batchmerkleproof",
    "generate_batch_merkle_proof(tree",
    "tree.proof_by_indices(&[0",
    "batchmerkleproof",
    "method",
    "batchmerkleproof.rs`](https://github.com",
    "batchmerkleproof.rs",
    "part",
    "verify_batch_merkle_proof(tree",
    "assert!(proof.valid(tree.root_hash().as_ref",
    "println!(\"proof",
    "serialization",
    "deserialization",
    "storage",
    "transmission",
    "node",
    "serialize_and_deserialize_proof(proof",
    "serialized_proof",
    "proof.scorex_serialize_bytes().unwrap",
    "deserialized_proof",
    "batchmerkleproof::scorex_parse_bytes(&serialized_proof).unwrap",
    "assert_eq!(proof",
    "println!(\"serialization",
    "scrypto",
    "https://github.com/input-output-hk/scrypto.git",
    "ensure",
    "scala",
    "lang.org](https://www.scala",
    "compile",
    "class",
    "import",
    "scorex.crypto.authds.merkle",
    "scorex.crypto.authds",
    "leafdata",
    "scorex.crypto.hash",
    "blake2b256",
    "seq.fill(5)(leafdata",
    "scorex.util",
    "random.randombytes(32",
    "merkletree(leafdata",
    "println(s\"merkle",
    "hf.encode(tree.roothash",
    "merkletree.scala`](https://github.com",
    "input",
    "output",
    "master",
    "scorex",
    "crypto",
    "authds",
    "merkletree.scala",
    "index",
    "scorex.crypto.authds.merkle.{batchmerkleproof",
    "leaf",
    "batchproof",
    "tree.proofbyindices(seq(0",
    "batchmerkleproof.scala`](https://github.com",
    "batchmerkleproof.scala",
    "batchproof.valid(tree.roothash",
    "scorex.crypto.authds.merkle.serialization",
    "serializer",
    "batchmerkleproofserializer[digest32",
    "blake2b256.type",
    "serializedproof",
    "serializer.serialize(batchproof",
    "deserializedproof",
    "serializer.deserialize(serializedproof).get",
    "println(\"serialization",
    "batchmerkleproofserializer",
    "batchmerkleproofserializer.scala`](https://github.com",
    "batchmerkleproofserializer.scala",
    "workflow",
    "scorex.crypto.authds.merkle.{merkletree"
  ],
  "sections": [
    {
      "heading": "Overview",
      "content": "While full support for Merkle Trees and Batch Proofs is available in the sigma-rust library, which is extensively used in Rust-based Ergo applications, integration into the core JVM-based sigmastate-interpreter for direct use within ErgoScript remains in progress. There is an open issue in the sigmastate-interpreter repository to support Merkle Trees natively, which would allow for direct handling of static data within ErgoScript, enhancing efficiency in various blockchain operations, such as proof-of-transaction and securing extension block data.\nUntil this feature is fully integrated into sigmastate-interpreter, developers working in JVM-based environments can leverage scrypto, which provides essential cryptographic functionalities, including Merkle Tree management and Batch Proof generation and verification.\nFor more details on the ongoing integration efforts, you can refer to the GitHub issue #296 in the Ergo repository.\nNow, let's delve into the practical steps of using Merkle Batch Proofs in Ergo."
    },
    {
      "heading": "Using Sigma-Rust for Rust-based Applications",
      "content": "The sigma-rust library provides comprehensive tools to create, manage, and verify Merkle Batch Proofs in Rust-based Ergo applications. Below is a step-by-step guide with code examples."
    },
    {
      "heading": "Step 1: Setting Up the Environment",
      "content": "Before you begin working with Merkle Batch Proofs in sigma-rust, ensure your environment is properly set up:\nClone the Sigma-Rust Repository:\n   bash\n   git clone https://github.com/ergoplatform/sigma-rust.git\n   cd sigma-rust\n\n\nInstall Rust: \n   Follow the instructions on rust-lang.org to install Rust if you haven't done so.\n\n\nBuild the Project:\n   bash\n   cargo build"
    },
    {
      "heading": "Step 2: Creating a Merkle Tree",
      "content": "First, create a Merkle tree using the MerkleTree structure provided by the sigma-rust library.\n```rust\nuse sigma_merkle_tree::merkletree::MerkleTree;\nuse sigma_merkle_tree::MerkleNode;\nfn create_merkle_tree() {\n    let data_1 = [1u8; 32];\n    let data_2 = [2u8; 32];\n    let data_3 = [3u8; 32];\nlet node_1 = MerkleNode::from_bytes(data_1);\nlet node_2 = MerkleNode::from_bytes(data_2);\nlet node_3 = MerkleNode::from_bytes(data_3);\n\nlet tree = MerkleTree::new(vec![node_1, node_2, node_3]);\nprintln!(\"Merkle Root: {:?}\", tree.root_hash());\n}\n```\nCode Reference: The MerkleTree structure is implemented in the merkletree.rs file."
    },
    {
      "heading": "Step 3: Generating a Batch Merkle Proof",
      "content": "Once the Merkle tree is created, you can generate a batch Merkle proof for specific leaves. This proof can be used to verify the inclusion of multiple elements.\n```rust\nuse sigma_merkle_tree::batchmerkleproof::BatchMerkleProof;\nfn generate_batch_merkle_proof(tree: &MerkleTree) {\n    let proof = tree.proof_by_indices(&[0, 2]).unwrap();\n    println!(\"Batch Merkle Proof: {:?}\", proof);\n}\n```\nCode Reference: The BatchMerkleProof structure and its methods are implemented in the batchmerkleproof.rs file."
    },
    {
      "heading": "Step 4: Verifying the Batch Merkle Proof",
      "content": "The generated proof can be verified against the Merkle root to ensure that the specified leaves are indeed part of the tree.\nrust\nfn verify_batch_merkle_proof(tree: &MerkleTree, proof: &BatchMerkleProof) {\n    assert!(proof.valid(tree.root_hash().as_ref()));\n    println!(\"Proof is valid.\");\n}"
    },
    {
      "heading": "Step 5: Serialization and Deserialization",
      "content": "Merkle batch proofs can be serialized and deserialized for storage or transmission, which is crucial for many blockchain applications where proofs are shared between nodes or stored for future verification.\n```rust\nuse sigma_ser::ScorexSerializable;\nfn serialize_and_deserialize_proof(proof: &BatchMerkleProof) {\n    let serialized_proof = proof.scorex_serialize_bytes().unwrap();\n    let deserialized_proof = BatchMerkleProof::scorex_parse_bytes(&serialized_proof).unwrap();\nassert_eq!(proof, &deserialized_proof);\nprintln!(\"Serialization and deserialization successful.\");\n}\n```"
    },
    {
      "heading": "Using Scrypto for JVM-based Applications",
      "content": "For JVM-based applications, scrypto provides similar functionalities to sigma-rust. It works closely with the sigmastate-interpreter to handle cryptographic operations, including Merkle Trees and Batch Proofs."
    },
    {
      "heading": "Step 1: Setting Up the Environment",
      "content": "To work with scrypto, follow these steps:\nClone the Scrypto Repository:\n   bash\n   git clone https://github.com/input-output-hk/scrypto.git\n   cd scrypto\n\n\nEnsure Scala and SBT Are Installed: \n   You can install Scala and SBT by following the instructions on scala-lang.org.\n\n\nBuild the Project:\n   bash\n   sbt compile"
    },
    {
      "heading": "Step 2: Creating a Merkle Tree",
      "content": "The Merkle Tree can be constructed using the MerkleTree class in Scrypto, similarly to how it's done in Rust.\n```scala\nimport scorex.crypto.authds.merkle.MerkleTree\nimport scorex.crypto.authds.LeafData\nimport scorex.crypto.hash.Blake2b256\nimplicit val hf = Blake2b256\nval leafData = Seq.fill(5)(LeafData @@ scorex.utils.Random.randomBytes(32))\nval tree = MerkleTree(leafData)\nprintln(s\"Merkle Root: ${hf.encode(tree.rootHash)}\")\n```\nCode Reference: The MerkleTree class is implemented in the MerkleTree.scala file."
    },
    {
      "heading": "Step 3: Generating a Batch Merkle Proof",
      "content": "In Scrypto, you can generate a batch Merkle proof by specifying the indices of the leaves you want to prove.\n```scala\nimport scorex.crypto.authds.merkle.{BatchMerkleProof, Leaf}\nval batchProof = tree.proofByIndices(Seq(0, 2)).get\nprintln(s\"Batch Merkle Proof: $batchProof\")\n```\nCode Reference: The BatchMerkleProof class and its methods are implemented in the BatchMerkleProof.scala file."
    },
    {
      "heading": "Step 4: Verifying the Batch Merkle Proof",
      "content": "You can then verify the generated proof to ensure that the elements are part of the Merkle tree.\nscala\nval isValid = batchProof.valid(tree.rootHash)\nprintln(s\"Batch Merkle Proof is valid: $isValid\")"
    },
    {
      "heading": "Step 5: Serialization and Deserialization",
      "content": "To serialize and deserialize the proof, Scrypto provides dedicated classes and methods, ensuring the proof can be efficiently stored or transmitted.\n```scala\nimport scorex.crypto.authds.merkle.serialization.BatchMerkleProofSerializer\nval serializer = new BatchMerkleProofSerializer[Digest32, Blake2b256.type]\nval serializedProof = serializer.serialize(batchProof)\nval deserializedProof = serializer.deserialize(serializedProof).get\nassert(batchProof == deserializedProof)\nprintln(\"Serialization and deserialization successful.\")\n```\nCode Reference: The BatchMerkleProofSerializer class is implemented in the BatchMerkleProofSerializer.scala file."
    },
    {
      "heading": "Example: End-to-End Workflow in Scrypto",
      "content": "Here\u2019s an example tying together all the steps in Scrypto:\n```scala\nimport scorex.crypto.authds.merkle.{MerkleTree, Leaf, BatchMerkleProof}\nimport scorex.crypto.authds.merkle.serialization.BatchMerkleProofSerializer\nimport scorex.crypto.hash.Blake2b256\nimport scorex.crypto.hash.Digest32\nimplicit val hf = Blake2b256\n// Create the Merkle tree\nval leafData = Seq.fill(5)(LeafData @@ scorex.utils.Random.randomBytes(32))\nval tree = MerkleTree(leafData)\n// Generate the batch Merkle proof\nval batchProof = tree.proofByIndices(Seq(0, 2)).get\n// Verify the proof\nval isValid = batchProof.valid(tree.rootHash)\nprintln(s\"Batch Merkle Proof is valid: $isValid\")\n// Serialize and deserialize the proof\nval serializer = new BatchMerkleProofSerializer[Digest32, Blake2b256.type]\nval serializedProof = serializer.serialize(batchProof)\nval deserializedProof = serializer.deserialize(serializedProof).get\nassert(batchProof == deserializedProof)\nprintln(\"Serialization and deserialization successful.\")\n```"
    }
  ],
  "qa_pairs": []
}