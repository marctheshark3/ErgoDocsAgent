{
  "title": "Features",
  "source_url": "docs/dev/stack/appkit/tutorial.md",
  "summary": "---\ntags:\n  - Java\n  - Tutorial\n---\n\n## Features\n\n[Ergo Appkit](https://github.com/aslesarenko/ergo-appkit) is a library for polyglot development of Ergo Applications based on [GraalVM](https://www.graalvm.org/). GraalVM has many [great use cases](https://medium.com/graalvm/graalvm-ten-things-12d9111f307d). Expanding on that, in this article, we will go through some of the Appkit features inherited from GraalVM and take you step-by-step in learning how to take advantage of them. ### Example Scenario\n\nWe will create a simple console application (called [FreezeCoin](https://github.com/aslesarenko/ergo-appkit-examples/blob/master/java-examples/src/main/java/org/ergoplatform/appkit/examples/FreezeCoin.java)) in Java which uses the Appkit library. By using Appkit, we will be able to easily send a new transaction to an Ergo node programmatically.",
  "keywords": [
    "java",
    "tutorial",
    "feature",
    "ergo",
    "appkit](https://github.com",
    "appkit",
    "library",
    "development",
    "applications",
    "graalvm",
    "cases](https://medium.com",
    "things-12d9111f307d",
    "article",
    "step",
    "advantage",
    "example",
    "scenario",
    "console",
    "application",
    "blob",
    "master",
    "ergoplatform",
    "transaction",
    "node",
    "amount",
    "contract",
    "ergoscript",
    "ergoscript.pdf",
    "examples](https://ergoplatform.org",
    "docs",
    "advancedergoscripttutorial.pdf",
    "freezer",
    "parameters",
    "freezedeadline",
    "block",
    "number",
    "ownerpk",
    "sigmaprop",
    "owner",
    "sigmaprop(height",
    "fund",
    "script",
    "blockchain",
    "order",
    "individual",
    "logic",
    "condition",
    "height",
    "deadline",
    "spending",
    "corresponding",
    "minute",
    "duration",
    "delay",
    "week",
    "month",
    "depth",
    "apkit",
    "freezecoin",
    "coin",
    "granted",
    "dapp",
    "technology",
    "stack",
    "dapps",
    "line",
    "interface",
    "home",
    "veteran",
    "setup",
    "appkit#setup",
    "implementation",
    "dependency",
    "gradle",
    "build.gradle.kts",
    "kotlin",
    "implementation(\"org.ergoplatform",
    "compile",
    "runtime",
    "rest",
    "http://localhost:9052/",
    "wiki",
    "default",
    "configuration",
    "testing",
    "addition",
    "setting",
    "json",
    "file",
    "parameter",
    "startup",
    "freeze_coin_config.json",
    "nodeapi",
    "apikey",
    "wallet",
    "password",
    "mnemonicpassword",
    "testnet",
    "newboxspendingdelay",
    "owneraddress",
    "authentication",
    "here](https://github.com",
    "api#setting",
    "mnemonic",
    "phrase",
    "wallet](https://github.com",
    "documentation",
    "user",
    "command",
    "argument",
    "value",
    "nanoergs",
    "lock",
    "void",
    "main(string",
    "args",
    "amounttosend",
    "long.parselong(args[0",
    "nanoerg",
    "ergotoolconfig",
    "conf",
    "ergotoolconfig.load(\"freeze_coin_config.json",
    "code",
    "address",
    "config",
    "address.create(conf.getparameters().get(\"owneraddress",
    "datum",
    "chain",
    "ergoclient",
    "instance",
    "ergonodeconfig",
    "nodeconf",
    "conf.getnode",
    "ergoclient](https://github.com",
    "ergoclient.java",
    "access",
    "context",
    "string",
    "txjson",
    "ergoclient.execute((blockchaincontext",
    "lambda",
    "ergowallet",
    "ctx.getwallet",
    "totaltospend",
    "minfee",
    "request",
    "optional",
    "list",
    "inputbox",
    "wallet.getunspentboxes(totaltospend",
    "boxes.ispresent",
    "ergoclientexception",
    "prover",
    "object",
    "secret",
    "signature",
    "proof",
    "ergoprover",
    "ctx.newproverbuilder",
    "nodeconf.getwallet().getpassword",
    "point",
    "input",
    "output",
    "builder",
    "unsignedtransactionbuilder",
    "case",
    "ergocontract",
    "outbox",
    "txb.outboxbuilder",
    "constantsbuilder.create",
    "ctx.getheight",
    "owneraddress.getpublickey",
    "source",
    "compilecontract",
    "method",
    "constant",
    "constantsbuilder.empty",
    "placeholder",
    "change",
    "unsignedtransaction",
    "txb.boxestospend(boxes.get",
    ".outputs(newbox",
    ".fee(parameters",
    "signedtransaction",
    "prover.sign(tx",
    "printing",
    "code](https://github.com",
    "detail",
    "template",
    "stone",
    "directory",
    "examples](https://github.com",
    "./gradlew",
    "clean",
    "shadowjar",
    "examples-3.1.0",
    "all.jar",
    "note",
    "build",
    "org.ergoplatform.appkit.examples",
    "console](https://gist.github.com",
    "aslesarenko",
    "cacee372350458ac31bd5c73e957e322",
    "network",
    "pool",
    "miner",
    "select",
    "footprint",
    "running",
    "process",
    "drawback",
    "time",
    "memory",
    "usage",
    "wall",
    "clock",
    "program",
    "start",
    "finish",
    "flag",
    "org.ergoplatform.appkit.example",
    "resident",
    "size",
    "page",
    "swap",
    "operation",
    "message",
    "signal",
    "switch",
    "thread",
    "second",
    "background",
    "compiler",
    "performance",
    "solution",
    "issue",
    "image",
    "need",
    "experience",
    "developer",
    "server",
    "all.jar\\",
    "--report",
    "elements",
    "runtime\\",
    "fallback",
    "-h:+traceclassinitialization",
    "-h:+reportexceptionstacktraces\\",
    "-h:+addallcharset",
    "classpath",
    "protocol",
    "http",
    "https",
    "classlist",
    "35,217.78",
    "freezecoin:3133",
    "60,238.25",
    "33,009.06",
    "analysis",
    "clinit",
    "universe",
    "13,718.96",
    "parse",
    "inline",
    "18,317.24",
    "44,806.82",
    "72,288.24",
    "write",
    "executable",
    "launcher",
    "fact",
    "machine",
    "system",
    "otool",
    "linux",
    "libsystem",
    "b.dylib",
    "compatibility",
    "version",
    "1.0.0",
    "/system",
    "frameworks",
    "corefoundation.framework",
    "versions",
    "corefoundation",
    "150.0.0",
    "/usr",
    "libz.1.dylib",
    "1.2.11",
    "pause",
    "dyld_library_path=$graal_home",
    "./freezecoin",
    "benefit",
    "develop",
    "javascript",
    "python",
    "ruby",
    "polyglot",
    "programming",
    "component",
    "language",
    "platform",
    "project",
    "node.js](https://www.graalvm.org",
    "reference",
    "manual",
    "ecmascript",
    "specification](http://www.ecma",
    "international.org",
    "ecma-262/10.0",
    "--polyglot",
    "option",
    "class",
    "freezecoin.js",
    "--vm.cp",
    "path",
    "root",
    "thoughthe",
    "python/#python",
    "freezecoin.py",
    "graalpython",
    "scripts](https://www.graalvm.org",
    "truffleruby",
    "ruby/#compatibility",
    "freezecoin.rb",
    "native",
    "shared",
    "libraries",
    "@centrypoint",
    "entry",
    "wrap",
    "@link",
    "freezecoin#sendtx",
    "@centrypoint(name",
    "sendtxentrypoint",
    "isolatethread",
    "signedword",
    "amounttosendw",
    "ccharpointer",
    "configfilenamec",
    "resbuffer",
    "unsignedword",
    "buffersize",
    "filenotfoundexception",
    "target",
    "ctypeconversion.tojavastring(configfilenamec",
    "sendtx(amounttosend",
    "configfilename",
    "buffer",
    "ctypeconversion.tocstring(txjson",
    "header",
    "--shared",
    "name",
    "libfreezecoin.dylib",
    "0.0.0",
    "boilerplate",
    "heap",
    "garbage",
    "collector",
    "stdlib.h",
    "libfreezecoin.h",
    "main(int",
    "argc",
    "char",
    "argv",
    "graal_isolate_t",
    "isolate",
    "null",
    "graal_isolatethread_t",
    "graal_create_isolate(null",
    "fprintf(stderr",
    "graal_create_isolate",
    "error\\n",
    "creation",
    "result[1024",
    "sendtx(thread",
    "sizeof(result",
    "result",
    "printf(\"%s\\n",
    "graal_detach_thread(thread",
    "graal_detach_thread",
    "return",
    "tool",
    "ld_library_path=.",
    "call_freezecoin",
    "intellij",
    "reason",
    "editor",
    "truffle",
    "framework](https://github.com",
    "oracle",
    "graal",
    "tree",
    "tooling",
    "debugger",
    "link",
    "chrome",
    "port",
    "debugging",
    "devtools://devtools",
    "js_app.html?ws=127.0.0.1:9229/30c7da1e-7558a47d09b",
    "breakpoint",
    "execution",
    "variable",
    "conclusion",
    "core",
    "consensus",
    "cryptography",
    "byte",
    "interpreter",
    "data",
    "serialise",
    "modification",
    "d)apps",
    "site](https://ergoplatform.org",
    "sources](https://github.com",
    "graalvm](https://www.graalvm.org"
  ],
  "sections": [
    {
      "heading": "Features",
      "content": "Ergo Appkit is a library for polyglot development of Ergo Applications based on GraalVM. GraalVM has many great use cases. Expanding on that, in this article, we will go through some of the Appkit features inherited from GraalVM and take you step-by-step in learning how to take advantage of them."
    },
    {
      "heading": "Example Scenario",
      "content": "We will create a simple console application (called FreezeCoin) in Java which uses the Appkit library. By using Appkit, we will be able to easily send a new transaction to an Ergo node programmatically. The\ntransaction will transfer a given amount of Erg into a new box protected by the following Ergo contract written in ErgoScript (see this introduction and more advanced examples to learn more about ErgoScript).\njava\n// Freezer Contract\n{ \n  // Parameters\n  // freezeDeadline: Int - some future block number after which the box can be spent\n  // ownerPk: SigmaProp - public key of the new box owner\n  sigmaProp(HEIGHT > freezeDeadline) && ownerPk\n}\nIn short, a box (and therefore the funds within the box) are locked under a contract (or script) on the Ergo blockchain. In order for the box to be spent, the contract must evaluate to be true. Thus the individual who wishes to spend the box must ensure that the contract evaluates to true based on the encoded logic within it.\nOur Freezer contract above checks the following conditions before allowing the box to be spent:\nThe current block number of the Ergo blockchain (aka blockchain HEIGHT) is \ngreater than the specified deadline\n\n\nThe spending transaction must be signed by the owner of the secret key\ncorresponding to the ownerPk public key.\nThe first condition forbids anyone from spending the box before the Ergo\nblockchain grows to the given height. Because new blocks on the blockchain are mined approximately every 2 minutes on average, using the current\nblockchain height, it is easy to define any duration of delays we wish, such as 1 day, 1 week, or 1 month. (i.e. (60 / 2) * 24 * 7 = 5040, which is the # of blocks per week).\nWe will now be going in-depth on how we can take this Freezer Contract and integrate it with the Apkit library in order to create the FreezeCoin console application so that anyone and everyone can choose to freeze their coins if they so wish. (Granted, this contract/dApp is not useful; however, it is an..."
    },
    {
      "heading": "Java Ergo App Development",
      "content": "Appkit aims to provide a set of interfaces that can be used idiomatically in Java. You will feel right at home using Appkit if you are a Java veteran.\nPlease follow the setup instructions for GraalVM and Appkit if you wish to reproduce the examples below.\nTo use Appkit in our Java implementation of FreezeCoin, we must add the following dependency in the gradle file\nkotlin\ndependencies {\n    implementation(\"org.ergoplatform\", \"ergo-appkit_2.12\", \"3.1.0\", \"compile\")\n    ...\n}\nFurthermore, at runtime, Appkit/our application needs to connect with an Ergo Node via REST API. Often,\nthe node will be running locally and made available at http://localhost:9052/. This is the standard scenario for anyone who has set up a full-node by following these\ninstructions and is using the default configuration.\nHenceforth we will assume that you have set up and started your Ergo Node so that it is available for testing of the application.\nNext, our application will need to know how to be able to connect to our local running node, in addition to other various settings, in order to function properly. We will use a JSON file with the following\nconfiguration parameters which our FreezeCoin app will load at startup.\nfreeze_coin_config.json:\nJSON\n{\n  \"node\": {\n    \"nodeApi\": {\n      \"apiUrl\": \"http://localhost:9052/\",\n      \"apiKey\": \"put your secret apiKey generated during node setup here\"\n    },\n    \"wallet\": {\n      \"mnemonic\": \"the mnemonic key used to initialize or restore the wallet of the node\",\n      \"password\": \"the password you chose to protect the wallet\",\n      \"mnemonicPassword\": \"the password you chose to protect the mnemonic\"\n    },\n    \"networkType\": \"TESTNET\"\n  },\n  \"parameters\": {\n    \"newBoxSpendingDelay\": \"30\",\n    \"ownerAddress\": \"3WzR39tWQ5cxxWWX6ys7wNdJKLijPeyaKgx72uqg9FJRBCdZPovL\"\n  }\n}\nHere apiKey is the secret key required for API authentication, which can be\nacquired as described\nhere.\nYour mnemonic is the secret phrase obtained during setup of a new\nwallet.\nHow our..."
    },
    {
      "heading": "Low-footprint, Fast-startup Ergo Applications",
      "content": "As you may know, using Java for short-running processes has a lot of drawbacks.\nApplications tend to suffer from long startup times and relatively high memory usage.\nLet's run FreezeCoin using the time command to\nget the real (wall-clock elapsed time). It takes the entire program to run from\nstart to finish. We use the -l flag to print the memory usage as well.\nshell\n$ /usr/bin/time -l java -cp build/libs/appkit-examples-3.1.0-all.jar \\\n   org.ergoplatform.appkit.examples.FreezeCoin 1000000000\n...\n       4.97 real         8.41 user         0.69 sys\n 513703936  maximum resident set size\n         0  average shared memory size\n         0  average unshared data size\n         0  average unshared stack size\n    125010  page reclaims\n      1216  page faults\n         0  swaps\n         0  block input operations\n         0  block output operations\n        13  messages sent\n        86  messages received\n         1  signals received\n      2384  voluntary context switches\n     17409  involuntary context switches\nAs seen above, this tiny application took 2 parallel threads almost 4\nseconds to run. Most of that time can be attributed to the JVM startup and\nthe background JIT compiler running. This is quite a sub-par performance, and we know we can do a lot better.\nLuckily, GraalVM provides us with the perfect solution.\nWe can solve this inherent issue with the JVM by compiling the Java code\nahead of time into a native executable image via GraalVM. This skips over the need to use the Java just-in-time compiler\nat runtime.\nThe experience for us (the developer using GraalVM) is quite similar to a conventional compiler like GCC. Note,\nwe may need to run ./gradlew clean shadowJar first.\nshell\n$ ./gradlew clean shadowJar\n$ native-image --no-server \\\n -cp build/libs/appkit-examples-3.1.0-all.jar\\\n --report-unsupported-elements-at-runtime\\\n  --no-fallback -H:+TraceClassInitialization -H:+ReportExceptionStackTraces\\\n   -H:+AddAllCharsets -H:+AllowVMInspection -H:-RuntimeAssertions\\\n   --al..."
    },
    {
      "heading": "Develop Ergo Applications in JavaScript, Python, Ruby",
      "content": "GraalVM supports so-called polyglot programming in which different components of\nan application can be developed using the most suitable language and then seamlessly combined together at runtime. In this way, a unique library written in, say, Java can be used in a node.js application written in JavaScript, for example.\nTo support polyglot programming GraalVM platform has high-performance implementations of popular languages. We are going to take advantage of this for our FreezeCoin example project to show you how easy this is to use your preferred language.\nBefore running the examples below (in JavaScript, Python and Ruby), please make sure that you have the Java version of FreezeCoin working locally in order to ensure everything is set up correctly."
    },
    {
      "heading": "JavaScript",
      "content": "GraalVM can run JavaScript and Node.js applications out of the box. It is compatible with the ECMAScript 2019\nspecification.\nAdditionally, js and node launchers accept special --jvm and --polyglot command-line options which allow JS scripts to access Java objects and classes.\nGiven that being the case, a JS implementation of FreezeCoin can be easily written using the Appkit.\nAPI interface.\nPlease see the full source code of FreezeCoin JS implementation\nfor details.\nThe following command uses the node launcher to execute the FreezeCoin.js script.\nshell\n$ node --jvm --vm.cp=build/libs/appkit-examples-3.1.0-all.jar \\\n  js-examples/FreezeCoin.js  1000000000\nNote, the paths in the command are relative to the root of\nergo-appkit-examples project directory."
    },
    {
      "heading": "Python",
      "content": "GraalVM can run Python\nscripts, thoughthe Python implementation is still experimental (see also\ncompatibility section for details).\nPython example of FreezeCoin can be executed using the following command\nshell\n$ graalpython --jvm --polyglot --vm.cp=build/libs/appkit-examples-3.1.0-all.jar \\\n   python-examples/FreezeCoin.py 1900000000"
    },
    {
      "heading": "Ruby",
      "content": "GraalVM can run Ruby scripts using TruffleRuby implementation, which is however still experimental (see also compatibility section for details).\nTruffleRuby aims to be fully compatible with the standard implementation of Ruby, MRI, version 2.6.2\nRuby example of FreezeCoin can be executed using the following command\nshell\n$ truffleruby --polyglot --jvm --vm.cp=build/libs/appkit-examples-3.1.0-all.jar \\\n    ruby-examples/FreezeCoin.rb 1900000000"
    },
    {
      "heading": "Ergo Native Shared Libraries",
      "content": "Another great benefit of GraalVM is that we can compile Java classes down into a native shared library instead of an executable.\nTo do this, we declare one or more static methods as the @CEntryPoint.\n```Java\npublic class FreezeCoin {\n    ...\n     /*\n     * Entry point callable from C which wraps {@link FreezeCoin#sendTx}\n     /\n    @CEntryPoint(name = \"sendTx\")\n    public static void sendTxEntryPoint(\n            IsolateThread thread,\n            SignedWord amountToSendW,\n            CCharPointer configFileNameC,\n            CCharPointer resBuffer, UnsignedWord bufferSize) throws FileNotFoundException {\n        long amountToSend = amountToSendW.rawValue();\n        // Convert the C strings to the target Java strings.\n        String configFileName = CTypeConversion.toJavaString(configFileNameC);\n        String txJson = sendTx(amountToSend, configFileName);\n// put resulting string into the provided buffer\n    CTypeConversion.toCString(txJson, resBuffer, bufferSize);\n}  \n...\n}\n```\nWe can then compile down to a shared library and an automatically generated header file. Notice the use of the --shared option.\n```shell\n$ native-image --no-server \\\n -cp build/libs/appkit-examples-3.1.0-all.jar\\\n --report-unsupported-elements-at-runtime\\\n  --no-fallback -H:+TraceClassInitialization -H:+ReportExceptionStackTraces\\\n   -H:+AddAllCharsets -H:+AllowVMInspection -H:-RuntimeAssertions\\\n   --allow-incomplete-classpath \\\n    --enable-url-protocols=http,https \n    --shared -H:Name=libfreezecoin -H:Path=c-examples\n$ otool -L c-examples/libfreezecoin.dylib \nc-examples/libfreezecoin.dylib:\n  .../c-examples/libfreezecoin.dylib (compatibility version 0.0.0, current version 0.0.0)\n  /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.50.4)\n  /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1455.12.0)\n  /usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)\n```\nNow we ca..."
    },
    {
      "heading": "include",
      "content": "int main(int argc, char argv) {\n  graal_isolate_t isolate = NULL;\n  graal_isolatethread_t thread = NULL;\nif (graal_create_isolate(NULL, &isolate, &thread) != 0) {\n    fprintf(stderr, \"graal_create_isolate error\\n\");\n    return 1;\n  }\nchar * configFileName = \"freeze_coin_config.json\";\n// get amountToSend from cmd args and call transaction creation\n  long amountToSend = atol(argv[1]);\n  char result[1024 * 16];\n  sendTx(thread, amountToSend, configFileName, result, sizeof(result));\n// print out serialized result\n  printf(\"%s\\n\", result);\nif (graal_detach_thread(thread) != 0) {\n    fprintf(stderr, \"graal_detach_thread error\\n\");\n    return 1;\n  }\n  return 0;\n}\n```\nWe can compile this with our standard system tools and easily run our executable (set LD_LIBRARY_PATH=. on Linux).\nshell\n$ clang -Ic-examples -Lc-examples -lfreezecoin c-examples/freezecoin.c -o call_freezecoin\n$ otool -L call_freezecoin\n$ DYLD_LIBRARY_PATH=$GRAAL_HOME/jre/lib ./call_freezecoin 1000000000"
    },
    {
      "heading": "Debugging Your Polyglot Ergo Application",
      "content": "You can debug JS, Python and Ruby in IntelliJ, but if, for some reason, this doesn't work for you or fit with your preferred editor, GraalVM offers another option.\nAll of the GraalVM languages (except for Java) are implemented using the common Truffle framework.\nTruffle allows for tooling like debuggers to be implemented once and be available for all supported languages.\nAs such, we can run our program with the flag --inspect, which will give us a link to open in Chrome and will pause the program in the debugger.\nshell\n$ ruby --polyglot --jvm --inspect --vm.cp=build/libs/appkit-examples-3.1.0-all.jar \\\n    ruby-examples/FreezeCoin.rb 1900000000\nDebugger listening on port 9229.\nTo start debugging, open the following URL in Chrome:\n    chrome-devtools://devtools/bundled/js_app.html?ws=127.0.0.1:9229/30c7da1e-7558a47d09b\n...\nFrom here, we can set breakpoints and continue execution. When it breaks, we\u2019ll see values of the variables, can continue again until the next breakpoint, and do everything we've come to expect from debuggers."
    },
    {
      "heading": "Conclusions",
      "content": "And with all of that said and done, we see just how easy it is to use Appkit to develop Ergo Applications. Appkit relies on the same core libraries which were used in implementing the Ergo consensus protocol. These libraries include the ErgoScript compiler, cryptography, byte code interpreter, data serialises and the other core components. Using GraalVM, we can reuse these tried and tested components in different application contexts without any modification or rewriting them ourselves.\nNo matter if you are using Java, JavaScript, Python or Ruby, you can take advantage of Appkit with GraalVM to drastically simplify the process of interacting with the Ergo blockchain while creating native-running (d)Apps."
    },
    {
      "heading": "References",
      "content": "Ergo Site\nErgo Sources\nErgo Appkit\nErgo Appkit Examples\nGraalVM"
    }
  ],
  "qa_pairs": []
}