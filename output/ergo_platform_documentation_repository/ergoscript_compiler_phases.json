{
  "title": "ErgoScript Compiler Phases",
  "source_url": "docs/dev/scs/ergoscript/compiler-phases.md",
  "summary": "---\ntags:\n  - Compiler\n---\n# ErgoScript Compiler Phases\n\nThis document provides an overview of the key phases in the ErgoScript compiler pipeline, including specific implementations in the sigma-rust and sigmastate-interpreter projects. The ErgoScript compiler takes high-level ErgoScript code and translates it into an intermediate form that can be evaluated by the ErgoTree interpreter or serialized for execution in the Ergo blockchain. ## Compiler Pipeline Overview\n\nThe Sigma frontend implements the following pipeline:\n\n`SourceCode` \u2192 `parse` \u2192 `bind` \u2192 `typecheck` \u2192 `buildGraph` \u2192 `buildTree` \u2192 `ErgoTree`\n\nHere\u2019s a breakdown of each phase:\n\n1. **Source Code**: The input is a string of Unicode characters representing the ErgoScript code. 2. **Parse**: Converts the source code into an Abstract Syntax Tree (AST).",
  "keywords": [
    "compiler",
    "ergoscript",
    "phase",
    "document",
    "overview",
    "pipeline",
    "implementation",
    "sigma",
    "rust",
    "sigmastate",
    "interpreter",
    "project",
    "level",
    "code",
    "form",
    "ergotree",
    "execution",
    "ergo",
    "blockchain",
    "frontend",
    "sourcecode",
    "parse",
    "buildgraph",
    "breakdown",
    "source",
    "input",
    "string",
    "unicode",
    "character",
    "abstract",
    "syntax",
    "tree",
    "bind",
    "resolve",
    "identifier",
    "definition",
    "typecheck",
    "expression",
    "type",
    "node",
    "graph",
    "optimization",
    "buildtree",
    "representation",
    "lexical",
    "analysis",
    "lexer",
    "tokenizer",
    "sequence",
    "token",
    "tokens",
    "element",
    "keyword",
    "operator",
    "literal",
    "group",
    "parser",
    "example",
    "language",
    "logos",
    "crate",
    "rule",
    "location",
    "lexer.rs`](https://github.com",
    "blob",
    "lexer.rs",
    "custom",
    "scala",
    "tokenization",
    "lang",
    "lexer.scala`](https://github.com",
    "scorexfoundation",
    "develop",
    "lexer.scala",
    "list",
    "structure",
    "format",
    "construct",
    "statement",
    "function",
    "order",
    "process",
    "sigmacompiler.parse",
    "method",
    "root",
    "child",
    "error",
    "handling",
    "parserexception",
    "rowan",
    "library",
    "concrete",
    "trees",
    "detail",
    "binaryexpr::lhs",
    "parser.rs`](https://github.com",
    "ergoplatform",
    "ast.rs`](https://github.com",
    "ast.rs",
    "parsing",
    "strategy",
    "sigmaparser.scala`](https://github.com",
    "sigmaparser.scala",
    "intermediate",
    "transformation",
    "information",
    "compilation",
    "kind",
    "enum",
    "span",
    "reference",
    "operation",
    "inference",
    "binding",
    "hir.rs`](https://github.com",
    "hir.rs",
    "purpose",
    "emphasis",
    "compatibility",
    "programming",
    "feature",
    "typedescs.scala`](https://github.com",
    "typedescs.scala",
    "binder",
    "variable",
    "script",
    "logic",
    "data",
    "name",
    "environment",
    "constant",
    "value",
    "intconstant",
    "boxconstant",
    "height",
    "block",
    "binderexception",
    "scriptenv",
    "binder.rs`](https://github.com",
    "binder.rs",
    "resolution",
    "sigmabinder.scala",
    "algorithm",
    "consistency",
    "infer",
    "assignment",
    "integer",
    "point",
    "number",
    "result",
    "typerexception",
    "correctness",
    "type_infer.rs`](https://github.com",
    "type_infer.rs",
    "system",
    "sigmatyper.scala",
    "building",
    "edge",
    "dependency",
    "propagation",
    "subexpression",
    "elimination",
    "ircontext.buildgraph",
    "replace",
    "common",
    "identifie",
    "computation",
    "dead",
    "remove",
    "output",
    "serialization",
    "mir.rs`](https://github.com",
    "mir.rs",
    "programgraphs.scala`](https://github.com",
    "programgraphs.scala",
    "checking",
    "verifie",
    "checker",
    "traversal",
    "type_check.rs`](https://github.com",
    "type_check.rs",
    "evaluable::eval",
    "trait",
    "lib.rs`](https://github.com",
    "lib.rs",
    "evaluation",
    "sigmapropprover.scala`](https://github.com",
    "sigmapropprover.scala",
    "sigmaserializable",
    "deserialization",
    "storage",
    "transmission",
    "serialization.rs`](https://github.com",
    "resource",
    "documentation](https://github.com",
    "docs",
    "compiler.md"
  ],
  "sections": [
    {
      "heading": "ErgoScript Compiler Phases",
      "content": "This document provides an overview of the key phases in the ErgoScript compiler pipeline, including specific implementations in the sigma-rust and sigmastate-interpreter projects. The ErgoScript compiler takes high-level ErgoScript code and translates it into an intermediate form that can be evaluated by the ErgoTree interpreter or serialized for execution in the Ergo blockchain."
    },
    {
      "heading": "Compiler Pipeline Overview",
      "content": "The Sigma frontend implements the following pipeline:\nSourceCode \u2192 parse \u2192 bind \u2192 typecheck \u2192 buildGraph \u2192 buildTree \u2192 ErgoTree\nHere\u2019s a breakdown of each phase:\nSource Code: The input is a string of Unicode characters representing the ErgoScript code.\nParse: Converts the source code into an Abstract Syntax Tree (AST).\nBind: Resolves identifiers within the AST, linking them to their corresponding definitions.\nTypecheck: Ensures all expressions in the AST are type-safe by assigning types to each node.\nBuildGraph: Transforms the typed AST into a directed acyclic graph (DAG) for optimization.\nBuildTree: Converts the optimized graph into an ErgoTree, the executable intermediate representation."
    },
    {
      "heading": "1. Lexical Analysis (Lexer)",
      "content": "Objective: The Lexer, or tokenizer, scans the source code and converts it into a sequence of tokens. Tokens are the smallest meaningful elements in the code, such as keywords, operators, literals, and identifiers.\nHow it works: The Lexer reads the input source code character by character and groups characters into tokens. These tokens are categorized and labeled for the parser to consume.\n\nExample: Keywords like if, else, or operators like +, - are converted into tokens representing these elements in the language.\n\n\n\nIn sigma-rust: Implemented using the Logos crate, which provides an efficient way to define lexing rules in Rust.\n\nLocation: ergoscript-compiler/src/lexer.rs\n\n\n\nIn sigmastate-interpreter: A custom Scala-based Lexer is used for tokenization.\n\nLocation: parsers/shared/src/main/scala/sigmastate/lang/Lexer.scala"
    },
    {
      "heading": "2. Syntax Analysis (Parser)",
      "content": "Objective: The Parser takes the list of tokens generated by the Lexer and constructs an Abstract Syntax Tree (AST). The AST represents the syntactical structure of the source code in a tree format, where each node corresponds to a language construct like an expression, statement, or function.\nHow it works: The parser traverses the tokens in a predefined grammatical order to build the AST. This process involves ensuring that the source code follows the language's syntax rules. In Sigma, this is done via the SigmaCompiler.parse method.\n\n\nExample: An expression like a + b would be represented as a node in the AST with + as the root and a and b as its children.\n\n\nError Handling: Any parsing errors throw a ParserException.\n\n\n\n\nIn sigma-rust: The parser uses the Rowan library to manage Concrete Syntax Trees (CST) and Abstract Syntax Trees (AST). AST nodes wrap Rowan's trees (CST) and expose node-specific details through methods (e.g., BinaryExpr::lhs()).\n\nLocation: ergoscript-compiler/src/parser.rs\nLocation: ergoscript-compiler/src/ast.rs\n\n\n\nIn sigmastate-interpreter: The Scala implementation utilizes its own parsing strategies to construct the AST from tokens.\n\nLocation: parsers/shared/src/main/scala/sigmastate/lang/SigmaParser.scala"
    },
    {
      "heading": "3. High-level Intermediate Representation (HIR)",
      "content": "Objective: The HIR simplifies the AST by abstracting away certain syntactical details while retaining the logical structure of the code. This intermediate representation is more conducive to further analysis and transformation.\nHow it works: The AST is transformed into HIR by \"lowering\" its structure, which means simplifying and standardizing the representation while retaining all necessary information for the subsequent compilation phases.\n\nExample: Complex language constructs in the AST are reduced to simpler, more uniform representations in the HIR.\n\n\n\nIn sigma-rust: Each HIR node has a kind (enum), span (source code reference), and an optional type. This makes it easier to perform operations like type inference and binding.\n\nLocation: ergoscript-compiler/src/hir.rs\n\n\n\nIn sigmastate-interpreter: HIR serves a similar purpose, with emphasis on compatibility with the Scala language's functional programming features.\n\nLocation: sc/shared/src/main/scala/sigma/compiler/ir/TypeDescs.scala"
    },
    {
      "heading": "4. Binding (Binder)",
      "content": "Objective: The Binder phase resolves and links identifiers in the HIR to their corresponding definitions. This includes resolving variables, functions, and constants to ensure that the script's logic is correctly mapped to the underlying data structures.\nHow it works: The Binder, implemented in SigmaBinder.bind, traverses the HIR and replaces symbolic names with actual references. This process involves checking the environment (like global variables and predefined constants) and linking them appropriately. It also transforms environment values of predefined Scala types (such as Int, Boolean, Box, etc.) into constant nodes (IntConstant, BoxConstant, etc.) of the corresponding type.\n\n\nExample: An identifier like HEIGHT in a script would be resolved to the actual block height from the environment.\n\n\nError Handling: Any binding errors throw a BinderException.\n\n\n\n\nIn sigma-rust: The Binder rewrites the HIR tree, swapping identifiers (e.g., HEIGHT), some predefined functions (e.g., min/max), and variables from the environment (ScriptEnv) with their HIR nodes, ensuring correct references.\n\nLocation: ergoscript-compiler/src/binder.rs\n\n\n\nIn sigmastate-interpreter: A similar process is implemented in Scala, using the Scala language's features for name resolution and binding.\n\nLocation: sc/shared/src/main/scala/sigma/compiler/phases/SigmaBinder.scala"
    },
    {
      "heading": "5. Type Inference",
      "content": "Objective: Type Inference ensures that all expressions in the script are type-safe by determining the types of all expressions. This phase is crucial for ensuring that all operations in the script are performed on compatible types.\nHow it works: The Type Inference algorithm recursively analyzes the HIR and assigns types to each expression. It checks for type consistency and infers types where they are not explicitly provided. The type assignment is performed by the assignType tree transformation, which assigns correct types to all tree nodes.\n\nExample: In a script, if an integer is added to a floating-point number, type inference will ensure that the operation is valid and determine the result's type.\n\n\n\nError Handling: Any type inference errors throw a TyperException.\n\n\nIn sigma-rust: Type inference is implemented as a separate phase that traverses the HIR tree and assigns types, ensuring type correctness before moving to the next phase.\n\nLocation: ergoscript-compiler/src/type_infer.rs\n\n\n\nIn sigmastate-interpreter: Type inference follows Scala's type system rules, ensuring that all expressions are type-safe.\n\nLocation: sc/shared/src/main/scala/sigma/compiler/phases/SigmaTyper.scala"
    },
    {
      "heading": "6. Graph Building",
      "content": "Objective: This phase converts the type-checked AST into a directed acyclic graph (DAG) where nodes represent operations and edges represent dependencies between operations. This graph representation allows for optimizations such as constant propagation, common subexpression elimination, and dead code elimination.\nHow it works: The IRContext.buildGraph method takes the typed AST and builds the graph. During graph building, the following optimizations are performed:\nConstant Propagation: Replaces variables with their known constant values.\nCommon Subexpression Elimination: Identifies and eliminates redundant computations.\n\nDead Code Elimination: Removes code that does not affect the final output.\n\n\nIn sigma-rust: The MIR generated during this phase is the final form of the intermediate representation used by the interpreter and for serialization.\n\nLocation: ergotree-ir/src/mir.rs\n\n\n\nIn sigmastate-interpreter: The graph building phase focuses on preparing the code for efficient execution by the ErgoTree interpreter.\n\nLocation: sc/shared/src/main/scala/sigma/compiler/ir/ProgramGraphs.scala"
    },
    {
      "heading": "7. Tree Building",
      "content": "Objective: This phase converts the optimized graph into an ErgoTree, which is the executable intermediate representation of the script. The ErgoTree is then ready to be interpreted by the ErgoTree interpreter.\nHow it works: The IRContext.buildTree method takes the graph produced in the previous phase and constructs the final ErgoTree. This involves finalizing the structure of the script in a form that can be executed by the interpreter.\n\n\nIn sigmastate-interpreter: The resulting ErgoTree can be processed by the Sigma interpreter, allowing for secure and efficient execution of the script.\n\nLocation: sc/shared/src/main/scala/sigma/compiler/ir/ProgramGraphs.scala"
    },
    {
      "heading": "8. Type Checking",
      "content": "Objective: Type Checking ensures that the types of all expressions and operations in the MIR are consistent and correct. This phase verifies that the script adheres to the type rules established during type inference.\nHow it works: The Type Checker traverses the MIR, checking that each operation's input types are compatible with its output types, and ensuring that the script is type-safe.\n\nExample: The Type Checker would flag an error if a string were incorrectly used in a numerical operation.\n\n\n\nIn sigma-rust: Type checking is performed alongside the MIR traversal, validating the correctness of the types before the script is executed.\n\nLocation: ergotree-ir/src/type_check.rs"
    },
    {
      "heading": "9. Execution (ErgoTree Interpreter)",
      "content": "Objective: The ErgoTree interpreter evaluates the MIR nodes by calling the Evaluable::eval() method on the tree root. Each node implements the Evaluable::eval() trait method.\nHow it works: The interpreter evaluates the ErgoTree to produce a result based on the logic defined in the script.\n\n\nIn sigma-rust: The interpreter evaluates the MIR nodes by calling Evaluable::eval() on the tree root.\n\nLocation: ergotree-interpreter/src/lib.rs\n\n\n\nIn sigmastate-interpreter: The Scala-based interpreter executes the ErgoTree, providing the final evaluation of the script.\n\nLocation: interpreter/shared/src/main/scala/org/ergoplatform/SigmaPropProver.scala"
    },
    {
      "heading": "10. ErgoTree Serialization",
      "content": "Objective: Each MIR node implements the SigmaSerializable trait with sigma_parse() and sigma_serialize() methods for serialization and deserialization.\nHow it works: This phase ensures that the ErgoTree can be serialized into a format suitable for storage or transmission and can be deserialized back into an executable form.\n\n\nIn sigma-rust: Each MIR node implements the SigmaSerializable trait for serialization and deserialization.\n\nLocation: ergotree-ir/src/serialization.rs"
    },
    {
      "heading": "Resources",
      "content": "sigma-rust/docs/architecture\nErgoScript Compiler Documentation"
    }
  ],
  "qa_pairs": []
}