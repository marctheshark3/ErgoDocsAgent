{
  "title": "EIP-0001: UTXO-Set Scanning Wallet API",
  "source_url": "docs/dev/wallet/standards/eip1.md",
  "summary": "---\ntags:\n  - EIP\n---\n\n# EIP-0001: UTXO-Set Scanning Wallet API\n\nMotivation \n----------\n\nCurrently, the Ergo node wallet is able to search for boxes protected only by simplest scripts associated with P2PK \naddresses which is a large barrier for dApps. This makes development of external applications which use smart contracts \nquite challenging. Development would involve scanning the blockchain state independently by the off-chain portion of \nthe dApp itself with handling forks, confirmation numbers, and so on. This Ergo Improvement Proposal focused on extending the wallet to be able to serve the needs of external applications by providing \na flexible scanning interface and the possibility for applications to register scans with the wallet to ensure that they are tracked. Scans that have successfully passed are considered to belong to the application.",
  "keywords": [
    "eip-0001",
    "utxo",
    "scanning",
    "wallet",
    "motivation",
    "currently",
    "ergo",
    "node",
    "script",
    "p2pk",
    "address",
    "barrier",
    "dapps",
    "development",
    "application",
    "contract",
    "state",
    "chain",
    "portion",
    "dapp",
    "fork",
    "confirmation",
    "number",
    "improvement",
    "proposal",
    "need",
    "scan",
    "interface",
    "possibility",
    "match",
    "mine",
    "reward",
    "user",
    "specification",
    "request",
    "registers](registers.md",
    "change",
    "predicate",
    "function",
    "value",
    "predicates",
    "return",
    "register",
    "argument",
    "value)`return",
    "contains_asset(assetid)`-",
    "asset",
    "and(predicate1",
    "predicate2",
    "predicaten",
    "child",
    "or(predicate1",
    "field",
    "sigma",
    "assetid",
    "bytes",
    "long",
    "byte",
    "array",
    "following",
    "example",
    "0e24",
    "ergotree",
    "form",
    "contains_asset(\"bc01de24311298068c07857d3860625abf3277997e2a2b8ff8ea91dda28d47a5",
    "json",
    "endpoint",
    "addition",
    "scheme",
    "name",
    "character",
    "scanname",
    "tracker",
    "args",
    "0e240008cd029f2230dbe53f6b84d8a884a3407c3dffe43daf8037445441be7cdcd261feeaa4",
    "containsasset",
    "02dada811a888cd0dc7a0a41739a3ad9b0f427741fe6ca19700cf1a51200c96bf7",
    "error",
    "reference",
    "identifier(id",
    "integer",
    "/scan",
    "listall",
    "deregister",
    "interaction",
    "question",
    "option",
    "walletinteraction",
    "boxes",
    "scanner",
    "addbox",
    "false",
    "positive",
    "rule",
    "filter",
    "part",
    "stoptracking/{scanid}/{boxid",
    "reading",
    "method",
    "boxes/{scanid",
    "boxesunspent/{scanid",
    "list",
    "proposed",
    "post",
    "registers",
    "stop",
    "manually",
    "3.3.0",
    "object",
    "description",
    "openapi.yaml",
    "file",
    "protocol",
    "client",
    "ergoplatform",
    "blob",
    "master",
    "resource",
    "predefine",
    "simplepayments",
    "miningrewards",
    "priority",
    "default",
    "or(contains(pk_1",
    "contains(pk_n",
    "pk_1",
    "pk_n",
    "mining",
    "examples",
    "scenario",
    "case",
    "crowdfunding",
    "section",
    "ergoscript",
    "whitepaper](https://ergoplatform.org",
    "docs",
    "ergoscript.pdf",
    "role",
    "project",
    "pledge",
    "self",
    "equals(script",
    "whitepaper",
    "backer",
    "deadline",
    "campaign",
    "moment",
    "contains(projectpubkey",
    "purpose",
    "count",
    "backerpubkey",
    "contains",
    "advanced",
    "tutorial](https://ergoplatform.org",
    "advancedergoscripttutorial.pdf",
    "coin",
    "alice",
    "output",
    "spending",
    "transaction",
    "side",
    "pubkey",
    "lets",
    "here](trustless",
    "lets.md",
    "management",
    "singleton",
    "token",
    "exchange",
    "manager",
    "contains_asset"
  ],
  "sections": [
    {
      "heading": "Motivation",
      "content": "Currently, the Ergo node wallet is able to search for boxes protected only by simplest scripts associated with P2PK \naddresses which is a large barrier for dApps. This makes development of external applications which use smart contracts \nquite challenging. Development would involve scanning the blockchain state independently by the off-chain portion of \nthe dApp itself with handling forks, confirmation numbers, and so on.\nThis Ergo Improvement Proposal focused on extending the wallet to be able to serve the needs of external applications by providing \na flexible scanning interface and the possibility for applications to register scans with the wallet to ensure that they are tracked. Scans that have successfully passed are considered to belong to the application.\nEach scan has a given scan ID, and each box found that matches said scan is tracked by the wallet and thus is associated with the scan ID. Among possible scans, there are some pre-defined scans \nimplemented by the node wallet, to track wallet's public keys and also mining rewards. Other scans are not directly implemented inside of \nthe wallet but can be added by a user or an external application."
    },
    {
      "heading": "Specification: Scanning",
      "content": "A new request to scan is initiated which registers said scan to be checked for all future UTXO-set changes (thus it is forward-looking).\nA predicate (function which returns a boolean value for a box) is required to register a scan.\nPredicates available are:\nCONTAINS(register, value) returns true if certain register contains given value. If register argument is missed, R1 (script register) will be scanned\nEQUALS(register, value)returns true if certain register contains only given value. If register argument is missed, R1 will be scanned\nCONTAINS_ASSET(assetId)- if a box contains asset with a given id\nAND(predicate1, predicate2, ..., predicateN) - if all the children predicates are true\nOR(predicate1, predicate2, ..., predicateN) - if one of the children predicates is true\nvalue field in the predicates above is about encoded sigma value, assetId is about just 32-bytes long byte array.\nThe following is an example of a predicate which states that the registered scan will search for boxes that contain a \ngiven asset and also the provided bytes in R1 (\"0e24...\" in the example is a byte array which contains a script \nrepresented in ErgoTree form).\nhaskell\nAND(\n    CONTAINS_ASSET(\"bc01de24311298068c07857d3860625abf3277997e2a2b8ff8ea91dda28d47a5\"), \n    CONTAINS(\"0e240008cd029f2230dbe53f6b84d8a884a3407c3dffe43daf8037445441be7cdcd261feeaa4\")\n   )\nThis must be formatted in JSON and sent as a request to register the scan. \nThis is done via the endpoint: /scan/register.\nIn addition to root predicate the scheme also requires a scan name \n(UTF-8 characters requiring for up to 255 bytes to be encoded).\nThe following is an example of valid JSON for a scan register request for the previous predicate.\njson\n{\n    \"scanName\": \"Asset and script tracker\",\n    \"trackingRule\" : {\n        \"predicate\": \"and\",\n        \"args\":[\n            {\"predicate\": \"contains\", \"value\": \"0e240008cd029f2230dbe53f6b84d8a884a3407c3dffe43daf8037445441be7cdcd261feeaa4\"},\n            {\"predicate\": \"containsAsset\"..."
    },
    {
      "heading": "Specification: Interaction With the Wallet",
      "content": "If a scan has found a box which also could be spent by the node wallet, there is a question whether the box should be \nshared with the wallet or not. There are three options for corresponding walletInteraction :\noff - add found boxes to the scan only\nshared - add found boxes to the scan if they belong to the wallet (so associated with P2PK scripts)\nforced - add found boxes to the wallet\nexample:\njson\n{\n    \"scanName\": \"Script tracker\",\n    \"trackingRule\" : {\n        \"predicate\": \"contains\", \n        \"value\": \"0e240008cd029f2230dbe53f6b84d8a884a3407c3dffe43daf8037445441be7cdcd261feeaa4\"       \n    },\n    \"walletInteraction\": \"forced\"\n}"
    },
    {
      "heading": "Specification: Adding Boxes Externally",
      "content": "Sometimes it is simpler for an external application to find relevant boxes itself without using the\nwallet scanner. For that we have the following endpoint:\n/scan/addBox"
    },
    {
      "heading": "Specification: Removing False Positive Boxes",
      "content": "The wallet collects boxes according to the scanning rules used. However, a box which passes the predicate filter may still not \nnecessarily be wanted as part of a scan. As such, an application can inform the wallet if a box is not needed to be\ntracked and can be ignored.\n/scan/stopTracking/{scanId}/{boxId} - to inform the wallet that a box does not belong to a given scan and \n                      thus should not be tracked anymore"
    },
    {
      "heading": "Specification: Reading Boxes",
      "content": "Once boxes are recognized, an external application can use them. To get all of the boxes that have ever been tracked by a scan, or \ncurrent tracked unspent boxes, the following API methods are proposed:\n/scan/boxes/{scanId}\n/scan/boxesUnspent/{scanId}"
    },
    {
      "heading": "Specification: List Of All Proposed Endpoints",
      "content": "POST: /scan/register - Registers/begins tracking a scan based on a provided predicate\nPOST: /scan/deregister - Stops tracking a given scan based on the ID provided\nPOST: /scan/addBox  - Manually add box\nPOST: /scan/stopTracking - To inform the wallet that a box does not belong to a given scan\nGET: /scan/listAll - Returns all the registered scans\nGET: /scan/boxes/{scanId} - List all boxes that have ever been tracked by the scan\nGET: /scan/boxesUnspent/{scanId} - List all boxes that have been tracked by the scan and are still unspent/part of the UTXO set"
    },
    {
      "heading": "Specification: List Of Implemented Endpoints",
      "content": "POST: /scan/register - 3.3.0\nPOST: /scan/deregister - 3.3.0\nPOST: /scan/addBox\nPOST: /scan/stopTracking - 3.3.0\nGET: /scan/listAll - 3.3.0\nGET: /scan/boxesUnspent/{scanId} - 3.3.0\nObjects and endpoints description can be found in openapi.yaml file in Ergo protocol reference client repository."
    },
    {
      "heading": "Specification: Predefined Scans",
      "content": "There are some predefined scans in the node, such as SimplePayments and MiningRewards. External scans has exclusive \npriority over predefined ones, this does mean that if a box could be, for example, associated with both the \nSimplePayments and an external scan, then the box will be associated with the external scan only.\nThe SimplePayments scan always has id == 10, MiningRewards has id == 9. \nThe SimplePayments default wallet scan is using the OR(CONTAINS(pk_1), ..., CONTAINS(pk_n)) predicate, where \npk_1, ..., pk_n are script bytes of the P2PK addresses of the wallet. MiningRewards predicate is similarly about \nmining script bytes corresponding to the P2PK addresses of the wallet."
    },
    {
      "heading": "UTXO-Set Scanning dApp Examples",
      "content": "Below example scenarios for dApp use cases are presented.\nCrowdfunding\nThe simplest crowdfunding script is provided in Section 2.3 of ErgoScript Whitepaper.\nThere are two roles in the script, a user and a project. For a user, scanning pledge boxes of self would be \njust EQUALS(script), where script are the bytes of a script from the Whitepaper that embeds both the backer and\nproject public keys. The user can withdraw the pledge box if it is still unspent after the crowdfunding deadline.\nHowever, a user may be interested to know the state of the campaign at a given moment. The project also needs to collect all of the pledge boxes.\nFor this, the simplest option is to use CONTAINS(projectPubKey) predicate \n, however if the project is using its key for other purposes than the crowdfunding, then the filter will \ngive false-positives. To reduce false positives count, instead of the public key, a larger part of the script which \ncontains projectPubKey but does not contain backerPubKey could be used within CONTAINS().\nMixing\nFor mixing scripts, see Section 3.3.1 of \nAdvanced ErgoScript Tutorial. To find her half-mix coin\nin the mixing application, Alice can simply watch for her public key. Then she is watching for this box, and once the\nbox is spent, she figures out the outputs of the spending transaction and adds her output manually to the wallet. Bob can \non his side can track a large enough part of the half-mix script not including Alice's pubkey u.\nLETS\nWe consider a trusted LETS as described here\nManagement contract uses a singleton token, as does the exchange contract as well. Thus for both the managers\nand the user, boxes can be tracked via CONTAINS_ASSET() filter."
    }
  ],
  "qa_pairs": []
}