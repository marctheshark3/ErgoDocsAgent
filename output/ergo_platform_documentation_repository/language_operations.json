{
  "title": "Language Operations",
  "source_url": "docs/dev/scs/sigma/lang-ops.md",
  "summary": "# Language Operations\n\n## Opcodes\n\n|   Code\t|   Operation\t|   Comment\t|\n|---\t|---\t|---\t|\n|   1\t| $LT(left: Value[SInt], right: Value[SInt])$$\t|   \t|\n|   2\t| $LE(left: Value[SInt] , right: Value[SInt])$  \t|   \t|\n|   3\t| $GT(left: Value[SInt], right: Value[SInt])$  \t|   \t|\n|   4\t| $GE(left: Value[SInt], right: Value[SInt])$  \t|   \t|\n|   5\t| $EQ$[$T1 <: SType, T2 <: SType$]$(left: Value[T1], right: Value[T2])$  \t|   \t|\n|   6\t| $NEQ$[$T1 <: SType, T2 <: SType$]$(left: Value[T1], right: Value[T2])$  \t|   \t|\n|   7\t| $OR(input: Value[SCollection[SBoolean]])$  \t|   \t|\n|   8\t| $AND(input: Value[SCollection[SBoolean]])$  \t|   \t|\n|   9\t| $CAND(sigmaTrees: Seq[SigmaTree])$  \t|   \t|\n|   10\t| $COR(sigmaTrees: Seq[SigmaTree])$  \t|   \t|\n|   11\t| $Plus(left: Value[SInt], right: Value[SInt])$  \t|   \t|\n|   12\t| $Minus(left: Value[SInt], right: Value[SInt])$  \t|   \t|\n|   13\t| $Xor(left: Value[SByteArray], right: Value[SByteArray])$  \t|   \t|\n|   14\t| $AppendBytes(left: Value[SByteArray], right: Value[SByteArray])$  \t|   \t|\n|   15\t| $Exponentiate(left: Value[SGroupElement], right: Value[SBigInt])$  \t|   \t|\n|   16\t| $MultiplyGroup(left: Value[SGroupElement], right: Value[SGroupElement])$  \t|   \t|\n|   17\t| $IntToByteArray(input: Value[SInt])$  \t|   \t|\n|   18\t| $ByteArrayToBigInt(input: Value[SByteArray])$  \t|   \t|\n|   19\t| $CalcBlake2b256(input: Value[SByteArray])$  \t|   \t|\n|   20\t| $ProveDiffieHellmanTuple(gv: Value[SGroupElement], hv: Value[SGroupElement], uv: Value[SGroupElement], vv: Value[SGroupElement])$  \t|   \t|\n|   21\t| $IsMember(tree: Value[SAvlTree], key: Value[SByteArray], proof: Value[SByteArray])$  \t|   \t|\n|   22\t| $IntConstant(value: Long)$ \t|   \t|\n|   23\t| $TaggedInt(id: Byte)$  \t|   \t|\n|   24\t| $BigIntConstant(value: BigInteger)$  \t|   \t|\n|   25\t| $TaggedBigInt(id: Byte)$  \t|   \t|\n|   26\t| $ByteArrayConstant(value: Array[Byte])$ |   \t|\n|   27\t| $TaggedByteArray(id: Byte)$  \t| |\n|   28\t| $PropConstant(value:",
  "keywords": [
    "language",
    "operations",
    "opcodes",
    "code",
    "operation",
    "comment",
    "|---",
    "value[sint])$$",
    "le(left",
    "value[sint])$",
    "gt(left",
    "ge(left",
    "eq$[$t1",
    "stype",
    "stype$]$(left",
    "value[t1",
    "value[t2])$",
    "neq$[$t1",
    "or(input",
    "value[scollection[sboolean]])$",
    "and(input",
    "cand(sigmatree",
    "seq[sigmatree])$",
    "cor(sigmatree",
    "plus(left",
    "value[sint",
    "minus(left",
    "xor(left",
    "value[sbytearray",
    "value[sbytearray])$",
    "exponentiate(left",
    "value[sgroupelement",
    "value[sbigint])$",
    "value[sgroupelement])$",
    "bytearraytobigint(input",
    "calcblake2b256(input",
    "provediffiehellmantuple(gv",
    "proof",
    "intconstant(value",
    "long)$",
    "taggedint(id",
    "byte)$",
    "bigintconstant(value",
    "taggedbigint(id",
    "bytearrayconstant(value",
    "taggedbytearray(id",
    "propconstant(value",
    "taggedprop(id",
    "avltreeconstant(value",
    "taggedavltree(id",
    "groupelementconstant(value",
    "groupelement)$",
    "groupgenerator$",
    "taggedgroupelement(id",
    "booleanconstant(val",
    "value",
    "taggedboolean(id",
    "taggedbox(id",
    "concretecollection$[$v",
    "stype$]$(value",
    "indexedseq[value[v]])$",
    "stype](input",
    "value[scollection[iv",
    "byte",
    "mapper",
    "transformer[iv",
    "ov])$",
    "value$[scollection[iv",
    "relation",
    "forall$[$iv",
    "fold$[$iv",
    "accid",
    "foldop",
    "twoargumentsoperation[iv",
    "iv])$",
    "byindex$[$v",
    "value[scollection[v",
    "index",
    "int)$",
    "sizeof$[$v",
    "value[scollection[v]])$",
    "extractheight(input",
    "value[sbox])$",
    "height$",
    "extractamount(input",
    "extractscript(input",
    "extractbytes(input",
    "extractregisteras$[$v",
    "value[sbox",
    "registerid",
    "registeridentifier",
    "default",
    "option[value[v",
    "none)$",
    "txoutput(outindex",
    "provedlog(value",
    "taggedvariable",
    "node",
    "scorexfoundation",
    "sigmastate",
    "interpreter",
    "pull/657",
    "front",
    "sgroupelement",
    "sigma",
    "state",
    "ergoscript",
    "groupelement",
    "blockchain",
    "boxleafconstant",
    "avltreedata",
    "avltree",
    "savltree](https://github.com",
    "blob",
    "fe7319f6ddd131d4bc02f46313f3590721f39f3b",
    "parser",
    "scala",
    "lang",
    "types.scala#l40",
    "case",
    "class",
    "avltreedata(digest",
    "addigest](https://github.com",
    "avltreedata.scala#l54",
    "height"
  ],
  "sections": [
    {
      "heading": "Opcodes",
      "content": "|   Code    |   Operation   |   Comment |\n|---    |---    |---    |\n|   1   | $LT(left: Value[SInt], right: Value[SInt])$$  |       |\n|   2   | $LE(left: Value[SInt], right: Value[SInt])$   |       |\n|   3   | $GT(left: Value[SInt], right: Value[SInt])$   |       |\n|   4   | $GE(left: Value[SInt], right: Value[SInt])$   |       |\n|   5   | $EQ$[$T1 <: SType, T2 <: SType$]$(left: Value[T1], right: Value[T2])$     |       |\n|   6   | $NEQ$[$T1 <: SType, T2 <: SType$]$(left: Value[T1], right: Value[T2])$    |       |\n|   7   | $OR(input: Value[SCollection[SBoolean]])$     |       |\n|   8   | $AND(input: Value[SCollection[SBoolean]])$    |       |\n|   9   | $CAND(sigmaTrees: Seq[SigmaTree])$    |       |\n|   10  | $COR(sigmaTrees: Seq[SigmaTree])$     |       |\n|   11  | $Plus(left: Value[SInt], right: Value[SInt])$     |       |\n|   12  | $Minus(left: Value[SInt], right: Value[SInt])$    |       |\n|   13  | $Xor(left: Value[SByteArray], right: Value[SByteArray])$      |       |\n|   14  | $AppendBytes(left: Value[SByteArray], right: Value[SByteArray])$      |       |\n|   15  | $Exponentiate(left: Value[SGroupElement], right: Value[SBigInt])$     |       |\n|   16  | $MultiplyGroup(left: Value[SGroupElement], right: Value[SGroupElement])$      |       |\n|   17  | $IntToByteArray(input: Value[SInt])$      |       |\n|   18  | $ByteArrayToBigInt(input: Value[SByteArray])$     |       |\n|   19  | $CalcBlake2b256(input: Value[SByteArray])$    |       |\n|   20  | $ProveDiffieHellmanTuple(gv: Value[SGroupElement], hv: Value[SGroupElement], uv: Value[SGroupElement], vv: Value[SGroupElement])$     |       |\n|   21  | $IsMember(tree: Value[SAvlTree], key: Value[SByteArray], proof: Value[SByteArray])$   |       |\n|   22  | $IntConstant(value: Long)$    |       |\n|   23  | $TaggedInt(id: Byte)$     |       |\n|   24  | $BigIntConstant(value: BigInteger)$   |       |\n|   25  | $TaggedBigInt(id: Byte)$      |       |\n|   26  | $ByteArrayConstant(value: Array[Byte])$   |       |\n|   27  ..."
    },
    {
      "heading": "TaggedVariable",
      "content": "Remove unused TaggedVariable node #657"
    },
    {
      "heading": "SGroupElement",
      "content": "The 'S' in front of SGroupElement refers to the sigma state code under the ErgoScript. When working on the ErgoScript directly, you will use GroupElement."
    },
    {
      "heading": "SAvlTree (AvlTreeData)",
      "content": "\"AvlTree\" -> SAvlTree\n\n\ncase class AvlTreeData(digest: ADDigest"
    }
  ],
  "qa_pairs": []
}