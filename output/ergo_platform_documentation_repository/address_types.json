{
  "title": "Address Types",
  "source_url": "docs/dev/wallet/address/address_types.md",
  "summary": "# Address Types \n\n\nPossible network types are:\n\n* Mainnet - `0x00`\n* Testnet - `0x10`\n\nAddress types are (semantics described below):\n\n* `0x01` - Pay-to-PublicKey(P2PK) address\n* `0x02` - Pay-to-Script-Hash(P2SH) * `0x03` - Pay-to-Script(P2S)\n\n\nFor an address type, we form content bytes as follows:\n\n* **P2PK** - serialized (compressed) public key\n* **P2SH** - first 192 bits of the Blake2b256 hash of serialized script bytes\n*",
  "keywords": [
    "address",
    "types",
    "network",
    "type",
    "mainnet",
    "0x00",
    "testnet",
    "semantic",
    "publickey(p2pk",
    "script",
    "hash(p2sh",
    "script(p2s",
    "content",
    "bytes",
    "p2pk",
    "blake2b256",
    "hash",
    "byte",
    "mining",
    "reward",
    "example",
    "transaction",
    "ergs",
    "case",
    "value",
    "input",
    "p2sh",
    "rbcrmkeyduuvadj9ts3dsvsg27h54pgrq5fpuwb",
    "4mqyml64gnzmxzgm",
    "bxkbahkvrtvlzrdczjcsxsf7assrn73ijefzxtbj4cxzhhcvbtqsxq",
    "note",
    "number",
    "base58",
    "summary",
    "prefix",
    "0x13",
    "checksum",
    "leftmost_4_bytes",
    "people",
    "contract",
    "chain",
    "fund",
    "dapp",
    "datum",
    "load",
    "candidate",
    "template",
    "term",
    "eip-5](eip5.md",
    "perspective",
    "context",
    "parameter",
    "concrete",
    "dapps",
    "sigma",
    "contracttemplate",
    "code",
    "fleet"
  ],
  "sections": [
    {
      "heading": "Address Types",
      "content": "Possible network types are:\nMainnet - 0x00\nTestnet - 0x10\nAddress types are (semantics described below):\n0x01 - Pay-to-PublicKey(P2PK) address\n0x02 - Pay-to-Script-Hash(P2SH)\n0x03 - Pay-to-Script(P2S)\nFor an address type, we form content bytes as follows:\nP2PK - serialized (compressed) public key\nP2SH - first 192 bits of the Blake2b256 hash of serialized script bytes\nP2S  - serialized script (this is where mining rewards go!)\nFor example,\nSending 10 ERG to a P2PK address usually means that a corresponding transaction will contain a box in which 10 Ergs are locked by a public key encoded in the P2PK Address. \nSimilarly, in the case of a P2S address, the box will be locked by a script encoded in the Address. \nIn the most complicated case of a P2SH script, the box will be protected by a special predefined script that takes the first 192 bits of Blake2b256 hash value for a script shown by an input spending the box.\nHere are some examples of the various types of addresses you'll see on the testnet:\nP2PK (3WvsT2Gm4EpsM9Pg18PdY6XyhNNMqXDsvJTbbf6ihLvAmSb7u5RN)\nP2SH (rbcrmKEYduUvADj9Ts3dSVSG27h54pgrq5fPuwB)\nP2S (Ms7smJwLGbUAjuWQ)\nAnd here is how what they look like on the mainnet:\nP2PK (9fRAWhdxEsTcdb8PhGNrZfwqa65zfkuYHAMmkQLcic1gdLSV5vA)\nP2SH (8UApt8czfFVuTgQmMwtsRBZ4nfWquNiSwCWUjMg)\nP2S (4MQyML64GnzMxZgm, BxKBaHkvrTvLZrDcZjcsxsF7aSsrN73ijeFZXtbj4CXZHHcvBtqSxQ)\nNote: P2S can start with any number, D, M, or any other of base58. 9 is always a P2PK address on the mainnet."
    },
    {
      "heading": "Summary",
      "content": "Prefix byte = network type + address type \n(for example, P2S script on the testnet starts with 0x13 before Base58)\n\n\nchecksum = leftmost_4_bytes (blake2b256 (prefix byte || content bytes))\naddress = prefix byte || content bytes || checksum"
    },
    {
      "heading": "P2S vs P2SH",
      "content": "Typically most people use P2S because it is a lot easier to use. P2SH means you have to keep the contract ready off-chain to be submitted when you create the transaction, and if you lose it, then your funds are stuck forever. This also makes it harder for other people to use your dApp as they need the contract themselves, rather than just the address. P2SH is technically cheaper since you store less data on-chain, but likely we won't see anyone using P2SH until we start to get heavy load on-chain.\nP2SH is a good candidate for a pre-defined contract template (in terms of EIP-5) From this perspective context var id can be a template parameter. So fixing concrete id is not necessary. The template hex can be created once and then used across dApps. Sigma already support ContractTemplate, and the corresponding code can be made available in Fleet via Sigma-js."
    }
  ],
  "qa_pairs": []
}