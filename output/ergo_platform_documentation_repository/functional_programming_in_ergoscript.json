{
  "title": "Functional Programming in ErgoScript",
  "source_url": "docs/dev/scs/ergoscript/functional-programming.md",
  "summary": "# Functional Programming in ErgoScript\n\nFunctional programming is a significant part of ErgoScript's capabilities. The next examples demonstrate the application of functional features in ErgoScript. Consider a situation where we want to allow a box to be spent only if all the following conditions are met:\n\n1. The spender knows the discrete log of the given elliptic curve (EC) point `0250863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b2352`. 2.",
  "keywords": [
    "functional",
    "programming",
    "ergoscript",
    "part",
    "capability",
    "example",
    "application",
    "feature",
    "situation",
    "condition",
    "spender",
    "curve",
    "point",
    "input",
    "program",
    "sameasme(box",
    "box.propositionbyte",
    "self.propositionbyte",
    "provedlog(z",
    "inputs.forall(sameasme",
    "address",
    "p2s/?source",
    "absence",
    "keyword",
    "immutability",
    "value",
    "iteration",
    "self.propositionbytes",
    "inputs.fold(0l",
    "accum",
    "box.value",
    "address](https://wallet.plutomonkey.com",
    "icagihskicagicagihzhbcb6id0gzgvjb2rlug9pbnqoznjvbujhc2u2ncgiqwxdr090wktonjzltctnoed2r29rrhkxudfqa2h0afjiytjlqklok1d5tlmikskkicagicagigrlzibzyw1lqxnnzshib3g6qm94ksa9igjvec5wcm9wb3npdglvbkj5dgvzid09ifnfteyuchjvcg9zaxrpb25cexrlcwogicagicagdmfsihn1bsa9ieloufvuuy5mb2xkkdbmlcb7ichhy2n1btpmb25nlcbib3g6iejveckgpt4gywnjdw0gkybib3gudmfsdwugfskgciagicagicakicagicagihbyb3zlrgxvzyh6ksamjibjtlbvvfmuzm9yywxskhnhbwvbc01lksamjibzdw0gpiaxmdawmdawmdawicagicagiaogicagfqo=",
    "49aksspuvsqhk17c4jlxhqxh7yl5nmwxdeselp6mnzyejzvf7ikk3jgi4fh96o7rjeau8jsvpvz5ehcgboqy9d68qrewaycvxsucsd8ucamhpsv9khzqhe4tam5d7zmf",
    "power",
    "restriction",
    "range",
    "function",
    "style"
  ],
  "sections": [
    {
      "heading": "Functional Programming in ErgoScript",
      "content": "Functional programming is a significant part of ErgoScript's capabilities. The next examples demonstrate the application of functional features in ErgoScript. Consider a situation where we want to allow a box to be spent only if all the following conditions are met:\nThe spender knows the discrete log of the given elliptic curve (EC) point 0250863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b2352.\nAll input boxes must be protected by the same ErgoScript program.\nThe conditions above can be coded into the following program:\n```scala\n{\n   val z = decodePoint(fromBase64(\"AlCGOtZKh66KL+g8GvGoQDy1P1PkhthRHa2KBIh+WyNS\"))\n   def sameAsMe(box:Box) = box.propositionBytes == SELF.propositionBytes\nproveDlog(z) && INPUTS.forall(sameAsMe)     \n}\n```\nThe address that corresponds to the program above is 3PwBHASpxaJa5i3vmLtUTvEqjbJWcpqnyuX9hSmUbaK2HAmoDLHmYSMm4up5pCRytSStEhsHnzTfpHzvCRZ.\nThe absence of the var keyword might initially seem limiting as it enforces immutability. For example, to calculate the sum of all inputs, you might think about storing the cumulative value in a var and iterating over all inputs, updating the var with each iteration.\nHere's an example of how you can compute the sum of all inputs in ErgoScript. Suppose an additional condition is that the box can only be spent if the sum of all inputs is greater than 1 Erg (or 1000000000 nanoErgs).\n```scala\n{\n   val z = decodePoint(fromBase64(\"AlCGOtZKh66KL+g8GvGoQDy1P1PkhthRHa2KBIh+WyNS\"))\n   def sameAsMe(box:Box) = box.propositionBytes == SELF.propositionBytes\n   val sum = INPUTS.fold(0L, { (accum:Long, box: Box) => accum + box.value })\nproveDlog(z) && INPUTS.forall(sameAsMe) && sum > 1000000000     \n}\n```\nThis corresponds to the address\n49AkSSPuVSQHk17C4JLxhqxH7yL5NMWxdEsELp6MNzYeJZvF7iKk3Jgi4fh96o7RJeaU8JSVPvZ5EhCgboQy9d68QreWaYcVxSUcsd8UCamHPsv9kHzqhe4tAM5D7ZmF.\nThese examples demonstrate the power of functional programming in ErgoScript. Despite the apparent restriction of immutability, a wide range of ..."
    }
  ],
  "qa_pairs": []
}