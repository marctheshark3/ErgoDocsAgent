{
  "title": "Analog Ergo",
  "source_url": "docs/eco/analog-ergo.md",
  "summary": "---\ntags:\n  - Analog Ergo\n  - Marketplace\n  - Atomic Swaps\n  - dApp\n  - dApp-InDev\n---\n\n# Analog Ergo\n\nThis project aims to use cryptographic primitives (well established, low level algorithms) as the basis for a cross-chain peer-to-peer marketplace. It will enable users to set and agree to listing prices and other parameters in a private and fungible manner, without the involvement of intermediaries.\n\n\n\n## ScalarLock\n\n> Successfully tested a Scalar Lock contract, this allows you to lock funds to a scalar value like a random 256bit number that you can test by comparing it with an Elliptic curve multiplication operation against the Secp256k1 Generator. A key component of how values are checked when verifying cryptographic signatures and will enable the final step to Atomic Swaps!. ErgoScript makes this quite easy (Once the constants and [registers](registers.md) are figured out):\n\n```scala\n val scalarLockScript: String = {\n        s\"\"\"\n            {\n            val xBYTES = OUTPUTS(0).R4[Coll[Byte]].get\n            val x = byteArrayToBigInt(xBYTES)",
  "keywords": [
    "analog",
    "ergo",
    "marketplace",
    "atomic",
    "swaps",
    "dapp",
    "indev",
    "project",
    "primitive",
    "level",
    "algorithm",
    "basis",
    "peer",
    "user",
    "price",
    "parameter",
    "manner",
    "involvement",
    "intermediary",
    "scalarlock",
    "scalar",
    "lock",
    "contract",
    "fund",
    "value",
    "256bit",
    "number",
    "curve",
    "multiplication",
    "operation",
    "generator",
    "component",
    "signature",
    "step",
    "ergoscript",
    "constant",
    "registers](registers.md",
    "scalarlockscript",
    "string",
    "bytearraytobigint(xbytes",
    "decodepoint(generator",
    "g.exp(x",
    "check",
    "point",
    "transaction",
    "output",
    "deploying](https://tn",
    "explorer.anetabtc.io",
    "b9d6a5796e0fa7b8fdf374426219d8fe2d64e7d9976e04845a0a6886414343b9",
    "spending](https://tn",
    "transactions/8c2440eff436a0c2f2af4b8b2d2ac53fbcfd43762b411217a26899f0ce749ba0",
    "scala](https://github.com",
    "dzyphr",
    "scalasigmaparticle",
    "blob",
    "scala",
    "scalarlock.scala",
    "party",
    "swap",
    "example",
    "shell",
    "window",
    "2patomicswapexample](https://github.com",
    "dzyphr/2patomicswapexample",
    "people",
    "secret",
    "protocol",
    "datum",
    "interaction"
  ],
  "sections": [
    {
      "heading": "Analog Ergo",
      "content": "This project aims to use cryptographic primitives (well established, low level algorithms) as the basis for a cross-chain peer-to-peer marketplace. It will enable users to set and agree to listing prices and other parameters in a private and fungible manner, without the involvement of intermediaries."
    },
    {
      "heading": "ScalarLock",
      "content": "Successfully tested a Scalar Lock contract, this allows you to lock funds to a scalar value like a random 256bit number that you can test by comparing it with an Elliptic curve multiplication operation against the Secp256k1 Generator. A key component of how values are checked when verifying cryptographic signatures and will enable the final step to Atomic Swaps!. \nErgoScript makes this quite easy (Once the constants and registers are figured out):\nscala\n val scalarLockScript: String = {\n        s\"\"\"\n            {\n            val xBYTES = OUTPUTS(0).R4[Coll[Byte]].get\n            val x = byteArrayToBigInt(xBYTES)\n            val G = decodePoint(generator)\n              sigmaProp(\n                receiver &&\n                G.exp(x) == xG\n              )\n            }\n        \"\"\".stripMargin\nIt compares a given scalar value (x) to an elliptic curve multiplication operation of Secp256k1 generator (G) and checks if they are equal.\nIt decodes the generator point and extracts a scalar value from the transaction output. It then checks if the point computed from the scalar multiplication of the generator point and the extracted scalar value is equal to a predefined point. If the two points are equal, the transaction is valid.\nDeploying\nSpending\nScala"
    },
    {
      "heading": "2-Party Atomic Swap",
      "content": "A working python example of a 2-party atomic swap that you can simulate from 2 shell/terminal windows is available at 2pAtomicSwapExample. This might help people reason about the way in which secrets are shared through this protocol and at what steps what data transfer or blockchain interaction is supposed to occur."
    }
  ],
  "qa_pairs": []
}