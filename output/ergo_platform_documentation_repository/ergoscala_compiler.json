{
  "title": "ErgoScala compiler",
  "source_url": "docs/dev/stack/ergoscala.md",
  "summary": "# ErgoScala compiler\n\nCompiler for Ergo smart contracts written in ErgoScala (a subset of Scala). Compilation from formally verified smart contracts from [ergo-contracts](https://github.com/ergoplatform/ergo-contracts) is supported. # Usage\n\n```scala\nlibraryDependencies += \"org.ergoplatform\" %% \"ergo-scala-compiler\" % \"0.0.0-32-aaadbee1-SNAPSHOT\",\n```\n\nCompilation results in producing `ErgoContract` that provides:\n\n- `ErgoTree` instance, Ergo's IR, which is used to define logical propositions protecting boxes (a generalization of coins) in the Ergo blockchain. Serialized ErgoTree expressions are written into UTXO boxes and then evaluated by the transaction verifier;\n- Scala anonymous function that when called with a `Context` parameter evaluates(reduces) the contract code to a sigma property. It allows us to \"call\" the contract code without loading up the interpreter.",
  "keywords": [
    "ergoscala",
    "compiler",
    "ergo",
    "contract",
    "subset",
    "scala",
    "compilation",
    "ergoplatform",
    "usage",
    "librarydependencie",
    "org.ergoplatform",
    "aaadbee1",
    "snapshot",
    "result",
    "ergocontract",
    "ergotree",
    "instance",
    "proposition",
    "generalization",
    "coin",
    "blockchain",
    "expression",
    "utxo",
    "transaction",
    "verifier",
    "function",
    "context",
    "parameter",
    "evaluates(reduce",
    "code",
    "sigma",
    "property",
    "interpreter",
    "example",
    "call",
    "ergoscalacompiler.contract",
    "import",
    "org.ergoplatform.compiler",
    "ergoscalacompiler",
    "amount",
    "buyer",
    "input",
    "buyercontract",
    "tokenid",
    "coll[byte",
    "tokenamount",
    "buyerpk",
    "sigmaprop",
    "compile",
    "library",
    "condition",
    "output",
    "register",
    "outputs.nonempty",
    "outputs(0).r4[coll[byte]].isdefined",
    "token",
    "tokens",
    "outputs(0).tokens",
    "tokens.nonempty",
    "tokens(0)._1",
    "tokens(0)._2",
    "self",
    "byte",
    "knownid",
    "self.id",
    "tokendatacorrect",
    "outputs(0).propositionbytes",
    "buyerpk.propbytes",
    "method",
    "verification",
    "stainless",
    "@param",
    "buyercontractinstance(tokenid",
    "buyer(context",
    "blob/63e494c9d33af25e23efea88d27f31742ad31f64",
    "assetsatomicexchange.scala#l150",
    "l157",
    "fund",
    "outputs",
    "assetsatomicexchange.scala#l24"
  ],
  "sections": [
    {
      "heading": "ErgoScala compiler",
      "content": "Compiler for Ergo smart contracts written in ErgoScala (a subset of Scala). Compilation from formally verified smart contracts from ergo-contracts is supported."
    },
    {
      "heading": "Usage",
      "content": "scala\nlibraryDependencies += \"org.ergoplatform\" %% \"ergo-scala-compiler\" % \"0.0.0-32-aaadbee1-SNAPSHOT\",\nCompilation results in producing ErgoContract that provides:\nErgoTree instance, Ergo's IR, which is used to define logical propositions protecting boxes (a generalization of coins) in the Ergo blockchain. Serialized ErgoTree expressions are written into UTXO boxes and then evaluated by the transaction verifier;\nScala anonymous function that when called with a Context parameter evaluates(reduces) the contract code to a sigma property. It allows us to \"call\" the contract code without loading up the interpreter."
    },
    {
      "heading": "Contract code in  contract call",
      "content": "Ergo contract code can be compiled with ErgoScalaCompiler.contract call:\n```scala\nimport org.ergoplatform.compiler.ErgoScalaCompiler\n// Define a function that takes token id, amount, and buyer's public key as input parameters and returns an ErgoContract.\ndef buyerContract(\n  tokenId: Coll[Byte],\n  tokenAmount: Long,\n  buyerPk: SigmaProp\n): ErgoContract =\n  ErgoScalaCompiler.contract { // Compile the contract using the ErgoScalaCompiler library.\n    // If the buyer's public key is valid, the contract can be spent without any additional conditions.\n    buyerPk || {\n      // Otherwise, some additional conditions must be met.\n      // Check if there are any outputs and the first output has a non-empty R4 register.\n      (OUTPUTS.nonEmpty && OUTPUTS(0).R4[Coll[Byte]].isDefined) && {\n        // Get the tokens of the first output and verify that the specified token id and amount are correct.\n        val tokens = OUTPUTS(0).tokens\n        val tokenDataCorrect = tokens.nonEmpty &&\n          tokens(0)._1 == tokenId &&\n          tokens(0)._2 >= tokenAmount\n// Check if the first output's R4 register matches the id of the current box (SELF) and its proposition bytes matches the buyer's public key.\n    val knownId = OUTPUTS(0).R4[Coll[Byte]].get == SELF.id\n    tokenDataCorrect && OUTPUTS(0).propositionBytes == buyerPk.propBytes && knownId\n  }\n}\n}\n```"
    },
    {
      "heading": "Verified contract code in a separate method call",
      "content": "For verified contracts, the compilation is done differently. Formal verification is done using Stainless in ergo-contracts. Verified contract code can be compiled by providing the method call where contract code resides.\n```scala\n/*\n * This function creates a new instance of the buyer contract, compiled with the provided parameters.\n * @param tokenId - the id of the token to be exchanged\n * @param tokenAmount - the amount of tokens to be exchanged\n * @param pkA - the public key of the buyer\n * @return a compiled instance of the buyer contract\n /\ndef buyerContractInstance(tokenId: Coll[Byte], tokenAmount: Long, pkA: SigmaProp): ErgoContract =\n  ErgoContractCompiler.compile { context: Context =>\n    buyer(context, tokenId, tokenAmount, pkA)\n  }\n```\nsee sources\nwhere buyer method holds verified smart contract:\n```scala\n/*\n  * Function that returns a SigmaProp indicating whether a buyer can spend the funds locked in a box.\n  * A buyer can spend the funds if either the buyerPk is provided, or if the OUTPUTS have a valid tokenData\n  * for the given tokenId and the box id is known.\n  *\n  * @param ctx The context where the function is being evaluated.\n  * @param tokenId The Coll[Byte] representing the token id.\n  * @param tokenAmount The amount of tokens needed.\n  * @param buyerPk The SigmaProp of the buyer.\n  * @return A SigmaProp indicating whether a buyer can spend the funds locked in a box.\n  /\ndef buyer(ctx: Context, tokenId: Coll[Byte], tokenAmount: Long, buyerPk: SigmaProp): SigmaProp = {\n  import ctx._\n  buyerPk || {\n    (OUTPUTS.nonEmpty && OUTPUTS(0).R4[Coll[Byte]].isDefined) && {\n      val tokens = OUTPUTS(0).tokens\n      val tokenDataCorrect = tokens.nonEmpty &&\n        tokens(0)._1 == tokenId &&\n        tokens(0)._2 >= tokenAmount\nval knownId = OUTPUTS(0).R4[Coll[Byte]].get == SELF.id\n  tokenDataCorrect &&\n  OUTPUTS(0).propositionBytes == buyerPk.propBytes &&\n  knownId\n}\n}\n}\n```\nsee sources"
    }
  ],
  "qa_pairs": []
}