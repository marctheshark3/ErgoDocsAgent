{
  "title": "Network Messages in Ergo's P2P Protocol",
  "source_url": "docs/dev/p2p/network.md",
  "summary": "---\ntags:\n  - P2P\n---\n\n# Network Messages in Ergo's P2P Protocol\n\nThis document provides a detailed overview of the network messages in Ergo's P2P protocol. Understanding these messages is crucial for interacting with the Ergo network at a low level. Each message in the protocol has a specific format and serves a unique purpose in the communication between nodes. ## Message Format Every message in the P2P protocol has the following format:\n\n| Data type         | Field name              | Details                                                                                                                      |  \n|:------------------|:------------------------|:-----------------------------------------------------------------------------------------------------------------------------|\n| byte\\[4\\]         | Magic bytes             |",
  "keywords": [
    "network",
    "messages",
    "ergo",
    "protocol",
    "document",
    "overview",
    "message",
    "level",
    "format",
    "purpose",
    "communication",
    "nodes",
    "data",
    "type",
    "field",
    "name",
    "detail",
    "|:------------------|:------------------------|:-----------------------------------------------------------------------------------------------------------------------------|",
    "byte\\[4\\",
    "magic",
    "byte",
    "mainnet",
    "testnet",
    "unsigned",
    "code",
    "body",
    "length",
    "zigzag",
    "encoding",
    "reason",
    "order",
    "handshake",
    "checksum",
    "first",
    "blake2b256(message",
    "byte\\[bodylength",
    "implementation",
    "node",
    "view",
    "synchronizer](https://github.com",
    "ergoplatform",
    "blob",
    "master",
    "scala",
    "ergonodeviewsynchronizer.scala",
    "repository",
    "records",
    "peer",
    "feature",
    "modifier",
    "header",
    "record",
    "details",
    "|:------------------------|:------------------------------|:------------------------------------------------------------------|",
    "utf-8",
    "string",
    "agent",
    "byte\\[3\\",
    "version",
    "example",
    "address",
    "value",
    "byte\\[iplength",
    "port",
    "count",
    "feature\\[featurecount\\",
    "|:-------------------|:-------------|",
    "|:---------------------|:-----------------|",
    "byte\\[32\\",
    "object",
    "|:-------------------|:----------------|",
    "bytes",
    "byte\\[length",
    "understanding",
    "serialization",
    "documentation](https://github.com",
    "core",
    "ergoserializer.scala",
    "mean",
    "peers",
    "sync",
    "info",
    "request",
    "response",
    "discovery",
    "|:------------------|:---------------|",
    "java",
    "getpeers",
    "ergonnection](https://github.com",
    "satergo",
    "ergonnection",
    "getpeers.java",
    "4.0.16",
    "old)](#sync",
    "sender",
    "blockchain",
    "recipient",
    "time",
    "datum",
    "block",
    "|:---------------------------------|:------------------------|",
    "|:--------------------------------|:---------------------------------|",
    "array",
    "inventory",
    "transaction",
    "reply",
    "info](#sync",
    "element",
    "byte\\[32\\]\\[elementcount\\",
    "invspec.scala](https://github.com",
    "invspec.scala",
    "memory",
    "pool",
    "database",
    "|:----------------------------------------------|:-------------------|",
    "record)\\[modifiercount\\",
    "tests",
    "1365](https://github.com",
    "issues/1365",
    "enhancement",
    "method",
    "proofs",
    "proof",
    "work",
    "nipopows",
    "test",
    "networking",
    "vector",
    "validation",
    "require",
    "check",
    "solution",
    "introduce",
    "syncinfo",
    "spec",
    "handling",
    "demo",
    "applications",
    "application",
    "generation",
    "addressgenerationdemo](https://github.com",
    "wallet",
    "addressgenerationdemo.java",
    "json",
    "printing",
    "createtransactiondemo.java",
    "print",
    "functionality",
    "resource",
    "here](https://gist.github.com",
    "satsen/5e7bcc38565ad193cf7d906a856f804e"
  ],
  "sections": [
    {
      "heading": "Network Messages in Ergo's P2P Protocol",
      "content": "This document provides a detailed overview of the network messages in Ergo's P2P protocol. Understanding these messages is crucial for interacting with the Ergo network at a low level. Each message in the protocol has a specific format and serves a unique purpose in the communication between nodes."
    },
    {
      "heading": "Message Format",
      "content": "Every message in the P2P protocol has the following format:\n| Data type         | Field name              | Details                                                                                                                      |\n|:------------------|:------------------------|:-----------------------------------------------------------------------------------------------------------------------------|\n| byte[4]         | Magic bytes             | For the mainnet, the magic bytes are {1, 0, 2, 4}. For testnet, {2, 0, 0, 1}.                                            |            \n| unsigned byte     | Message code            | One byte describing message type                                                                                             |\n| int               | Message body length     | No VLQ or ZigZag encoding is used for the message length (for historical reasons); bytes are coming in big-endian order. |\n| byte[4]         | Handshake body checksum | First four bytes of blake2b256(message body)                                                                                 |                                      \n| byte[bodyLength] | Message body            | Message body                                                                                                                 |\nFor more detailed implementation, you can check out the Ergo Node View Synchronizer in the Ergo repository."
    },
    {
      "heading": "Records",
      "content": "Records are structured data types used in the P2P protocol. They include Peer, Feature, Modifier, and Header records."
    },
    {
      "heading": "Peer",
      "content": "| Data type               | Field name                    | Details                                                           |\n|:------------------------|:------------------------------|:------------------------------------------------------------------|\n| unsigned byte           | Length of next field        |\n| UTF-8 String            | Agent name                    |\n| byte[3]               | Version                       | For example, {4, 0, 25}                                         |\n| unsigned byte           | Length of next field        |\n| UTF-8 String            | Peer name                     |\n| boolean                 | Whether public address exists |\n| (unsigned byte)         | Length of the IP plus 4   | When decoding, subtract the value with 4 to get the actual length |\n| (byte[ipLength - 4])  | The public IP address         |\n| (VLQ unsigned int)  | Port                          |\n| unsigned byte           | Count of peer features        |\n| Feature[featureCount] | Features                      |"
    },
    {
      "heading": "Feature",
      "content": "| Data type          | Field name   |\n|:-------------------|:-------------|\n| unsigned byte      | Feature code |\n| VLQ unsigned short | Body length  |\n| byte[bodyLength] | Body         |"
    },
    {
      "heading": "Modifier (Record)",
      "content": "| Data type            | Field name       |\n|:---------------------|:-----------------|\n| byte[32]           | Modifier ID      |\n| VLQ unsigned int     | Length of object |\n| byte[objectLength] | Object           |"
    },
    {
      "heading": "Header",
      "content": "| Data type          | Field name      |\n|:-------------------|:----------------|\n| VLQ unsigned short | Length of bytes |\n| byte[length]      | Bytes           |\nFor a deeper understanding of how records are serialized, check out the Ergo Serialization Documentation."
    },
    {
      "heading": "Messages",
      "content": "Messages are the primary means of communication between nodes in the P2P network. They include Get Peers, Peers, Sync Info, Inv, Request Modifier, and Modifier messages."
    },
    {
      "heading": "Get Peers",
      "content": "Code = 1\nThe body is empty."
    },
    {
      "heading": "Peers",
      "content": "Code = 2\nSent in response to Get Peers. Contains all the peers that are currently connected to. Used for node discovery.\n| Data type         | Field name     |\n|:------------------|:---------------|\n| VLQ ZZ int        | Count of peers |\n| Peer[] | Peers          |\nFor the Java implementation of the GetPeers message, refer to Ergonnection."
    },
    {
      "heading": "Sync Info",
      "content": "Code = 65\nNew (Added in 4.0.16)\nIt is sent only to nodes that report a version of 4.0.16 or higher. For older nodes, the Sync Info (old) is sent.\nRequests an Inv message that provides modifier IDs required by the sender to synchronize their blockchain with the recipient. It allows a peer which has been disconnected or started for the first time to get the data it needs to request the blocks it hasn't seen.\n| Data type                        | Field name              |\n|:---------------------------------|:------------------------|\n| VLQ unsigned short               | The constant value 0  |\n| byte                             | The constant value -1 |\n| unsigned byte                    | Count of headers        |\n| Header[headerCount] | Headers                 |"
    },
    {
      "heading": "Sync Info (old)",
      "content": "Code = 65\nThe old (before 4.0.16) version of the Sync Info message.\n| Data type                       | Field name                       |\n|:--------------------------------|:---------------------------------|\n| VLQ unsigned short              | Count of last header IDs         |\n| byte[32][lastHeaderIdCount] | Last header IDs (ID byte arrays) |"
    },
    {
      "heading": "Inv",
      "content": "Code = 55\nTransmits one or more inventories of objects known to the transmitting peer.\nIt can be sent unsolicited to announce new transactions or blocks, or it can be sent in reply to a Sync Info message.\n| Data type                  | Field name                |\n|:---------------------------|:--------------------------|\n| unsigned byte              | Type ID                   |\n| VLQ unsigned int           | Count of elements         |\n| byte[32][elementCount] | Elements (ID byte arrays) |\nFor an example of how INV messages are handled, see InvSpec.scala."
    },
    {
      "heading": "Request Modifier",
      "content": "Code = 22\nRequests one or more modifiers from another node. The objects are requested by an inventory, which the requesting node typically received previously with an Inv message.\nThis message cannot be used to request arbitrary data, such as historic transactions no longer in the memory pool. Full nodes may not even be able to provide older blocks if they've pruned old transactions from their block database.\nFor this reason, this message should usually only be used to request data from a node that previously advertised it had that data by sending an Inv message.\n| Data type                  | Field name                |\n|:---------------------------|:--------------------------|\n| unsigned byte              | Modifier type ID          |\n| VLQ unsigned int           | Count of elements         |\n| byte[32][elementCount] | Elements (ID byte arrays) |"
    },
    {
      "heading": "Modifier",
      "content": "Code = 33\nSent in response to Request Modifier.\n| Data type                                     | Field name         |\n|:----------------------------------------------|:-------------------|\n| unsigned byte                                 | Type ID            |\n| VLQ unsigned int                              | Count of modifiers |\n| Modifier[modifierCount] | Modifiers          |"
    },
    {
      "heading": "Pull Requests (PRs) & Tests",
      "content": "The NiPoPoW powered bootstrapping PR #1365 is a relevant enhancement that introduces a method to bootstrap nodes using Non-Interactive Proofs of Proof-of-Work (NiPoPoWs).\nTests for parsing networking messages against test vectors are discussed in PR #1264, which includes:\nEnhanced validation with require() for non-elidable checks.\nSimplified test vectors for invalid PoW solution validation and handshake parsing.\nIntroduced SyncInfo networking message parsing test (can be used as a simple spec).\nThese tests ensure robust handling of network messages in Ergo\u2019s P2P protocol."
    },
    {
      "heading": "Demo Applications",
      "content": "Demo applications are available for practical implementation, such as:\nAddress Generation: AddressGenerationDemo\nTransaction JSON Printing: CreateTransactionDemo\nThese demos provide examples of how to generate addresses and print transactions using the Ergo wallet functionalities."
    },
    {
      "heading": "Resources",
      "content": "A simple implementation of VLQ and ZigZag encoding can be found here.\nA complete implementation of the P2P protocol written in Java can be found in Ergonnection."
    }
  ],
  "qa_pairs": []
}