{
  "title": "Proxy contracts",
  "source_url": "docs/dev/wallet/payments/standards/eip17.md",
  "summary": "---\ntags:\n  - EIP\n---\n# Proxy contracts\n\n> \ud83d\udd17 From [EIP-0017](https://raw.githubusercontent.com/ergoplatform/eips/master/eip-0017.md) * Author: anon_real\n* Status: Proposed\n* Created: 05-May-2021\n* License: CC0\n* Forking: not needed \n\n\n\n## Motivation \n\nOutsourcing transaction generation to an external service/dApp can be useful or even needed in various circumstances. For example, avoiding wallet limitations to generate any transaction on behalf of the user - [Ergo Assembler](https://github.com/anon-real/ergo-assembler) is designed for this purpose. Another example is to scale dApps to be able to fulfill many requests without double-spending or data invalidation - SigmaUSD dApp can use proxy contracts to avoid bank double-spending and ERG/USD oracle data invalidation. ## Background\nThe idea of proxy contracts came to life with the [Ergo Assembler](https://github.com/anon-real/ergo-assembler) which helped dApp developments like [Ergo Auction House](https://ergoauctions.org/), [ErgoUtils](https://ergoutils.org/), and [SigmaUSD web interface](https://sigmausd.io/#/) despite not having a wallet-bridge like MetaMask (Ethereum wallet) in the ecosystem.",
  "keywords": [
    "proxy",
    "contract",
    "eip-0017](https://raw.githubusercontent.com",
    "ergoplatform",
    "master",
    "eip-0017.md",
    "author",
    "status",
    "may-2021",
    "license",
    "forking",
    "motivation",
    "outsourcing",
    "transaction",
    "generation",
    "service",
    "dapp",
    "circumstance",
    "example",
    "wallet",
    "limitation",
    "behalf",
    "user",
    "ergo",
    "assembler](https://github.com",
    "anon",
    "assembler",
    "purpose",
    "dapps",
    "request",
    "spending",
    "datum",
    "invalidation",
    "sigmausd",
    "bank",
    "oracle",
    "background",
    "idea",
    "life",
    "development",
    "auction",
    "house](https://ergoauctions.org/",
    "interface](https://sigmausd.io/#/",
    "bridge",
    "metamask",
    "ethereum",
    "ecosystem",
    "time",
    "structure",
    "advantage",
    "vulnerability",
    "dapp](https://sigmausd.io/#/",
    "beginning",
    "fund",
    "asset",
    "infrastructure",
    "activity",
    "violation",
    "whale",
    "interface",
    "developer",
    "period",
    "network",
    "reason",
    "sigusd",
    "sigrsv",
    "token",
    "holder",
    "devs",
    "attack",
    "integrity",
    "prevent",
    "attacker",
    "manner",
    "part",
    "properfundusage",
    "userout",
    "userout.propositionbyte",
    "recipient",
    "userout.tokens(0)._1",
    "frombase64(\"$sctokenid",
    "userout.tokens(0)._2",
    "scamountl",
    "amount",
    "height",
    "timestampl",
    "timestamp",
    "unix",
    "address",
    "everytime",
    "condition",
    "procedure",
    "uifeeok",
    "outputs(2).propositionbyte",
    "frombase64(\"$implementor",
    "outputs.size",
    "person",
    "properbank",
    "outputs(0).tokens(2)._1",
    "frombase64(\"$banknft",
    "protocol",
    "dappworksfine",
    "case",
    "returnfund",
    "inputs.fold(0l",
    "b.value",
    "refund",
    "outputs(0).value",
    "total",
    "outputs(0).propositionbyte",
    "pk(\"$assemblernodeaddr",
    "refundheightthreshold",
    "node",
    "block",
    "sigmaprop(dappworksfine",
    "operation",
    "compilation",
    "usage",
    "ensuring",
    "failure",
    "glance",
    "secret",
    "logic",
    "entity",
    "order",
    "execution",
    "problem",
    "perspective"
  ],
  "sections": [
    {
      "heading": "Proxy contracts",
      "content": "\ud83d\udd17 From EIP-0017\nAuthor: anon_real\nStatus: Proposed\nCreated: 05-May-2021\nLicense: CC0\nForking: not needed"
    },
    {
      "heading": "Motivation",
      "content": "Outsourcing transaction generation to an external service/dApp can be useful or even needed in various circumstances. For example, avoiding wallet limitations to generate any transaction on behalf of the user - Ergo Assembler is designed for this purpose. Another example is to scale dApps to be able to fulfill many requests without double-spending or data invalidation - SigmaUSD dApp can use proxy contracts to avoid bank double-spending and ERG/USD oracle data invalidation."
    },
    {
      "heading": "Background",
      "content": "The idea of proxy contracts came to life with the Ergo Assembler which helped dApp developments like Ergo Auction House, ErgoUtils, and SigmaUSD web interface despite not having a wallet-bridge like MetaMask (Ethereum wallet) in the ecosystem.\nDuring this time, the structure of proxy contracts evolved as some malicious users tried to take advantage of some minor vulnerabilities, mostly in the SigmaUSD dApp."
    },
    {
      "heading": "The structure",
      "content": "In the beginning, the sole purpose of proxy contracts was to protect users from losing their funds (not to be cheated) when they outsource their assets to engage with some dApp. While the initial structure succeeded to achieve this, it proved to be not sufficient for the whole dApp infrastructure to work without malicious activities. Some examples of dApp infrastructure violations are as follows:\nA malicious whale tried to take advantage of this simple structure by stealing UI fees from SigmaUSD web interface developers for some period of time. This happened because the proxy contracts were simply only trying to protect users from malicious activities, not the dApp infrastructure.\n\n\nThe same whale tried to prevent user's requests (minting/redeeming) from being executed by the assembler service by retuning their funds as soon as funds were broadcasted in the network. This happened also because of the same reasons.\n\n\nMoreover, the whale tried to sell SigUSD/SigRSV tokens to users by imitating the bank box. He succeeded to do that and take 2.25% fee for each request which was supposed to go to the SigRSV holders (2%) and UI devs (0.25%).\nThe above attacks were possible because proxy contracts were not designed to preserve the integrity of the whole dApp infrastructure but only the user's funds.\nGenerally, proxy contracts should be designed to:\nprevent dApp developers or any other attacker from taking advantage of user's funds in any manner\npreserve the integrity of the dApp by preventing attacks like the ones explained in the above examples.\nTo achieve all of the above, the below contract structure is proposed as an example:\n```scala\n{\n  // dApp-specific part ensuring that user will receive what he is paying for\n  val properFundUsage = {\n    val userOut = OUTPUTS(1)\n    userOut.propositionBytes == fromBase64(\"$userAddress\") && // user must be the recipient\n      userOut.tokens(0)._1 == fromBase64(\"$scTokenId\") && // user must receive SigmaUSD\n      userOut.tokens(0)._2..."
    }
  ],
  "qa_pairs": []
}