{
  "title": "Transaction Fees in Ergo",
  "source_url": "docs/dev/protocol/tx/min-fee.md",
  "summary": "---\ntags:\n  - Fees\n  - Transaction Fees\n---\n\n# Transaction Fees in Ergo\n\nEach Ergo [transaction](transactions.md) is an atomic state transition operation, involving the destruction of one or more [boxes](format.md) from the state and the creation of new ones. Unlike Bitcoin's implicit fee system, Ergo's fee structure is explicit, requiring a separate output to a specific address for fees. Ergo's transaction fee system is designed to be both flexible and explicit. While the protocol does not enforce a minimum transaction fee, transactions without a fee are less likely to be included in a block by miners.",
  "keywords": [
    "transaction",
    "fees",
    "ergo",
    "each",
    "transaction](transactions.md",
    "state",
    "transition",
    "operation",
    "destruction",
    "creation",
    "bitcoin",
    "system",
    "structure",
    "output",
    "address",
    "protocol",
    "block",
    "miner",
    "likelihood",
    "minimum",
    "value",
    "spam",
    "prevention",
    "strategy",
    "amount",
    "parameter",
    "size",
    "rule",
    "dust",
    "attack",
    "threshold",
    "nanoerg",
    "byte",
    "voting](governance.md",
    "guideline",
    "detail",
    "type",
    "info",
    "user",
    "other",
    "security",
    "measure",
    "control",
    "loss",
    "fund",
    "prioritization",
    "validation",
    "cost",
    "unit",
    "criterion",
    "voting",
    "mechanism",
    "miners](governance.md",
    "nodes",
    "metric",
    "node",
    "configuration](conf",
    "pool",
    "configuration",
    "mempool",
    "scheme",
    "byexecutioncost",
    "mempoolsorting",
    "propositionbytes",
    "register",
    "feeproposition",
    "method",
    "result",
    "basis",
    "special",
    "considerations",
    "standard",
    "incentive",
    "execution",
    "storage",
    "rent](rent",
    "collection",
    "contract](https://ergexplorer.com",
    "addresses#2ihkr7cwvd1r4j1yzg5bkedrqavjaavpetdfgglzduhyfwmuypmhhocx8gjoaietx78fntzjbcbvl6rf96ocjozdmwbl2fci7nqwgairpppqmz7fn9v6z13ay6brpribkyqlp1bt2fk4fkflcfdppe",
    "script",
    "reference",
    "implementation",
    "ergoscript",
    "contract",
    "ergotree",
    "scorexfoundation",
    "sigmastate",
    "interpreter",
    "blob",
    "f85f03cc8f063ae7f68d559371733c2b6bbc929a",
    "scala",
    "ergoplatform",
    "ergoscriptpredef.scala#l72",
    "proposition",
    "coin",
    "logarithm",
    "height",
    "delta",
    "feeproposition(delta",
    "byindex(outputs",
    "intconstant(0",
    "eq(height",
    "boxcreationheight(out",
    "eq(extractscriptbytes(out",
    "expectedmineroutscriptbytesval(delta",
    "minerpubkey",
    "eq(sizeof(outputs",
    "essence",
    "spending",
    "ergotransaction",
    "tx.output",
    "settings.chainsettings.monetary.feeproposition",
    ".map(_.value",
    "question",
    "design",
    "philosophy",
    "explicitness",
    "model",
    "aspect",
    "emission",
    "approach",
    "appropriate",
    "requirement",
    "practice",
    "ergotransaction.scala](https://github.com",
    "e784a70b8fabf7ae41f2ac9aa593a647f488100c",
    "modifier",
    "ergotransaction.scala#l163",
    "confirmation",
    "levels",
    "level",
    "network",
    "hashrate",
    "spend",
    "risk",
    "babel",
    "token",
    "sigmausd",
    "change",
    "recipient",
    "documentation](babel",
    "ergomixer",
    "ergomixe",
    "mixing",
    "management",
    "inclusion",
    "blockchain",
    "client",
    "guidance",
    "insight",
    "forum",
    "post](https://www.ergoforum.org",
    "zerojoin",
    "mixer",
    "tokens/318/10?u"
  ],
  "sections": [
    {
      "heading": "Transaction Fees in Ergo",
      "content": "Each Ergo transaction is an atomic state transition operation, involving the destruction of one or more boxes from the state and the creation of new ones. Unlike Bitcoin's implicit fee system, Ergo's fee structure is explicit, requiring a separate output to a specific address for fees.\nErgo's transaction fee system is designed to be both flexible and explicit. While the protocol does not enforce a minimum transaction fee, transactions without a fee are less likely to be included in a block by miners. Therefore, it is generally recommended to include a fee to incentivize miners to process your transaction. The larger the fee, the higher the likelihood of your transaction being included in a block and processed quickly."
    },
    {
      "heading": "Minimum Values",
      "content": "Although the protocol does not enforce a specific transaction fee, it employs a spam-prevention strategy that requires each box to contain a minimum amount of ERG. This minimum value is determined by a parameter voted on by miners and the size of the box. Every output box in a transaction must adhere to this rule. This strategy helps prevent the creation of dust in Ergo, thereby mitigating potential spam attacks.\nThis fee is calculated based on the serialized size of the boxes being created, with a minimum threshold set at 360 nanoerg per byte and is adjustable via miner voting. As a guideline, it is suggested to allocate 0.001 ERG (1,000,000 NanoErg) for each box involved in the transaction.\n/// details | Dust\n    {type: info, open: true}\nTo clarify, the Dust-prevention Fee is not an actual fee that users must pay to others (e.g., miners). Instead, it serves as a security measure for the box. If users avoid creating new boxes, the Dust-prevention Fee can be reused by transferring the same amount into a newly created single box. If the new box remains under your control, you can be assured that there will be no loss of funds.\n///"
    },
    {
      "heading": "Miner Transaction Prioritization",
      "content": "Miners prioritize transactions based on either the fee per byte or the validation cost unit. These criteria are adjustable via a voting mechanism among miners. Nodes can sort transactions based on these metrics, settable in the node configuration.\n```conf"
    },
    {
      "heading": "Mempool transaction sorting scheme (\"random\", \"bySize\", or \"byExecutionCost\")",
      "content": "mempoolSorting = \"random\"\n```\nWhen calculating the fee per byte or the fee per validation cost unit, miners initially filter out the fee boxes by checking the propositionBytes in the R1 register using the feeProposition method. Subsequently, they sum up the ERG value of these boxes. This sum is then divided by either the transaction's size or the total validation cost to yield a result. This final result serves as the basis for sorting transactions in the mempool.\n/// details | Special Considerations\n    {type: info, open: true}\nAlthough the minimal fee is a standard, miners can select transactions based on their economic incentives. This means transactions offering higher fees per byte or per execution unit are typically prioritized. However, miners may also choose to include their transactions above others when collecting storage rent.\n///"
    },
    {
      "heading": "Fee Collection",
      "content": "Transaction fees are secured in a contract, which can only be spent through a miner's script. The address used for fees is not fixed by the protocol but is a standard in the Ergo node reference implementation. The ErgoScript for this contract, implicitly defined in the ErgoTree, is detailed in this method.\n/**\n    * This proposition allows sending coins to a box protected by the following proposition:\n    * prove the discrete logarithm of the miner's public key and that the height is at least `delta` blocks greater than the current one.\n    */\n  def feeProposition(delta: Int = 720): ErgoTree = {\n    val out = ByIndex(Outputs, IntConstant(0))\n    AND(\n      EQ(Height, boxCreationHeight(out)),\n      EQ(ExtractScriptBytes(out), expectedMinerOutScriptBytesVal(delta, MinerPubkey)),\n      EQ(SizeOf(Outputs), 1)\n    ).toSigmaProp.treeWithSegregation\n  }\nIn essence, the fee script requires the spending transaction to have one output that pays to the miner's public key 720+ blocks later.\nAnd the method to extract the transaction fee method is as follows:\nprivate def extractFee(tx: ErgoTransaction): Long = {\n    tx.outputs\n      .filter(_.ergoTree == settings.chainSettings.monetary.feeProposition)\n      .map(_.value)\n      .sum\n  }\n/// details | Why is it like this?\n    {type: question, open: true}\nErgo's design philosophy emphasizes explicitness in its transactional model. This includes aspects such as emission, which is handled via a contract, and transaction fees. This approach simplifies the transactional model where possible.\n///"
    },
    {
      "heading": "Determining Appropriate Fees",
      "content": "The appropriate transaction fee must meet the protocol's minimum requirements, based on the box size. For best practices, see the ErgoTransaction.scala."
    },
    {
      "heading": "Confirmation Levels and Security",
      "content": "The recommended confirmation levels vary depending on the network hashrate. Higher hashrates reduce double-spend attack risks, thus requiring fewer confirmations."
    },
    {
      "heading": "Babel Fees",
      "content": "Babel Fees enable users to pay transaction fees using tokens like SigmaUSD instead of ERG. This involves creating a new box with Babel tokens as change. The necessary ERGs for the transaction recipient and the miner's fee are sourced from this Babel fee box. For more details, see Babel Fees documentation."
    },
    {
      "heading": "ErgoMixer",
      "content": "ErgoMixe offers token mixing and dynamic fee management for consistent transaction inclusion in blocks. It uses blockchain-stored parameters for client guidance, supporting transparent and flexible fee and token management. For more insights, see this forum post."
    }
  ],
  "qa_pairs": []
}