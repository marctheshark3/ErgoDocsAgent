{
  "title": "SigmaBoolean",
  "source_url": "docs/dev/scs/types/sigmaboolean.md",
  "summary": "# SigmaBoolean\n\nSigmaBoolean is a crucial data type in ErgoScript that represents propositions proven using Sigma protocols. It is derived from the base type [`ProveDlog`](global-functions.md#provedlog), which is used for discrete logarithm proofs. What sets SigmaBoolean apart is its dual functionality - it is used by the prover to construct the proof and by the verifier to check the proof. This dual role makes SigmaBoolean a key player in creating and verifying proofs within [ErgoScript](ergoscript.md). As an algebraic data type in SigmaScript and SigmaDsl, SigmaBoolean allows developers to use boolean-like logic when working with [Sigma Propositions](sigma-prop.md).",
  "keywords": [
    "sigmaboolean",
    "data",
    "type",
    "ergoscript",
    "proposition",
    "sigma",
    "protocol",
    "base",
    "functions.md#provedlog",
    "logarithm",
    "proof",
    "functionality",
    "prover",
    "verifier",
    "role",
    "player",
    "verifying",
    "ergoscript](ergoscript.md",
    "sigmascript",
    "sigmadsl",
    "developer",
    "logic",
    "propositions](sigma",
    "prop.md",
    "datum",
    "structure",
    "complexity",
    "process",
    "understanding",
    "expression",
    "trait",
    "identifier",
    "node",
    "class",
    "serialization",
    "opcode",
    "number",
    "tree",
    "size",
    "ergo",
    "category",
    "attribute",
    "behavior",
    "interaction",
    "opcodes`](lang",
    "ops.md#opcodes",
    "operation",
    "condition",
    "threshold",
    "provedlog",
    "provedhtuple",
    "requirement",
    "transaction",
    "method",
    "count",
    "estimate",
    "magnitude",
    "code",
    "scorexfoundation",
    "sigmastate",
    "interpreter",
    "blob",
    "develop",
    "scala",
    "values.scala#l745",
    "p2pk",
    "address",
    "key)](public",
    "keys.md",
    "knowledge",
    "contract",
    "privacy",
    "interoperability",
    "customize",
    "security",
    "audit",
    "compatibility",
    "step",
    "decode",
    "base58",
    "encoding",
    "extract",
    "public",
    "bytes",
    "byte",
    "0xcd",
    "0x03",
    "incorporate",
    "instruction",
    "08cd",
    "value",
    "bs58",
    "typescript",
    "const",
    "bs58.decode(ergoaddress",
    "rawbytes",
    "uint8array.from(decodedbuffer",
    "slicedbyte",
    "rawbytes.subarray(2",
    "rawbytes.length",
    "combinedbytes",
    "uint8array([0xcd",
    "buffer.from(combinedbytes).tostring('base64",
    "fleet",
    "fleet](fleet.md",
    "ergoaddress.frombase58(\"address_here\").getpublickeys()[0",
    "base64",
    "ergopay",
    "base64.encode(ssigmaprop(sgroupelement(pk)).tobytes",
    "ssigmaprop(sgroupelement(pk)).tohex",
    "ergotree",
    "transactions",
    "ergotree](ergotree.md",
    "spending",
    "0x00",
    "header",
    "formality",
    "creation",
    "construct",
    "flexibility",
    "design"
  ],
  "sections": [
    {
      "heading": "SigmaBoolean",
      "content": "SigmaBoolean is a crucial data type in ErgoScript that represents propositions proven using Sigma protocols. It is derived from the base type ProveDlog, which is used for discrete logarithm proofs. What sets SigmaBoolean apart is its dual functionality - it is used by the prover to construct the proof and by the verifier to check the proof. This dual role makes SigmaBoolean a key player in creating and verifying proofs within ErgoScript.\nAs an algebraic data type in SigmaScript and SigmaDsl, SigmaBoolean allows developers to use boolean-like logic when working with Sigma Propositions. It's worth noting that SigmaBoolean is a recursive data structure, which adds complexity to the parsing process."
    },
    {
      "heading": "Exploring SigmaBoolean Structure",
      "content": "To gain a deeper understanding of SigmaBoolean, let's examine its structure:\nscala\n/** SigmaBoolean represents the algebraic data type of sigma proposition expressions.\n * \n */\ntrait SigmaBoolean {\n  /** A unique identifier for the node class, used during serialization. */\n  val opCode: OpCode\n  /** Returns the number of nodes in the proposition tree, indicating its size. */\n  def size: Int\n}\nIn Ergo, a node class represents a specific type or category of nodes within the proposition tree. Each node class has unique attributes and behaviors that dictate its interactions with other nodes and contribute to the overall tree structure. These node classes are identified by their opCodes, which correspond to various logical operations or conditions within the proposition tree. These operations can include AND (&&), OR (||), and THRESHOLD, as well as conditions like proveDlog and proveDHtuple.\nBy strategically combining and arranging these node classes, developers can construct intricate proposition trees that define the conditions and requirements for validating Ergo transactions. To determine the size of the proposition tree, developers can use the size method, which counts the number of nodes in the tree. This count provides an estimate of the tree's complexity or magnitude.\nFor the complete code, refer to Values.scala."
    },
    {
      "heading": "Serializing SigmaBoolean from a P2PK Address",
      "content": "You may want to serialize a SigmaBoolean from a P2PK (Pay-to-Public-Key) address when you need to create a proof of knowledge for a specific public key. This process allows developers to create complex smart contracts. By encoding SigmaBoolean from a P2PK address, developers can define detailed contract conditions, improve privacy, ensure smooth interoperability, customize contract logic, enhance security audits, and support cross-platform compatibility.\nSerializing SigmaBoolean from a P2PK  address involves several steps:\nDecode P2PK Address: Begin by decoding the P2PK address using Base58 encoding.\n\n\nExtract Public Key Bytes: From the decoded data, remove the first byte, retain the last 4 bytes, and prepend it with 0xCD, 0x03.\n\n\nIncorporate Instruction Code: Integrate the ProveDlog instruction code with the public key bytes by prepending \"08cd\" to the bytes. This produces a serialized SigmaBoolean value."
    },
    {
      "heading": "Serialization with bs58 (TypeScript)",
      "content": "Alternatively, you can use bs58 for serialization in TypeScript:\ntypescript\nconst decodedBuffer = bs58.decode(ergoAddress);\nconst rawBytes = Uint8Array.from(decodedBuffer);\nconst slicedBytes = rawBytes.subarray(2, rawBytes.length - 4);\nconst combinedBytes = new Uint8Array([0xCD, 0x03, ...slicedBytes]);\nconst sigmaBoolean = Buffer.from(combinedBytes).toString('base64');"
    },
    {
      "heading": "Serialization using Fleet (TypeScript)",
      "content": "Here's how you can serialize SigmaBoolean using Fleet in TypeScript:\n```typescript\n// Extract the public key from the encoded address\nconst pk = ErgoAddress.fromBase58(\"address_here\").getPublicKeys()[0];\n// For base64 encoding (typically required for ergopay):\nconst encodedProp = base64.encode(SSigmaProp(SGroupElement(pk)).toBytes());\n// Without base64 encoding:\nconst encodedProp = SSigmaProp(SGroupElement(pk)).toHex();\n```"
    },
    {
      "heading": "ErgoTree and its Role in Transactions",
      "content": "The ErgoTree plays a vital role in Ergo transactions as it encompasses the spending conditions required for a box to be spent. To create an ErgoTree, it is necessary to prepend 0x00 (header byte) to the serialized SigmaBoolean. This step is not just a formality, but a crucial operation that enables the creation of intricate spending conditions. By supporting complex logical constructs, ErgoTree enhances the flexibility of contract design and strengthens the security of Ergo transactions."
    }
  ],
  "qa_pairs": []
}