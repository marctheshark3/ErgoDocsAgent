{
  "title": "Scala-Based ErgoScript Debugging",
  "source_url": "docs/dev/scs/debugging/scala-debugging.md",
  "summary": "---\ntags:\n  - Debugging\n  - ErgoScript\n  - Scala\n  - Testing\n  - sigmastate-interpreter\n  - Appkit\n---\n\n# Scala-Based ErgoScript Debugging\n\nSince ErgoScript is a subset of Scala and rigorously tested for equivalence within the [`sigmastate-interpreter`](https://github.com/ScorexFoundation/sigmastate-interpreter) repository, you can leverage standard Scala debugging tools and techniques to test and debug your contract logic off-chain. ## Concept\n\nThe core idea is to represent your ErgoScript contract logic as Scala code, typically within a testing environment like ScalaTest or JUnit, often using frameworks like [Appkit](scala.md) or the testing utilities within `sigmastate-interpreter` itself. This allows you to simulate the blockchain context (`Context`, `Box`, `Transaction`, etc.) and execute your contract logic within a standard JVM debugging environment. ## Process\n\n1. **Set up a Testing Environment:**\n    *   Use a project based on Appkit, which provides high-level abstractions for context and transaction building.",
  "keywords": [
    "ergoscript",
    "scala",
    "testing",
    "sigmastate",
    "interpreter",
    "appkit",
    "debugging",
    "subset",
    "equivalence",
    "interpreter`](https://github.com",
    "scorexfoundation",
    "repository",
    "debug",
    "tool",
    "technique",
    "contract",
    "logic",
    "chain",
    "idea",
    "code",
    "environment",
    "scalatest",
    "junit",
    "framework",
    "appkit](scala.md",
    "utility",
    "context",
    "transaction",
    "process",
    "project",
    "level",
    "abstraction",
    "building",
    "fork",
    "copy",
    "structure",
    "example",
    "represent",
    "function",
    "test",
    "case",
    "setup",
    "ergocontract",
    "compilation",
    "sigmabuilder",
    "simulate",
    "scenario",
    "populate",
    "input",
    "output",
    "register",
    "variable",
    "parameter",
    "height",
    "breakpoints",
    "intellij",
    "breakpoint",
    "mode",
    "debugger",
    "step",
    "through",
    "halt",
    "value",
    "datum",
    "line",
    "evaluate",
    "expression",
    "flow",
    "result",
    "assetsatomicexchange.scala](https://github.com",
    "blob",
    "develop",
    "utxo",
    "assetsatomicexchange.scala",
    "pattern",
    "proposition",
    "definition",
    "snippet",
    "assetsatomicexchange",
    "block",
    "buyerprop",
    "proposition(\"buyer",
    "import",
    "deadline",
    "tokendata",
    "outputs(0).r2[coll[(coll[byte",
    "long)]].get(0",
    "self",
    "knownid",
    "allof(coll",
    "tokendata._1",
    "tokenid",
    "tokendata._2",
    "pka.propbyte",
    "sellerprop",
    "locate",
    "method",
    "assetsatomicexchangetests.scala",
    "exchange",
    "spec",
    "property(\"atomic",
    "implementation",
    "detail",
    "class",
    "inspect",
    "execution",
    "state",
    "outputs",
    "evaluation",
    "deployment",
    "error"
  ],
  "sections": [
    {
      "heading": "Scala-Based ErgoScript Debugging",
      "content": "Since ErgoScript is a subset of Scala and rigorously tested for equivalence within the sigmastate-interpreter repository, you can leverage standard Scala debugging tools and techniques to test and debug your contract logic off-chain."
    },
    {
      "heading": "Concept",
      "content": "The core idea is to represent your ErgoScript contract logic as Scala code, typically within a testing environment like ScalaTest or JUnit, often using frameworks like Appkit or the testing utilities within sigmastate-interpreter itself. This allows you to simulate the blockchain context (Context, Box, Transaction, etc.) and execute your contract logic within a standard JVM debugging environment."
    },
    {
      "heading": "Process",
      "content": "Set up a Testing Environment:\nUse a project based on Appkit, which provides high-level abstractions for context and transaction building.\nAlternatively, work within a fork or local copy of the sigmastate-interpreter project, utilizing its internal testing structures and examples.\n\n\nRepresent Contract Logic:\nWrite your contract logic as Scala functions or within test case setups that mirror the ErgoScript structure. Appkit's ErgoContract compilation or direct use of SigmaBuilder can be employed.\n\n\nSimulate Context:\nCreate mock Context, Box, and Transaction objects representing the specific scenario you want to test. Populate input/output boxes, registers, context variables, and blockchain parameters (like HEIGHT) as needed.\n\n\nSet Breakpoints:\nUse your Scala IDE (e.g., IntelliJ IDEA) to set breakpoints within the Scala code representing your contract logic or the test setup code that invokes it.\n\n\nRun in Debug Mode:\nExecute the specific test case using the IDE's debugger.\n\n\nInspect and Step Through:\nWhen the debugger halts at a breakpoint, you can:\nInspect the values of variables (including simulated context data).\nStep through the code line by line.\nEvaluate expressions.\nValidate the logic flow and intermediate results."
    },
    {
      "heading": "Example Reference",
      "content": "The AssetsAtomicExchange.scala tests within the sigmastate-interpreter repository provide practical examples of this pattern. Breakpoints can be set within the proposition definitions (which contain Scala code mirroring ErgoScript), and the corresponding tests run in debug mode to step through the logic.\nscala\n// Snippet from AssetsAtomicExchange - Breakpoint can be set inside this block\nlazy val buyerProp = proposition(\"buyer\", { ctx: Context =>\n  import ctx._\n  (HEIGHT > deadline && pkA) || { // Breakpoint here\n    val tokenData = OUTPUTS(0).R2[Coll[(Coll[Byte], Long)]].get(0)\n    // ... inspect tokenData, OUTPUTS(0), SELF, etc. ...\n    val knownId = OUTPUTS(0).R4[Coll[Byte]].get == SELF.id\n    allOf(Coll(\n      tokenData._1 == tokenId,\n      tokenData._2 >= 60L,\n      OUTPUTS(0).propositionBytes == pkA.propBytes,\n      knownId\n    ))\n  }\n},\n// ..."
    },
    {
      "heading": "Debugging Process Example",
      "content": "Using the AssetsAtomicExchange.scala example:\nSet Breakpoint: Place a breakpoint within the buyerProp or sellerProp definition in AssetsAtomicExchange.scala (e.g., inside the || block as shown in the snippet above).\nLocate Test: Find the corresponding test method in AssetsAtomicExchangeTests.scala, such as property(\"atomic exchange spec\").\n    scala\n    // Test method for atomic exchange in AssetsAtomicExchangeTests.scala\n    property(\"atomic exchange spec\") {\n      // Test implementation details...\n      // This code sets up the context and attempts the transaction\n    }\nRun Test in Debug Mode: Right-click the specific test method (or the whole test class) in your IDE and select \"Debug\".\nInspect: The execution will pause at your breakpoint, allowing you to inspect the state of simulated context variables (ctx, HEIGHT, INPUTS, OUTPUTS, SELF), local variables (tokenData, knownId), and step through the contract logic evaluation.\nThis technique provides a powerful way to thoroughly verify contract logic before deployment, catching potential errors in a controlled off-chain environment."
    }
  ],
  "qa_pairs": []
}