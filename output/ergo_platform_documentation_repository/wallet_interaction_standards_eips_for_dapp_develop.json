{
  "title": "Wallet Interaction Standards (EIPs) for dApp Developers",
  "source_url": "docs/dev/wallet/eip-standards.md",
  "summary": "---\ntags:\n  - Wallets\n  - EIPs\n  - Standards\n  - dApp Connector\n  - EIP-0012\n  - EIP-0001\n  - EIP-0003\n  - get_used_addresses\n  - dApp Development\n  - Security\n  - Testing\n---\n\n# Wallet Interaction Standards (EIPs) for dApp Developers\n\nErgo Improvement Proposals (EIPs) define standards for interaction between dApps and wallets, ensuring a consistent and secure experience for users and developers. This page highlights key EIPs and expected behaviors relevant to dApp development, focusing primarily on EIP-0012 (dApp Connector). *(Note: This page is not a substitute for the full EIP specifications. Refer to the official [Ergo EIPs repository](https://github.com/ergoplatform/eips) for complete details. This aims to clarify common implementation points based on developer feedback.)",
  "keywords": [
    "wallet",
    "eips",
    "standards",
    "dapp",
    "connector",
    "eip-0012",
    "eip-0001",
    "eip-0003",
    "get_used_addresse",
    "development",
    "security",
    "testing",
    "interaction",
    "developers",
    "ergo",
    "improvement",
    "proposals",
    "standard",
    "dapps",
    "experience",
    "user",
    "developer",
    "page",
    "behavior",
    "substitute",
    "specification",
    "official",
    "ergoplatform",
    "detail",
    "implementation",
    "point",
    "feedback",
    "wallets",
    "nautilus",
    "wallet](nautilus.md",
    "browser",
    "extension",
    "mobile",
    "android",
    "note",
    "yoroi",
    "support",
    "option",
    "overview",
    "javascript",
    "interface",
    "context",
    "window.ergoconnector.ergo",
    "window.ergo",
    "connection",
    "function",
    "category",
    "functions",
    "ergoconnector",
    "address",
    "balance",
    "request",
    "signing",
    "object",
    "flow",
    "conceptual",
    "async",
    "connectwallet",
    "typeof",
    "ergoconnector.ergo",
    "console.error(\"ergo",
    "return",
    "null",
    "const",
    "isconnected",
    "console.log(\"wallet",
    "access",
    "prompt",
    "ergoconnector.ergo.connect",
    "reference",
    "state",
    "catch",
    "error",
    "console.error(\"error",
    "cancellation",
    "timeout",
    "usage",
    "ergocontext",
    "await",
    "ergocontext.get_used_addresse",
    "ergocontext.sign_tx",
    "examples",
    "expected",
    "purpose",
    "transaction",
    "fund",
    "empty",
    "array",
    "code",
    "case",
    "pagination",
    "supports",
    "number",
    "limit",
    "argument",
    "result",
    "handling",
    "session",
    "ergo.get_unused_addresse",
    "chain",
    "deposit",
    "ergo.get_balance(token_id",
    "token_id",
    "token",
    "eip-12",
    "structure",
    "rejection",
    "message",
    "submission",
    "network",
    "node",
    "handle",
    "spend",
    "inclusion",
    "block",
    "signature",
    "parameter",
    "type",
    "best",
    "practices",
    "minimal",
    "permissions",
    "sign",
    "permission",
    "intent",
    "sign_tx",
    "action",
    "clarity",
    "information",
    "input",
    "validation",
    "construction",
    "injection",
    "attack",
    "management",
    "call",
    "sensitive",
    "data",
    "store",
    "seed",
    "phrase",
    "considerations",
    "initiation",
    "method",
    "documentation",
    "screen",
    "recommendation",
    "integration",
    "platform",
    "desktop",
    "testnet",
    "datum",
    "fetching",
    "scenario",
    "mainnet",
    "edge",
    "cases",
    "test",
    "changes",
    "account",
    "common",
    "issue",
    "undefined",
    "enable",
    "rejected",
    "errors",
    "reject",
    "selection",
    "logic",
    "malformed",
    "unsignedtx",
    "spec",
    "submit_tx",
    "incorrect",
    "get_balance",
    "relevant",
    "allocation",
    "encoding](https://github.com",
    "blob",
    "master",
    "eip-0001.md",
    "format",
    "p2pk",
    "deterministic",
    "bip32",
    "bip44)](https://github.com",
    "eip-0003.md",
    "derivation",
    "path",
    "other",
    "eip-0004",
    "assets",
    "eip-0020",
    "ergopay",
    "eip-0027",
    "asset",
    "linking",
    "functionality",
    "example",
    "placeholder",
    "link",
    "source",
    "library",
    "spectrum",
    "fleet",
    "understanding"
  ],
  "sections": [
    {
      "heading": "Wallet Interaction Standards (EIPs) for dApp Developers",
      "content": "Ergo Improvement Proposals (EIPs) define standards for interaction between dApps and wallets, ensuring a consistent and secure experience for users and developers. This page highlights key EIPs and expected behaviors relevant to dApp development, focusing primarily on EIP-0012 (dApp Connector).\n(Note: This page is not a substitute for the full EIP specifications. Refer to the official Ergo EIPs repository for complete details. This aims to clarify common implementation points based on developer feedback.)"
    },
    {
      "heading": "Supported Wallets (EIP-0012)",
      "content": "Currently, the primary wallets implementing the EIP-0012 dApp Connector standard are:\nNautilus Wallet (Browser Extension)\nErgo Mobile Wallet (Android/iOS)\nNote: Yoroi Wallet's Ergo support is deprecated. Developers and users should utilize Nautilus or the official Ergo Mobile Wallet for dApp interactions. See the main Wallets page for more options."
    },
    {
      "heading": "EIP-0012: dApp Connector Overview",
      "content": "EIP-0012 defines a standard JavaScript interface injected into the dApp's web context by the wallet (usually as window.ergoConnector.ergo or just window.ergo after connection). It separates functions into two main categories:\nConnection API: Functions for establishing and managing the connection between the dApp and the wallet (e.g., connect, disconnect, check, isConnected). These are typically accessed via ergoConnector.\nContext API: Functions available after a connection is established, allowing the dApp to interact with the wallet's context (e.g., get addresses, balances, request signing). These are accessed via the ergo object obtained after successful connection."
    },
    {
      "heading": "Typical Connection Flow (Conceptual JS)",
      "content": "```javascript\nasync function connectWallet() {\n  // Check if the connector object exists (wallet extension installed)\n  if (typeof ergoConnector === 'undefined' || !ergoConnector.ergo) {\n    console.error(\"Ergo Wallet Connector not found. Please install Nautilus or use a compatible wallet.\");\n    // Optionally prompt user to install\n    return null;\n  }\ntry {\n    // Check if already connected\n    const isConnected = await ergoConnector.ergo.isConnected();\n    if (isConnected) {\n      console.log(\"Wallet already connected.\");\n      return ergo; // Return the existing context API object\n    }\n// Request read access (prompts user in wallet)\nconst granted = await ergoConnector.ergo.connect();\n\nif (!granted) {\n  console.log(\"Wallet connection request denied by user.\");\n  return null;\n} else {\n  console.log(\"Wallet connected successfully!\");\n  // 'ergo' object (Context API) is now available globally or via ergoConnector.ergo\n  // You might want to store this 'ergo' object reference in your dApp's state\n  return ergo; \n}\n} catch (error) {\n    console.error(\"Error connecting to wallet:\", error);\n    // Handle specific errors (e.g., user cancellation, timeouts)\n    return null;\n  }\n}\n// Usage:\n// const ergoContext = await connectWallet();\n// if (ergoContext) {\n//   // Now use ergoContext.get_used_addresses(), ergoContext.sign_tx(), etc.\n// }\n```"
    },
    {
      "heading": "Connection API Functions (Examples)",
      "content": "ergoConnector.ergo.connect(): Initiates the connection request. Returns true if access granted, false otherwise.\nergoConnector.ergo.disconnect(): Disconnects the dApp (if supported by the wallet).\nergoConnector.ergo.isConnected(): Checks if the dApp currently has read access without prompting the user."
    },
    {
      "heading": "Context API Functions (ergo.*) & Expected Behavior",
      "content": "(Available only after connect() returns true)\nergo.get_used_addresses(paging?):\nPurpose: Returns addresses involved in past transactions. Crucial for discovering user funds.\nReturn (Empty Wallet): MUST return [] (empty array) if no addresses have been used. Do not rely on error codes for this case, although older wallets might have thrown errors.\nPagination: Supports { page: number, limit: number } argument. Handle paginated results if expecting many addresses.\nError Handling: Catch potential errors (e.g., user session expired, wallet internal error).\n\n\nergo.get_unused_addresses():\nPurpose: Returns addresses generated but not yet seen on-chain. Useful for providing fresh deposit addresses.\nError Handling: Catch potential errors.\n\n\nergo.get_balance(token_id?):\nPurpose: Returns confirmed and unconfirmed balance for ERG (if token_id omitted) or a specific token.\nError Handling: Catch potential errors.\n\n\nergo.sign_tx(unsignedTx):\nPurpose: Sends an unsigned transaction (built according to EIP-12 structure) to the wallet for the user to review and sign.\nReturn: Returns the signed transaction if approved by the user.\nError Handling: Crucial to handle user rejection (often throws a specific error code/message), insufficient funds errors from the wallet's pre-check, or malformed transaction errors.\n\n\nergo.submit_tx(signedTx):\nPurpose: Sends a signed transaction to the wallet for submission to the network via the wallet's connected node.\nReturn: Returns the transaction ID upon successful submission.\nError Handling: Handle network errors, node rejection errors (e.g., double spends, invalid transaction), or wallet internal errors. Note that successful submission doesn't guarantee inclusion in a block.\n(Refer to the full EIP-0012 specification for exact function signatures, parameter/return types, and detailed error codes.)"
    },
    {
      "heading": "Security Best Practices",
      "content": "Request Minimal Permissions: Only request read access initially (connect). Don't request signing permissions upfront if not immediately needed.\nUser Intent: Ensure all signing requests (sign_tx) clearly correspond to an explicit user action within your dApp. Don't trigger signing requests unexpectedly.\nTransaction Clarity: Display the key details of any transaction clearly to the user before sending it to the wallet for signing. The wallet should also display this information, but providing context in the dApp is crucial.\nInput Validation: Sanitize and validate any user input used in transaction construction to prevent injection attacks or malformed requests.\nState Management: Securely manage the connection state within your dApp. Verify isConnected() before attempting Context API calls if needed.\nAvoid Storing Sensitive Data: Never ask for or store user private keys or seed phrases in your dApp. All signing happens within the wallet."
    },
    {
      "heading": "Mobile Considerations",
      "content": "Connection Initiation: The method for initiating a connection might differ slightly on mobile (e.g., via deeplinking or a dedicated browser within the mobile wallet app) compared to browser extensions. Check mobile wallet documentation.\nUser Experience: Ensure your dApp's UI is responsive and works well on mobile screens when interacting with the wallet interface."
    },
    {
      "heading": "Testing Recommendations",
      "content": "Multiple Wallets: Test your dApp integration with all supported wallets (Nautilus, Ergo Mobile Wallet) on different platforms (desktop, mobile).\nTestnet: Thoroughly test all connection flows, data fetching, and transaction signing/submission scenarios on the Ergo Testnet before deploying to Mainnet.\nEdge Cases: Test user cancellation flows (rejecting connection, rejecting signing), network errors, insufficient funds, and handling of empty/new wallets.\nWallet State Changes: Test how your dApp handles the user switching accounts or disconnecting the wallet while the dApp is active."
    },
    {
      "heading": "Troubleshooting Common Issues",
      "content": "ergoConnector Undefined: Wallet extension is not installed, not enabled, or not injecting the connector object correctly. Prompt user to install/enable.\nConnection Rejected: User explicitly denied the connection request in the wallet prompt. Handle gracefully.\nsign_tx Errors:\nUser rejected the signature: Catch the specific error thrown by the wallet.\nInsufficient funds: Wallet might pre-check and reject. Ensure input selection logic is correct.\nMalformed transaction: Double-check the structure of the unsignedTx object against EIP-12 specs.\n\n\nsubmit_tx Errors: Network issues, node errors (transaction invalid), or wallet unable to connect to its node. Provide feedback to the user; they might need to check their wallet's network connection.\nIncorrect Data (get_used_addresses, get_balance): Ensure the wallet is fully synced. Check for pagination issues with get_used_addresses."
    },
    {
      "heading": "Other Relevant EIPs",
      "content": "EIP-0001: Ergo Address Allocation and Encoding: Defines the standard address formats (P2PK, P2S).\nEIP-0003: Deterministic Wallet Standard (BIP32/BIP44): Defines derivation paths for hierarchical deterministic (HD) wallets.\n(Others like EIP-0004 (Assets), EIP-0020 (ErgoPay), EIP-0027 (Asset Linking) may also be relevant depending on dApp functionality)."
    },
    {
      "heading": "Example Implementations",
      "content": "(Placeholder: Link to well-known open-source dApps or libraries demonstrating good EIP-0012 integration, e.g., Spectrum UI, Nautilus examples, Fleet examples, if available).\nBy understanding and correctly implementing these standards, particularly EIP-0012, dApps can provide a smoother, more secure, and reliable interaction experience across different Ergo wallets."
    }
  ],
  "qa_pairs": []
}