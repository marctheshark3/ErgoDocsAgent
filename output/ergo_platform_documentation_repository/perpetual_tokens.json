{
  "title": "Perpetual Tokens",
  "source_url": "docs/dev/tokens/perpetual.md",
  "summary": "# Perpetual Tokens\n\nErgoScript allows the creation of a '*perpetual token*', a token that is designed to exist indefinitely, unless it is removed by garbage collection. ```scala\n    {\n      val isPerpetual = {(b: Box) =>\n        b.propositionBytes == SELF.propositionBytes && b.tokens == SELF.tokens\n      }\n\n      sigmaProp(OUTPUTS.exists(isPerpetual))\n    }\n```\nThis code snippet ensures the persistence of a collection of perpetual tokens, even if the collection's size is zero. If you protect a single token using this script, it guarantees that the token will only be removed by garbage collection. For a comprehensive discussion, refer to [this thread](https://www.ergoforum.org/t/a-perpetual-token/205/3). ## Multi-Stage Protocols\n\nMulti-stage protocols are beneficial in situations where multiple scripts need to interact.",
  "keywords": [
    "perpetual",
    "tokens",
    "ergoscript",
    "creation",
    "token",
    "garbage",
    "collection",
    "b.propositionbytes",
    "self.propositionbytes",
    "b.tokens",
    "self.token",
    "sigmaprop(outputs.exists(isperpetual",
    "code",
    "snippet",
    "persistence",
    "size",
    "script",
    "discussion",
    "thread](https://www.ergoforum.org",
    "token/205/3",
    "multi",
    "stage",
    "protocols",
    "protocol",
    "situation",
    "instance",
    "example",
    "script1",
    "statement",
    "hash(outputs(0).propositionbyte",
    "script2hash",
    "verifie",
    "hash",
    "output",
    "propositionbytes",
    "script2",
    "script1hash",
    "reference",
    "problem",
    "register",
    "box](box.md",
    "hash(self.propositionbyte",
    "vanilla",
    "block",
    "flexibility",
    "power",
    "design",
    "pattern"
  ],
  "sections": [
    {
      "heading": "Perpetual Tokens",
      "content": "ErgoScript allows the creation of a 'perpetual token', a token that is designed to exist indefinitely, unless it is removed by garbage collection.\n```scala\n    {\n      val isPerpetual = {(b: Box) =>\n        b.propositionBytes == SELF.propositionBytes && b.tokens == SELF.tokens\n      }\nsigmaProp(OUTPUTS.exists(isPerpetual))\n}\n```\nThis code snippet ensures the persistence of a collection of perpetual tokens, even if the collection's size is zero. If you protect a single token using this script, it guarantees that the token will only be removed by garbage collection.\nFor a comprehensive discussion, refer to this thread."
    },
    {
      "heading": "Multi-Stage Protocols",
      "content": "Multi-stage protocols are beneficial in situations where multiple scripts need to interact. In these protocols, a script can reference the script of a subsequent stage.\nFor instance, consider the following example:\nIn script1, we have the statement:\nscala\nhash(OUTPUTS(0).propositionBytes) == script2Hash\nHere, script1 verifies if the hash of the first output's propositionBytes matches the hash of script2.\nBut, if we want script2 to refer back to script1, as shown below:\nscala\nhash(OUTPUTS(0).propositionBytes) == script1Hash\nWe face a cyclic reference problem, as both scripts are referencing each other.\nTo overcome this, we can store script1Hash in a register of the box that contains script2. We also need to modify script1 to ensure that the corresponding register of any box containing script2 equals hash(SELF.propositionBytes).\nWhile the \"vanilla\" perpetual token is intriguing, the \"max-once-per-block-use\" perpetual token offers more flexibility and power, and should be considered as a distinct design pattern."
    }
  ],
  "qa_pairs": []
}