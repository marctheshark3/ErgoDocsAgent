{
  "title": "ErgoTree Evaluation",
  "source_url": "docs/dev/scs/ergotree/evaluation.md",
  "summary": "# ErgoTree Evaluation\n$$\n\\newcommand{\\TEnv}{\\Gamma}\n\\newcommand{\\Der}[2]{#1~\\vdash~#2}\n\\newcommand{\\DerV}[2]{#1~\\vdash^{\\text{\\lst{v}}}~#2}\n\\newcommand{\\DerC}[2]{#1~\\vdash^{\\text{\\lst{c}}}~#2}\n\\newcommand{\\DerEnv}[1]{\\Der{\\TEnv}{#1}}\n\\newcommand{\\DerEnvV}[1]{\\DerV{\\TEnv}{#1}}\n\\newcommand{\\DerEnvC}[1]{\\DerC{\\TEnv}{#1}}\n\\newcommand{\\lst}[1]{#1}\n\\newcommand{\\Tup}[1]{(#1)}\n\\newcommand{\\Apply}[2]{#1\\langle#2\\rangle}\n\\newcommand{\\MSig}[3]{\\text{def}~#1(#2): #3}\n\\newcommand{\\Ov}[1]{\\overline{#1}}\n\\newcommand{\\TyLam}[3]{\\lambda(\\Ov{#1:#2}).#3}\n\\newcommand{\\Trait}[2]{\\text{trait}~#1~\\{ #2 \\}}\n\\newcommand{\\To}{\\mapsto}\n\\newcommand{\\Low}[1]{\\mathcal{L}{[\\![#1]\\!]}}\n\\newcommand{\\Lam}[2]{\\lambda#1.#2}\n\\newcommand{\\IfThenElse}[3]{\\text{if}~(#1)~#2~\\text{else}~#3}\n\\newcommand{\\False}{\\text{false}}\n\\newcommand{\\True}{\\text{true}}\n\\newcommand{\\langname}{ErgoTree}\n\\newcommand{\\corelang}{Core-\\lambda}\n\\newcommand{\\Denot}[1]{[\\![#1]\\!]}  \n$$\n\n\nEvaluation of $\\langname$ is specified by its translation to $\\corelang$, whose terms form a subset of $\\langname$ terms. Thus, typing rules of $\\corelang$ form a subset of typing rules of $\\langname$.\n\nHere we specify evaluation semantics of $\\corelang$, which is based on call-by-value (CBV) lambda calculus. Evaluation of $\\corelang$ is specified using denotational semantics. To do that, we first specify denotations of types, then typed terms and then equations of denotational semantics. /// details | Definition 1\n    {type: note, open: true}\n\n**The following $\\corelang$ terms are called values:**\n\n$$V :== x \\mid C(d, T) \\mid \\Lam{x}{M}$$\n\nAll $\\corelang$ terms are called ***producers***.",
  "keywords": [
    "ergotree",
    "evaluation",
    "\\newcommand{\\tenv}{\\gamma",
    "\\newcommand{\\der}[2]{#1~\\vdash~#2",
    "\\newcommand{\\derenv}[1]{\\der{\\tenv}{#1",
    "\\newcommand{\\derenvv}[1]{\\derv{\\tenv}{#1",
    "\\newcommand{\\derenvc}[1]{\\derc{\\tenv}{#1",
    "\\newcommand{\\lst}[1]{#1",
    "\\newcommand{\\tup}[1]{(#1",
    "\\newcommand{\\msig}[3]{\\text{def}~#1(#2",
    "\\newcommand{\\ov}[1]{\\overline{#1",
    "\\newcommand{\\tylam}[3]{\\lambda(\\ov{#1:#2}).#3",
    "\\newcommand{\\low}[1]{\\mathcal{l}{[\\![#1]\\",
    "\\newcommand{\\lam}[2]{\\lambda#1.#2",
    "\\newcommand{\\ifthenelse}[3]{\\text{if}~(#1)~#2~\\text{else}~#3",
    "\\newcommand{\\false}{\\text{false",
    "\\newcommand{\\true}{\\text{true",
    "\\newcommand{\\langname}{ergotree",
    "\\langname$",
    "translation",
    "term",
    "subset",
    "rule",
    "\\corelang$",
    "form",
    "\\langname$.",
    "semantic",
    "call",
    "value",
    "lambda",
    "calculus",
    "denotation",
    "type",
    "equation",
    "detail",
    "definition",
    "note",
    "\\lam{x}{m}$$",
    "producer",
    "language",
    "principle",
    "\\denot{a}$",
    "element",
    "\\lst{boolean}$](types.md#boolean",
    "t_1,\\dot",
    "t_n)$",
    "denote",
    "\\denot{t_1},\\dots,\\denot{t_n})$",
    "v_1,\\dots",
    "v_n)$",
    "v_i$",
    "t_i$.",
    "\\denot{v}$",
    "\\denot{m}$",
    "\\denot{a}$.",
    "\\lam{x}{m}$.",
    "\\denot{b}$.",
    "syntax",
    "\\lam{x}{m}$",
    "context",
    "sequence",
    "identifier",
    "valuetype",
    "\\dot",
    "list",
    "\\gamma",
    "a_1,\\dot",
    "a_n$",
    "environment",
    "binding",
    "associate",
    "a_i$.",
    "\\denot{a_1},\\dots,\\denot{a_n})$",
    "\\denot{\\gamma}$",
    "\\derenv{m",
    "function",
    "summary",
    "\\denot{\\gamma",
    "\\denot{b}$",
    "\\lst{true",
    "\\lst{false",
    "\\}$$",
    "\\text{see",
    "appendix",
    "a}$$",
    "\\denot{(t_1,\\dot",
    "\\denot{t_1},\\dots,\\denot{t_n",
    "\\denot{a",
    "\\denot{b}$$",
    "\\denot{\\",
    "\\denot{t}$",
    "\\apply",
    "\\denot{\\lst{x",
    "\\rho,\\lst{x}\\mapsto",
    "\\rho",
    "\\denot{c(d",
    "\\denot{(\\ov{m_i",
    "\\apply{\\denot{m_i}}{\\rho",
    "\\denot{\\apply{\\delta}{n",
    "\\apply{\\denot{\\delta}}{\\rho",
    "~where",
    "\\denot{\\lam{\\lst{x}}{m",
    "\\lam{x",
    "\\lst{x}\\mapsto",
    "\\denot{\\apply{m_f}{n",
    "\\apply{\\denot{m_f}}{\\rho",
    "\\ov{v_i"
  ],
  "sections": [
    {
      "heading": "ErgoTree Evaluation",
      "content": "$$\n\\newcommand{\\TEnv}{\\Gamma}\n\\newcommand{\\Der}[2]{#1~\\vdash~#2}\n\\newcommand{\\DerV}[2]{#1~\\vdash^{\\text{\\lst{v}}}~#2}\n\\newcommand{\\DerC}[2]{#1~\\vdash^{\\text{\\lst{c}}}~#2}\n\\newcommand{\\DerEnv}[1]{\\Der{\\TEnv}{#1}}\n\\newcommand{\\DerEnvV}[1]{\\DerV{\\TEnv}{#1}}\n\\newcommand{\\DerEnvC}[1]{\\DerC{\\TEnv}{#1}}\n\\newcommand{\\lst}[1]{#1}\n\\newcommand{\\Tup}[1]{(#1)}\n\\newcommand{\\Apply}[2]{#1\\langle#2\\rangle}\n\\newcommand{\\MSig}[3]{\\text{def}~#1(#2): #3}\n\\newcommand{\\Ov}[1]{\\overline{#1}}\n\\newcommand{\\TyLam}[3]{\\lambda(\\Ov{#1:#2}).#3}\n\\newcommand{\\Trait}[2]{\\text{trait}~#1~{ #2 }}\n\\newcommand{\\To}{\\mapsto}\n\\newcommand{\\Low}[1]{\\mathcal{L}{[![#1]!]}}\n\\newcommand{\\Lam}[2]{\\lambda#1.#2}\n\\newcommand{\\IfThenElse}[3]{\\text{if}~(#1)~#2~\\text{else}~#3}\n\\newcommand{\\False}{\\text{false}}\n\\newcommand{\\True}{\\text{true}}\n\\newcommand{\\langname}{ErgoTree}\n\\newcommand{\\corelang}{Core-\\lambda}\n\\newcommand{\\Denot}[1]{[![#1]!]}\n$$\nEvaluation of $\\langname$ is specified by its translation to $\\corelang$, whose terms form a subset of $\\langname$ terms. Thus, typing rules of $\\corelang$ form a subset of typing rules of $\\langname$.\nHere we specify evaluation semantics of $\\corelang$, which is based on call-by-value (CBV) lambda calculus. Evaluation of $\\corelang$ is specified using denotational semantics. To do that, we first specify denotations of types, then typed terms and then equations of denotational semantics.\n/// details | Definition 1\n    {type: note, open: true}\nThe following $\\corelang$ terms are called values:\n$$V :== x \\mid C(d, T) \\mid \\Lam{x}{M}$$\nAll $\\corelang$ terms are called producers. (This is because, when evaluated, they produce a value.)\n///\nWe now describe and explain a denotational semantics for the $\\corelang$ language. The key principle is that each type $A$ denotes a set $\\Denot{A}$ whose elements are the denotations of values of the type $A$.\nThus the type $\\lst{Boolean}$ denotes the 2-element set ${\\lst{true},\\lst{false}}$, because there are two values of type $\\lst{Boolean}$...."
    }
  ],
  "qa_pairs": []
}