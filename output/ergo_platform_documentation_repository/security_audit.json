{
  "title": "Security Audit",
  "source_url": "docs/dev/protocol/audit.md",
  "summary": "---\ntags:\n  - Security\n  - Audit\n---\n\n# Security Audit\n\nErgo has successfully passed a security audit of certain (most critical) parts of the code. The audit was performed by Jean-Philipee Aumasson (aka veorq, [aumasson.jp/](https://aumasson.jp/)). The detailed report is below. Nothing critical is found. Comments on issues found:\n\n1.",
  "keywords": [
    "security",
    "audit",
    "ergo",
    "part",
    "code",
    "jean",
    "philipee",
    "aumasson",
    "aumasson.jp/](https://aumasson.jp/",
    "report",
    "comment",
    "issue",
    "wallet",
    "password",
    "recommendation",
    "version",
    "protocol",
    "client",
    "enforcement",
    "place",
    "consultation",
    "parameter",
    "sense",
    "network",
    "mining",
    "node",
    "block",
    "fork",
    "participant",
    "need",
    "check",
    "people",
    "library",
    "side",
    "channel",
    "attack",
    "memory",
    "inspection",
    "malware",
    "virus",
    "machine",
    "assessment",
    "philippe",
    "dec/19",
    "summary",
    "component",
    "platform",
    "sigma",
    "proof",
    "creation",
    "verification",
    "storage",
    "secret",
    "work",
    "validation",
    "finding",
    "\u200bthe",
    "ergoscript",
    "scripting",
    "language",
    "statement",
    "knowledge",
    "tree",
    "threshold",
    "condition",
    "leave",
    "logarithm",
    "problem",
    "thank",
    "fiat",
    "shamir",
    "transform",
    "logic",
    "paper](https://ergoplatform.org",
    "ergoscript.pdf",
    "proving",
    "routine",
    "appendix",
    "\u200bimplementation",
    "challenge",
    "encoding",
    "serialisation",
    "deserialisation",
    "input",
    "functionality",
    "compliance",
    "specification",
    "aspect",
    "repository",
    "sigmastate",
    "scorexfoundation",
    "interpreter",
    "behaviour",
    "sigserializer](https://github.com",
    "blob",
    "master",
    "scala",
    "sigserializer.scala",
    "interpreter](https://github.com",
    "interpreter.scala",
    "proverinterpreter.scala",
    "trait",
    "object",
    "class",
    "processing",
    "behavior",
    "depth",
    "recursion",
    "level",
    "type",
    "structure",
    "integer",
    "race",
    "review",
    "internal",
    "risk",
    "verifying",
    "attacker",
    "script",
    "software",
    "error",
    "user",
    "disk",
    "seed",
    "ergowalletactor](https://github.com",
    "ergoplatform",
    "nodeview",
    "ergowalletactor.scala",
    "jsonsecretstorage](https://github.com",
    "jsonsecretstorage.scala",
    "time",
    "initwallet",
    "command",
    "following",
    "generate",
    "settings.walletsettings.seedstrengthbit",
    "entropy",
    "default](https://github.com",
    "resource",
    "bip39",
    "mnemonic",
    "pbkdf2",
    "derivation",
    "nonce",
    "derive",
    "hmac",
    "sha256",
    "128000](https://github.com",
    "test",
    "iteration",
    "salt",
    "datum",
    "process",
    "initialisation",
    "account",
    "passphrase",
    "absence",
    "length",
    "theory",
    "practice",
    "example",
    "character",
    "copy",
    "value",
    "execution",
    "limitation",
    "garbage",
    "address",
    "space",
    "crash",
    "dump",
    "mitigation",
    "\u200bafter",
    "autolykos",
    "round",
    "change",
    "commit",
    "eb0f85a](https://github.com",
    "eb0f85ac48b0ee8194c12369faf4cc5f16954af9",
    "file",
    "autolykospowscheme](https://github.com",
    "autolykospowscheme.scala",
    "operation",
    "headersprocessor](https://github.com",
    "history",
    "modifierprocessor",
    "headersprocessor.scala",
    "modifiervalidator](https://github.com",
    "scorex",
    "core",
    "modifiervalidator.scala",
    "header",
    "point",
    "number",
    "element",
    "solution",
    "n<31",
    "log2",
    "validate",
    "function",
    "assert"
  ],
  "sections": [
    {
      "heading": "Security Audit",
      "content": "Ergo has successfully passed a security audit of certain (most critical) parts of the code. The audit was performed by Jean-Philipee Aumasson (aka veorq, aumasson.jp/).\nThe detailed report is below. Nothing critical is found. Comments on issues found:\nOn wallet password, we'll provide a recommendation in subsequent versions of the protocol client. Not sure hard enforcement on passwords will take place, but we'll do more consultations on this.\n\n\nChanging \"n\" and \"k\" parameters makes sense only when launching a new network. Changing these parameters in the mining node will make blocks produced invalid for other nodes. Changing these parameters in the protocol client means going on another fork (blocks coming from the honest protocol participants will be rejected). So no need for extra checks, as people launching new networks will set \"n\" and \"k\" properly.\n\n\nCurrently, the Ergo node (as well as other blockchain protocol clients and wallets we're aware of and the cryptographic libraries we're using) does not protect from side-channel attacks running locally (e.g. timing attacks or memory inspection by malware or viruses). So please protect the machines you're running wallets on!\nErgo security assessment by Jean-Philippe Aumasson on 07/Dec/19"
    },
    {
      "heading": "Summary",
      "content": "Ergo solicited us to perform a security assessment of several components of their Ergo Platform:\nSigma protocol proofs creation and verification\nWallet's secure storage of secrets\nProof-of-Work validation\n\u200bThis brief report summarises our assessment and describes our findings and mitigation recommendations."
    },
    {
      "heading": "Sigma protocol proofs",
      "content": "\u200bThe Ergo protocol relies on ErgoScript, a scripting language supporting sigma-statements, which can be proven and verified through non-interactive proofs of knowledge.\nThese proofs are statements described as a tree of AND, OR, and threshold conditions, whose leaves are proofs of knowledge of a discrete logarithm problem.\nThe proof of the sigma-statement is then made non-interactive thanks to the Fiat-Shamir transform.\nThis logic is specified in the ErgoScript paper, and the specific\nproving and verification routines described in Appendix A.\n\u200bImplementation challenges are then to:\nDefine encoding of the proofs that are safe and efficient, and implement serialisation and deserialisation that always successfully processes valid input and gracefully fails to process invalid input.\n\n\nImplement the proving and verification functionalities correctly, in compliance with the specification, and most importantly, no invalid statement can successfully pass verification.\nWe reviewed these two aspects, based on the code in the repository sigmastate-interpreter, and the ErgoScript paper, carefully comparing the intended behaviour (in Appendix A) with the actual behaviour as implemented.\n\u200bWe notably reviewed code from the SigSerializer, Interpreter, and ProverInterpreter traits and objects.\n\u200bWe mainly sought bugs from the following classes:\n\u200bUnsafe processing of malformed input\nUnsafe processing of unusually long or short input\nBehavior when large tree depth or recursion level\nUnsafe use Scala types and structures\nInappropriate variable types\nInteger overflows\nRace conditions\nLogic bugs\n\u200bDespite the extensive review, we did not identify any security issue.\nThe protocol's logic and internals are relatively complex, and we believe the highest risk is in parsing and verifying proofs. To exploit such issues, however, an attacker would have to create a semantically correct script that somehow benefits them yet that passes verification when it does not ought to.\nRegarding software secu..."
    },
    {
      "heading": "Wallet",
      "content": "Ergo's wallet functionality enables its users to store a secret on disk and recover it, initialising the wallet with a new seed when it's first used.\n\u200bThis logic is mainly defined in ErgoWalletActor, and a key component regarding secrets' storage is JsonSecretStorage.\n\u200bThe first time a wallet is created, the InitWallet command does the following:\nGenerate settings.walletSettings.seedStrengthBits random bits, as initial entropy. By default, 160 bits are generated.\n\n\nGenerate a BIP39 from the random bits generated, which can be seen as encoding the entropy bits. The standard BIP39 logic is used with an optional password.\n\n\nDerive a seed from the mnemonic using BIP39's PBKDF2-based derivation logic.\n\n\nEncrypt this seed to disk with AES-GCM, using a random nonce, and a key derives from the password using PBKDF2-HMAC-SHA256 with 128000 iterations, using a random salt.\nTo unlock a wallet already created, a user provides the password and the wallet attempts to decrypt the stored data.\n\u200bA similar process as initialisation is performed to restore an existing account from a BIP39 passphrase, except that the wallet will derive the seed from the mnemonic instead of picking a random mnemonic.\n\u200bThe two risks we identified here are:\nThe absence of checks on the password's length: since the password is sufficient to access the seed given the wallet's on-disk stored secret, the password should, in theory, have at least as much entropy as the mnemonic, and in practice, should be practically hard to crack. We thus recommend enforcing a minimal password length, for example of 16 characters.\n\n\nCopies of secret values (password, seed, and derive private keys) are likely to remain in memory after wallet software execution, an intrinsic limitation of garbage-collected languages such as Scala.\nAnother process or user sharing the same memory address space could potentially recover the secrets, and they could also appear in crash dumps. To the best of our knowledge, there is no effective miti..."
    },
    {
      "heading": "PoW validation",
      "content": "\u200bAfter previously reviewing the security of the Autolykos PoW, we performed another round of review focusing on its latest verification logic, and notably, the changes in the commit eb0f85a.\n\u200bThe main relevant file is AutolykosPowScheme, and other important operations are for example implemented in\nHeadersProcessor and ModifierValidator.\n\u200bWe checked that the implemented verification logic is consistent with that specified in the Autolykos specifications and that it is appropriately integrated into the block header validation logic.\n\u200bWe believe the following points should be addressed:\nStricter validation of k and n: although the class enforces k<=32 (number of elements in the solution) and n<31 (log2 of the total number of elements), weak could still be created from the authorised parameters. The validate() function may therefore have additional validation that n and k are equal to the intended\nvalues.\n\n\nAssert that k and n are positive values, since currently negative ones (as Int's) would pass theassert` statements."
    }
  ],
  "qa_pairs": []
}