{
  "title": "ErgoTree as a Language",
  "source_url": "docs/dev/scs/ergotree/ergotree-lang.md",
  "summary": "$$\n\\newcommand{\\lst}[1]{#1}\n\\newcommand{\\Tup}[1]{(#1)}\n\\newcommand{\\Apply}[2]{#1\\langle#2\\rangle}\n\\newcommand{\\MSig}[3]{\\text{def}~#1(#2): #3}\n\\newcommand{\\Ov}[1]{\\overline{#1}}\n\\newcommand{\\TyLam}[3]{\\lambda(\\Ov{#1:#2}).#3}\n\\newcommand{\\Trait}[2]{\\text{trait}~#1~\\{ #2 \\}}\n\\newcommand{\\To}{\\mapsto}\n\\newcommand{\\Low}[1]{\\mathcal{L}{[\\![#1]\\!]}}\n\\newcommand{\\Lam}[2]{\\lambda#1.#2}\n\\newcommand{\\IfThenElse}[3]{\\text{if}~(#1)~#2~\\text{else}~#3}\n\\newcommand{\\False}{\\text{false}}\n\\newcommand{\\True}{\\text{true}}\n\\newcommand{\\langname}{ErgoTree}\n\\newcommand{\\corelang}{Core-\\lambda}\n$$\n\n# ErgoTree as a Language\n\nThis section provides improved and clearer documentation for the ErgoTree language. ErgoTree is a typed, call-by-value, higher-order functional language without recursion. It supports various features such as single-assignment blocks, tuples, optional values, indexed collections with higher-order operations, short-circuiting logical operations, and ternary if-else expressions with lazy branches. It is important to note that all operations in ErgoTree are deterministic, without side effects, and all values are immutable. The semantics of ErgoTree are specified by first translating it to a lower-level language called Core-\u03bb and then providing its denotational evaluation semantics.",
  "keywords": [
    "\\newcommand{\\lst}[1]{#1",
    "\\newcommand{\\tup}[1]{(#1",
    "\\newcommand{\\msig}[3]{\\text{def}~#1(#2",
    "\\newcommand{\\ov}[1]{\\overline{#1",
    "\\newcommand{\\tylam}[3]{\\lambda(\\ov{#1:#2}).#3",
    "\\newcommand{\\low}[1]{\\mathcal{l}{[\\![#1]\\",
    "\\newcommand{\\lam}[2]{\\lambda#1.#2",
    "\\newcommand{\\ifthenelse}[3]{\\text{if}~(#1)~#2~\\text{else}~#3",
    "\\newcommand{\\false}{\\text{false",
    "\\newcommand{\\true}{\\text{true",
    "\\newcommand{\\langname}{ergotree",
    "ergotree",
    "language",
    "section",
    "documentation",
    "call",
    "value",
    "order",
    "recursion",
    "feature",
    "assignment",
    "block",
    "tuple",
    "collection",
    "operation",
    "expression",
    "branch",
    "side",
    "effect",
    "semantic",
    "level",
    "core",
    "evaluation",
    "syntax",
    "table",
    "class",
    "hierarchy",
    "reference",
    "implementation",
    "mnemonic",
    "column",
    "name",
    "description",
    "|----------|--------|----------|-------------|",
    "\\mathcal{t",
    "spredeftype",
    "types](types.md",
    "\\tau$",
    "stypevar",
    "type",
    "variable",
    "\\ldot",
    "t_n)$",
    "element",
    "\\ldots",
    "sfunc",
    "function",
    "argument",
    "coll}}[t]$",
    "scollection",
    "option}}[t]$",
    "soption",
    "optional",
    "term",
    "valuse",
    "\\tylam{x_i}{t_i}{e}$",
    "funcexpr",
    "lambda",
    "\\apply{e_f}{\\ov{e_i}}$",
    "apply",
    "application",
    "methodcall",
    "method",
    "invocation",
    "constructor",
    "item",
    "primitive",
    "blockexpr",
    "\\trait{i}{\\overline{ms_i}}$",
    "stypecompanion",
    "interface",
    "declaration",
    "\\msig{m[\\overline{\\tau_i}]}{\\overline{x_i",
    "smethod",
    "signature",
    "typing",
    "rule",
    "typing](typing.md",
    "constant",
    "data",
    "variables",
    "list",
    "body",
    "notation",
    "e_f(\\ov{e})$",
    "\\ov{e})$",
    "subterm",
    "e.m(args)$",
    "information",
    "condition",
    "result",
    "laziness",
    "figure",
    "definition",
    "binding",
    "execution",
    "principle",
    "object",
    "java",
    "scala",
    "instance",
    "term_{ergotree}$",
    "|---||---|",
    "\\low",
    "\\tylam{x_i}{t_i}{e",
    "\\to$",
    "\\lam",
    "x:(t_0,\\dots",
    "\\ov{\\lst{val}~x_i",
    "x.\\_i;}~e\\",
    "\\apply{e_f}{\\ov{e_i",
    "\\apply",
    "\\low{e_f",
    "\\low{(\\ov{e_i",
    "\\apply{e.m}{\\ov{e_i",
    "\\low{e}.m}{\\ov",
    "\\low{e_i",
    "\\tup{e_1",
    "\\dot",
    "\\low{e_1",
    "e_1~\\text{\\|\\|}~e_2",
    "\\ifthenelse",
    "\\true",
    "e_1~\\text{&&}~e_2",
    "\\ifthenelse{e_{cond}}{e_1}{e_2",
    "\\apply{(if(\\low{e_{cond",
    "\\ov{\\text{val}~x_i",
    "e_i;}~e\\",
    "\\lam{(x_1",
    "\\dots",
    "\\apply{(\\lam{(x_n",
    "\\low{e_1}}$\\\\",
    "\\apply{\\delta}{\\ov{e_i",
    "\\apply{\\delta}{\\ov",
    "hand",
    "\\lst{if}$",
    "\\lst{unit",
    "\\lst{||}$",
    "evaluation](evaluation.md",
    "transformation"
  ],
  "sections": [
    {
      "heading": "ErgoTree as a Language",
      "content": "This section provides improved and clearer documentation for the ErgoTree language. ErgoTree is a typed, call-by-value, higher-order functional language without recursion. It supports various features such as single-assignment blocks, tuples, optional values, indexed collections with higher-order operations, short-circuiting logical operations, and ternary if-else expressions with lazy branches. It is important to note that all operations in ErgoTree are deterministic, without side effects, and all values are immutable.\nThe semantics of ErgoTree are specified by first translating it to a lower-level language called Core-\u03bb and then providing its denotational evaluation semantics. The abstract syntax of ErgoTree is defined in Table 1, which represents the Value class hierarchy in the reference implementation. The values in the \"Mnemonic\" column correspond to specific classes in the reference implementation."
    },
    {
      "heading": "Table 1: Abstract syntax of ErgoTree language",
      "content": "| Set Name | Syntax | Mnemonic | Description |\n|----------|--------|----------|-------------|\n| $\\mathcal{T} \\ni T$ | P | SPredefType | See Types |\n| | $\\tau$ | STypeVar | Type variable |\n| | $(T_1, \\ldots, T_n)$ | STuple | Tuple of $n$ elements (see [Tuple] type) |\n| | $(T_1, \\ldots, T_n) \\to T$ | SFunc | Function of $n$ arguments (see [Func] type) |\n| | ${{Coll}}[T]$ | SCollection | Collection of elements of type $T$ |\n| | ${{Option}}[T]$ | SOption | Optional value of type $T$ |\n| $Term \\ni e$ | $C(v, T)$ | Constant | Typed constant |\n| | $x$ | ValUse | Variable |\n| | $\\TyLam{x_i}{T_i}{e}$ | FuncExpr | Lambda expression |\n| | $\\Apply{e_f}{\\Ov{e_i}}$ | Apply | Application of a functional expression |\n| | $\\Apply{e.m}{\\Ov{e_i}}$ | MethodCall | Method invocation |\n| | $\\Apply{e_f}{\\Ov{e_i}}$ | Tuple | Constructor of a tuple with $n$ items |\n| | $\\Apply{\\delta}{\\Ov{e_i}}$ | | Primitive application |\n| | $\\text{if}~(e_{\\text{cond}})~e_1~\\text{else}~e_2$ | If | If-then-else expression |\n| | ${{ \\overline{{\\text{val}}}~x_i = e_i;}~e}$ | BlockExpr | Block expression |\n| $cd$ | $\\Trait{I}{\\overline{ms_i}}$ | STypeCompanion | Interface declaration |\n| $ms$ | $\\MSig{m[\\overline{\\tau_i}]}{\\overline{x_i : T_i}}{T}$ | SMethod | Method signature declaration |\nThe terms in ErgoTree are assigned types according to the typing rules specified in Typing.\nConstants contain both the type and the data value of that type. The type of a constant must correspond to its value for it to be well-formed.\nVariables are always typed and identified by a unique ID, which refers to either a lambda-bound variable or a val-bound variable.\nLambda expressions can take a list of lambda-bound variables, which can be used in the body expression. The body expression itself can also be a block expression.\nFunction application takes an expression of functional type (e.g., $(T_1, \\ldots, T_n) \\to T$) and a list of arguments. The notation $e_f(\\Ov{e})$ is not used to represent function application because it s..."
    },
    {
      "heading": "Figure 2: Lowering to Core-\u03bb",
      "content": "| $Term_{ErgoTree}$ | | $Term_{Core}$  | \n|---||---|\n$\\Low{ \\TyLam{x_i}{T_i}{e}      }$ | $\\To$ | $\\Lam{   x:(T_0,\\dots,T_n)}{ \\Low{ { \\Ov{\\lst{val}~x_i: T_i = x._i;}~e} } }$  \n$\\Low{ \\Apply{e_f}{\\Ov{e_i}}    }$ | $\\To$ | $\\Apply{ \\Low{e_f} }{ \\Low{(\\Ov{e_i})} }$\n$\\Low{ \\Apply{e.m}{\\Ov{e_i}}    }$ | $\\To$ | $\\Apply{ \\Low{e}.m}{\\Ov{ \\Low{e_i} }}$ \n$\\Low{ \\Tup{e_1, \\dots ,e_n}    }$ | $\\To$ | $\\Tup{   \\Low{e_1}, \\dots ,\\Low{e_n}}$ \n$\\Low{ e_1~\\text{\\|\\|}~e_2        }$ | $\\To$ | $\\Low{   \\IfThenElse{ e_1 }{ \\True }{ e_2 }}$  \n$\\Low{ e_1~\\text{&&}~e_2      }$ | $\\To$ | $\\Low{   \\IfThenElse{ e_1 }{ e_2 }{ \\False } }$\n$\\Low{ \\IfThenElse{e_{cond}}{e_1}{e_2} }$ | $\\To$ | $\\Apply{(if(\\Low{e_{cond}} ,~\\Lam{(_:Unit)}{\\Low{e_1}} ,~\\Lam{(_:Unit)}{\\Low{e_2}} ))}{}$ \n$\\Low{ { \\Ov{\\text{val}~x_i: T_i = e_i;}~e} }$ | $\\To$ | $\\Apply{ (\\Lam{(x_1:T_1)}{( \\dots \\Apply{(\\Lam{(x_n:T_n)}{\\Low{e}})}{\\Low{e_n}} \\dots )}) }{\\Low{e_1}}$\\\n$\\Low{ \\Apply{\\delta}{\\Ov{e_i}} }$ | $\\To$ | $\\Apply{\\delta}{\\Ov{ \\Low{e_i} }}$ \n$\\Low{ e }$     | $\\To$ |  $e$\nAll $n$-ary lambdas where $n > 1$ are transformed into single-argument lambdas using tupled arguments.\nIt should be noted that the $\\IfThenElse{e_{\\text{cond}}}{e_1}{e_2}$ term in ErgoTree has lazy evaluation of its branches, while the right-hand-side $\\lst{if}$ is a primitive operation with strict evaluation of the arguments. Laziness is achieved using lambda expressions of type $\\lst{Unit} \\to \\lst{Boolean}$.\nLogical operations ($\\lst{||}$, &&) in ErgoTree, which are lazy (short-circuiting) on the second argument, are translated to $\\lst{if}$ terms in ErgoTree, which are then recursively translated to the corresponding Core-\u03bb terms.\nSyntactic blocks in ErgoTree are eliminated and translated into nested lambda expressions, which unambiguously specify the evaluation semantics of blocks. The evaluation semantics of Core-\u03bb are specified in evaluation.\nNote that the lowering transformation is used solely to specify semantics. Implementations may optimi..."
    }
  ],
  "qa_pairs": []
}