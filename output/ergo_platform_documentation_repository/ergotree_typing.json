{
  "title": "ErgoTree Typing",
  "source_url": "docs/dev/scs/ergotree/typing.md",
  "summary": "$$\n\\newcommand{\\TEnv}{\\Gamma}\n\\newcommand{\\Der}[2]{#1~\\vdash~#2}\n\\newcommand{\\DerV}[2]{#1~\\vdash^{\\text{\\lst{v}}}~#2}\n\\newcommand{\\DerC}[2]{#1~\\vdash^{\\text{\\lst{c}}}~#2}\n\\newcommand{\\DerEnv}[1]{\\Der{\\TEnv}{#1}}\n\\newcommand{\\DerEnvV}[1]{\\DerV{\\TEnv}{#1}}\n\\newcommand{\\DerEnvC}[1]{\\DerC{\\TEnv}{#1}}\n\\newcommand{\\lst}[1]{#1}\n\\newcommand{\\Tup}[1]{(#1)}\n\\newcommand{\\Apply}[2]{#1\\langle#2\\rangle}\n\\newcommand{\\MSig}[3]{\\text{def}~#1(#2): #3}\n\\newcommand{\\Ov}[1]{\\overline{#1}}\n\\newcommand{\\TyLam}[3]{\\lambda(\\Ov{#1:#2}).#3}\n\\newcommand{\\Trait}[2]{\\text{trait}~#1~\\{ #2 \\}}\n\\newcommand{\\To}{\\mapsto}\n\\newcommand{\\Low}[1]{\\mathcal{L}{[\\![#1]\\!]}}\n\\newcommand{\\Lam}[2]{\\lambda#1.#2}\n\\newcommand{\\IfThenElse}[3]{\\text{if}~(#1)~#2~\\text{else}~#3}\n\\newcommand{\\False}{\\text{false}}\n\\newcommand{\\True}{\\text{true}}\n\\newcommand{\\langname}{ErgoTree}\n\\newcommand{\\corelang}{Core-\\lambda}\n$$\n\n\n# ErgoTree Typing\n\n$\\langname$ is a strictly typed language, in which every term should have a type in order to be wellformed and evaluated. Typing judgement of the form $\\Der{\\Gamma}{e : T}$ say that $e$ is a term of type $T$ in the typing context $\\Gamma$. ### **Figure 3: Typing rules of ErgoTree**\n\n\n\n$$\\frac{}{\\Der{\\Gamma}{C(\\_, T)~:~T}}~(Const)$$\n\n$$\\frac{}{\\Der{\\Gamma,x~:~T}{x~:~T}}~(Var)$$\n\n$$\\frac{\\Ov{\\DerEnv{e_i:~T_i}}~~ptype(\\delta, \\Ov{T_i}) :~(T_1,\\dots,T_n) \\to T}{\\Apply{\\delta}{\\Ov{e_i}}:~T}~(Prim)$$\n\n$$\\frac{\\DerEnv{e_1 :~T_1}~~\\dots~~\\DerEnv{e_n :~T_n}}      {\\DerEnv{(e_1,\\dots,e_n)~:~(T_1,\\dots,T_n)}}~(Tuple)$$\n\n$$\\frac{\\DerEnv{e~:~I,~e_i:~T_i}~~mtype(m, I, \\Ov{T_i})~:~(I, T_1,\\dots,T_n) \\to T}{ \\Apply{e.m}{\\Ov{e_i}}:~T }~(MethodCall)$$ \n\n\n$$\\frac{\\Der{\\TEnv,\\Ov{x_i:~T_i}}{e~:~T}}{\\Der{\\Gamma}{\\TyLam{x_i}{T_i}{e}~:~(T_0,\\dots,T_n) \\to T}}~(FuncExpr)$$\n\n$$\\frac{\\Der{\\TEnv}{e_f:~(T_1,\\dots,T_n) \\to T}~~~\\Ov{\\Der{\\TEnv}{e_i:~T_i}} }{ \\Der{\\Gamma}{\\Apply{e_f}{\\Ov{e_i}}~:~T} }~(Apply)$$\n\n\n$$\\frac{\\DerEnv{e_{cond}:~\\lst{Boolean}}~~\\DerEnv{e_1:~T}~~\\DerEnv{e_2 :~T} }{\\DerEnv{\\IfThenElse{e_{cond}}{e_1}{e_2}~:~T} }~\\lst{(If)}$$\n\n$\\frac{\\DerEnv{e_1 :~T_1}~\\wedge~\\forall k\\in\\{2,\\dots,n\\}~\\Der{\\Gamma,x_1:~T_1,\\dots,x_{k-1}:~T_{k-1}}{e_k:~T_k}~\\wedge~\\Der{\\Gamma,x_1:~T_1,\\dots,x_n:~T_n}{e:~T}}{ \\DerEnv{\\{ \\Ov{\\text{val}}~x_i = e_i;}~e\\}~:~T} ~(BlockExpr)$\n\n\n\n\n\n\n> Note that each well-typed term has exactly one type; hence we assume there exists a function $termType: Term \\to \\mathcal{T}$ which relates each well-typed term with the corresponding type.",
  "keywords": [
    "\\newcommand{\\tenv}{\\gamma",
    "\\newcommand{\\der}[2]{#1~\\vdash~#2",
    "\\newcommand{\\derenv}[1]{\\der{\\tenv}{#1",
    "\\newcommand{\\derenvv}[1]{\\derv{\\tenv}{#1",
    "\\newcommand{\\derenvc}[1]{\\derc{\\tenv}{#1",
    "\\newcommand{\\lst}[1]{#1",
    "\\newcommand{\\tup}[1]{(#1",
    "\\newcommand{\\msig}[3]{\\text{def}~#1(#2",
    "\\newcommand{\\ov}[1]{\\overline{#1",
    "\\newcommand{\\tylam}[3]{\\lambda(\\ov{#1:#2}).#3",
    "\\newcommand{\\low}[1]{\\mathcal{l}{[\\![#1]\\",
    "\\newcommand{\\lam}[2]{\\lambda#1.#2",
    "\\newcommand{\\ifthenelse}[3]{\\text{if}~(#1)~#2~\\text{else}~#3",
    "\\newcommand{\\false}{\\text{false",
    "\\newcommand{\\true}{\\text{true",
    "\\newcommand{\\langname}{ergotree",
    "ergotree",
    "\\langname$",
    "language",
    "term",
    "type",
    "order",
    "judgement",
    "form",
    "\\der{\\gamma}{e",
    "context",
    "\\gamma$.",
    "figure",
    "rule",
    "\\frac{}{\\der{\\gamma}{c(\\",
    "t)~:~t}}~(const)$$",
    "\\ov{t_i",
    "~(t_1,\\dot",
    "t}{\\apply{\\delta}{\\ov{e_i}}:~t}~(prim)$$",
    "\\frac{\\derenv{e_1",
    "~t_1}~~\\dots~~\\derenv{e_n",
    "\\derenv{(e_1,\\dots",
    "e_n)~:~(t_1,\\dot",
    "t_n)}}~(tuple)$$",
    "\\ov{t_i})~:~(i",
    "t_1,\\dot",
    "~(methodcall)$$",
    "\\frac{\\der{\\tenv,\\ov{x_i:~t_i}}{e~:~t}}{\\der{\\gamma}{\\tylam{x_i}{t_i}{e}~:~(t_0,\\dot",
    "\\frac{\\der{\\tenv}{e_f:~(t_1,\\dots",
    "t}~~~\\ov{\\der{\\tenv}{e_i:~t_i",
    "\\der{\\gamma}{\\apply{e_f}{\\ov{e_i}}~:~t",
    "\\frac{\\derenv{e_{cond}:~\\lst{boolean}}~~\\derenv{e_1:~t}~~\\derenv{e_2",
    "\\derenv{\\ifthenelse{e_{cond}}{e_1}{e_2}~:~t",
    "~\\lst{(if)}$$",
    "~t_1}~\\wedge~\\forall",
    "k\\in\\{2,\\dots",
    "n\\}~\\der{\\gamma",
    "x_1:~t_1,\\dots",
    "x_{k-1}:~t_{k-1}}{e_k:~t_k}~\\wedge~\\der{\\gamma",
    "x_n:~t_n}{e:~t",
    "\\derenv{\\",
    "\\ov{\\text{val}}~x_i",
    "e_i;}~e\\}~:~t",
    "function",
    "termtype",
    "operation",
    "variable",
    "scorexfoundation",
    "sigmastate",
    "interpreter/4daec63275fd4e1364cf7a1132f3e7be6157bb5c",
    "docs",
    "spec",
    "ergotree.pdf",
    "signature",
    "type](types.md",
    "ptype$",
    "primop",
    "argument",
    "example",
    "ptype(+,int",
    "method",
    "methodcall",
    "blockexpr",
    "block",
    "expression",
    "ordering",
    "definition",
    "rest",
    "lambda",
    "calculus"
  ],
  "sections": [
    {
      "heading": "ErgoTree Typing",
      "content": "$\\langname$ is a strictly typed language, in which every term should have a type in order to be wellformed and evaluated. Typing judgement of the form $\\Der{\\Gamma}{e : T}$ say that $e$ is a term of type $T$ in the typing context $\\Gamma$."
    },
    {
      "heading": "Figure 3: Typing rules of ErgoTree",
      "content": "$$\\frac{}{\\Der{\\Gamma}{C(_, T)~:~T}}~(Const)$$\n$$\\frac{}{\\Der{\\Gamma,x~:~T}{x~:~T}}~(Var)$$\n$$\\frac{\\Ov{\\DerEnv{e_i:~T_i}}~~ptype(\\delta, \\Ov{T_i}) :~(T_1,\\dots,T_n) \\to T}{\\Apply{\\delta}{\\Ov{e_i}}:~T}~(Prim)$$\n$$\\frac{\\DerEnv{e_1 :~T_1}~~\\dots~~\\DerEnv{e_n :~T_n}}      {\\DerEnv{(e_1,\\dots,e_n)~:~(T_1,\\dots,T_n)}}~(Tuple)$$\n$$\\frac{\\DerEnv{e~:~I,~e_i:~T_i}~~mtype(m, I, \\Ov{T_i})~:~(I, T_1,\\dots,T_n) \\to T}{ \\Apply{e.m}{\\Ov{e_i}}:~T }~(MethodCall)$$\n$$\\frac{\\Der{\\TEnv,\\Ov{x_i:~T_i}}{e~:~T}}{\\Der{\\Gamma}{\\TyLam{x_i}{T_i}{e}~:~(T_0,\\dots,T_n) \\to T}}~(FuncExpr)$$\n$$\\frac{\\Der{\\TEnv}{e_f:~(T_1,\\dots,T_n) \\to T}~~~\\Ov{\\Der{\\TEnv}{e_i:~T_i}} }{ \\Der{\\Gamma}{\\Apply{e_f}{\\Ov{e_i}}~:~T} }~(Apply)$$\n$$\\frac{\\DerEnv{e_{cond}:~\\lst{Boolean}}~~\\DerEnv{e_1:~T}~~\\DerEnv{e_2 :~T} }{\\DerEnv{\\IfThenElse{e_{cond}}{e_1}{e_2}~:~T} }~\\lst{(If)}$$\n$\\frac{\\DerEnv{e_1 :~T_1}~\\wedge~\\forall k\\in{2,\\dots,n}~\\Der{\\Gamma,x_1:~T_1,\\dots,x_{k-1}:~T_{k-1}}{e_k:~T_k}~\\wedge~\\Der{\\Gamma,x_1:~T_1,\\dots,x_n:~T_n}{e:~T}}{ \\DerEnv{{ \\Ov{\\text{val}}~x_i = e_i;}~e}~:~T} ~(BlockExpr)$\nNote that each well-typed term has exactly one type; hence we assume there exists a function $termType: Term \\to \\mathcal{T}$ which relates each well-typed term with the corresponding type.\nPrimitive operations can be parameterized with type variables; for example,addition has the signature $+~:~ (T,T) \\to T$ where $T$ is a numeric type. Function $ptype$, defined in primops, returns a type of primitive operation specialized for concrete types of its arguments, for example, $ptype(+,Int, Int) = (Int, Int) \\to Int$.\nSimilarly, the function $mtype$ returns a type of method specialized for concrete types of the arguments of the MethodCall term.\nBlockExpr rule defines a type of well-formed block expression. It assumes a total ordering on val definitions. If a block expression is not well-formed, than is cannot be typed and evaluated.\nThe rest of the rules are standard for typed lambda calculus."
    }
  ],
  "qa_pairs": []
}