{
  "title": "ADProofs (Authenticated Data Proofs)",
  "source_url": "docs/dev/data-model/block-adproofs.md",
  "summary": "---\ntags:\n  - ADProofs\n  - Authenticated Data Proofs\n  - Block\n  - Data Model\n---\n\n# ADProofs (Authenticated Data Proofs)\n\n*(Back to: [Block Overview](block.md)) * **ADProofs**, short for Authenticated Data Proofs, are a crucial component of Ergo's [block structure](block.md) that allows for efficient and secure [validation](validation.md) of [transactions](transactions.md) without requiring full blockchain download. They are particularly beneficial for \"[light clients](modes.md)\" \u2013 [wallets](wallets.md) or [nodes](install.md) that don't store the entire blockchain.",
  "keywords": [
    "adproofs",
    "authenticated",
    "data",
    "proofs",
    "block",
    "model",
    "overview](block.md",
    "component",
    "ergo",
    "transactions](transactions.md",
    "download",
    "clients](modes.md",
    "nodes](install.md",
    "blockchain",
    "function",
    "efficient",
    "transaction",
    "validation",
    "adproof",
    "client",
    "validity",
    "merkle",
    "tree](merkle",
    "utxo",
    "set](eutxo.md",
    "need",
    "state",
    "verification",
    "light",
    "root](block",
    "header.md",
    "summary",
    "security",
    "tampering",
    "structure",
    "class",
    "adproofs.scala](https://github.com",
    "ergoplatform",
    "blob",
    "master",
    "core",
    "scala",
    "modifier",
    "history",
    "adproofs.scala",
    "element",
    "headerid",
    "header](block",
    "proof",
    "proofbyte",
    "change",
    "process",
    "initialization",
    "header",
    "list",
    "transactions](block",
    "application",
    "batchavlverifier",
    "verifier",
    "root",
    "calculation",
    "result",
    "transition",
    "concepts",
    "tree",
    "leaf",
    "node",
    "piece",
    "datum",
    "case",
    "box](box.md",
    "hash",
    "child",
    "inclusion",
    "avl+",
    "tree](avl.md",
    "self",
    "search",
    "lookup",
    "update",
    "batch",
    "operation",
    "addition",
    "removal",
    "efficiency",
    "benefit",
    "reduced",
    "bandwidth",
    "resource",
    "enhanced",
    "scalability",
    "participation"
  ],
  "sections": [
    {
      "heading": "ADProofs (Authenticated Data Proofs)",
      "content": "(Back to: Block Overview)\nADProofs, short for Authenticated Data Proofs, are a crucial component of Ergo's block structure that allows for efficient and secure validation of transactions without requiring full blockchain download. They are particularly beneficial for \"light clients\" \u2013 wallets or nodes that don't store the entire blockchain.\nFunction:\nEfficient Transaction Validation: ADProofs enable light clients to verify the validity of transactions within a block by proving they are included in the Merkle tree of the UTXO set. This eliminates the need to download and process the entire UTXO set or the full block.\nState Verification: Light clients can use ADProofs to calculate the new state root (a cryptographic summary of the UTXO set) after applying the transactions in a block. This allows them to stay synchronized with the blockchain without storing the complete state.\nSecurity: ADProofs are cryptographically secure, ensuring that any tampering with the transactions or the UTXO set will be detected during validation.\nStructure:\nThe ADProofs class in ADProofs.scala defines the structure of ADProofs. It contains the following key elements:\nheaderId: The ID of the block header to which these proofs correspond.\nproofBytes: The serialized cryptographic proof that allows for verification of the state changes.\nVerification Process:\nInitialization: A light client receives the block header, the ADProofs, and the list of transactions.\nProof Application: The client uses the ADProofs to construct a BatchAVLVerifier. This verifier utilizes the provided proof to validate the changes made to the UTXO set by the transactions.\nState Root Calculation: The verifier calculates the new state root after applying the transactions. This calculated root is then compared against the state root declared in the block header.\nVerification Result: If the calculated state root matches the one in the header, the transactions and the state transition are considered valid.\nKey Concepts:\nMerkle ..."
    }
  ],
  "qa_pairs": []
}