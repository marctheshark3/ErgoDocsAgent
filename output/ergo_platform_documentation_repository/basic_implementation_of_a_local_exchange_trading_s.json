{
  "title": "Basic Implementation of a Local Exchange Trading System (LETS)",
  "source_url": "docs/uses/lets/basic-imp.md",
  "summary": "# Basic Implementation of a Local Exchange Trading System (LETS)\n\n## Overview\n\nThe basic blueprint of our system encompasses two contracts: an administrative contract and a trade contract. Before delving into the details, we recommend acquainting yourself with the foundational aspects of Ergo by reviewing [this ICO article](ico.md) as well as [ErgoScript](ergoscript.md) tutorials. Despite the aforementioned recommendations, we will elucidate a few novel terms in the upcoming sections. ### Singleton Tokens and Boxes\n\nIn Ergo, when a token is minted with a value of one, it is termed a **singleton token**. Similarly, a box containing a singleton token is known as a **singleton box**.\n\n## Administrative Contract\n\n### Purpose\n\n-",
  "keywords": [
    "basic",
    "implementation",
    "local",
    "exchange",
    "trading",
    "system",
    "lets",
    "blueprint",
    "contract",
    "trade",
    "detail",
    "aspect",
    "ergo",
    "ergoscript](ergoscript.md",
    "tutorial",
    "recommendation",
    "term",
    "section",
    "singleton",
    "tokens",
    "boxes",
    "token",
    "value",
    "administrative",
    "purpose",
    "member",
    "addition",
    "rate",
    "transaction",
    "digest",
    "data",
    "structure",
    "directory",
    "housing",
    "balance",
    "register",
    "case",
    "correctness",
    "transformation",
    "committee",
    "management",
    "composition",
    "time",
    "logic",
    "instance",
    "signature",
    "datum",
    "input",
    "output",
    "code",
    "ergoscript",
    "comment",
    "usercontracthash",
    "correspond",
    "hash",
    "selfout",
    "script",
    "adminscript",
    "r5[sigmaprop].get",
    "scriptiscorrect",
    "selfout.propositionbyte",
    "self.propositionbytes",
    "spending",
    "user",
    "isoutputsizecorrect",
    "outputs.size",
    "replication",
    "label",
    "istokenoutputcorrect",
    "selfout.tokens.size",
    "selfout.tokens(0)._1",
    "letstoken",
    "issuance",
    "amount",
    "outputs(0",
    "issuedtokenid",
    "inputs(0).id",
    "userout",
    "aretokenamountscorrect",
    "userout.tokens.size",
    "userout.tokens(0)._1",
    "userout.tokens(0)._2",
    "outputs(2).tokens.size",
    "verifie",
    "isuserbalancezero",
    "r4[long",
    "isuserscriptproper",
    "identifier",
    "toadd",
    "coll[(coll[byte",
    "coll[byte",
    "coll((issuedtokenid",
    "proof",
    "updatedtree",
    "selftree.insert(toadd",
    "proof).get",
    "r4[avltree].get",
    "istreecorrect",
    "legitimacy",
    "trader",
    "minbalance",
    "-20000",
    "lookupproof",
    "read",
    "treeholderbox",
    "context.datainputs(0",
    "isletstokenproper",
    "treeholderbox.tokens(0)._1",
    "participant0",
    "participant1",
    "participantout0",
    "participantout1",
    "outputs(1",
    "token0",
    "participant1.tokens(0)._1",
    "membertokens",
    "coll(token0",
    "domembersexist",
    "memberstree.getmany(membertokens",
    "lookupproof).forall",
    "option[coll[byte",
    "change",
    "initialbalance0",
    "initialbalance1",
    "participantout0.r4[long].get",
    "finalbalance1",
    "participantout1.r4[long].get",
    "-balancedifference1",
    "arebalancescorrect",
    "participantout0.propositionbyte",
    "participantout1.propositionbyte",
    "participant1.propositionbyte",
    "arescriptspreserved",
    "isscript1pres",
    "protection",
    "selfpubkey",
    "self.r5[sigmaprop].get",
    "arebalancedifferencescorrect",
    "characteristic"
  ],
  "sections": [
    {
      "heading": "Overview",
      "content": "The basic blueprint of our system encompasses two contracts: an administrative contract and a trade contract. Before delving into the details, we recommend acquainting yourself with the foundational aspects of Ergo by reviewing this ICO article as well as ErgoScript tutorials.\nDespite the aforementioned recommendations, we will elucidate a few novel terms in the upcoming sections."
    },
    {
      "heading": "Singleton Tokens and Boxes",
      "content": "In Ergo, when a token is minted with a value of one, it is termed a singleton token. Similarly, a box containing a singleton token is known as a singleton box."
    },
    {
      "heading": "Purpose",
      "content": "The administrative contract oversees a singleton box that encompasses the members of the LETS system. \nThis contract facilitates the addition of new members, at a rate of one member per transaction. \nInstead of storing members, the box merely holds a succinct digest of an authenticated data structure based on the members' directory. \nEach member is linked with a singleton token minted during a transaction that adds the member to the directory. \nThis transaction generates a new member's box, housing the member's singleton token. \nThe trade contract safeguards the member's box. \nMoreover, the freshly generated member's box records the initial balance in the R4 register, which in this case is zero.\nThe transaction that adds a new member is obligated to validate the correctness of the directory transformation."
    },
    {
      "heading": "Committee Management",
      "content": "A committee generally manages the administrative contract box, and the composition of this committee may change over time. To accommodate this, we allow the committee's logic to reside in the R5 register. For instance, if a new member is added to both the committee and the LETS system, the incoming administrative contract box would require signatures from two out of three members, while the outgoing box would require three out of four signatures. Consequently, the data within the R5 register of the input and output boxes would vary.\nBelow, we provide the administrative contract's code written in ErgoScript, complete with comments. Note that userContractHash corresponds to the hash of the trade contract.\n```scala\n    val selfOut = OUTPUTS(0)\n// Administrative script\nval adminScript = selfOut.R5[SigmaProp].get\n\n// Confirming that the script replicates itself and the administrative script is satisfied\nval scriptIsCorrect = (selfOut.propositionBytes == SELF.propositionBytes) && adminScript\n\n// A spending transaction creates boxes for the directory, user, and fee\nval isOutputSizeCorrect = OUTPUTS.size == 3\n\n// Verifies the replication of the administrative label token \nval isTokenOutputCorrect = (selfOut.tokens.size == 1) && (selfOut.tokens(0)._1 == letsToken)\n\n// Validates the issuance of a new token and its amount\n// OUTPUTS(0) tokens are already checked via isTokenOutputCorrect\nval issuedTokenId = INPUTS(0).id\nval userOut = OUTPUTS(1)\nval areTokenAmountsCorrect =\n  (userOut.tokens.size == 1 &&\n    userOut.tokens(0)._1 == issuedTokenId &&\n    userOut.tokens(0)._2 == 1 &&\n    OUTPUTS(2).tokens.size == 0 &&\n    isTokenOutputCorrect)\n\n// Verifies that the new user is created with a zero balance\nval isUserBalanceZero  = userOut.R4[Long\n].get == 0\nval isUserScriptProper = blake2b256(userOut.propositionBytes) == userContractHash\n\n// Validates the addition of the new token identifier to the directory\nval selfTree = SELF.R4[AvlTree].get\nval toAdd: Coll[(Coll[Byte], Coll[Byte])..."
    }
  ],
  "qa_pairs": []
}