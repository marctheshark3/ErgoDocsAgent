[
  {
    "question": "What are the key phases in the ErgoScript compiler pipeline?",
    "answer": "The key phases in the ErgoScript compiler pipeline are: 1) Source Code, 2) Parse, 3) Bind, 4) Typecheck, 5) BuildGraph, and 6) BuildTree."
  },
  {
    "question": "What is the purpose of the Lexer (Lexical Analysis) phase in the ErgoScript compiler?",
    "answer": "The purpose of the Lexer (Lexical Analysis) phase is to scan the source code and convert it into a sequence of tokens, which are the smallest meaningful elements in the code, such as keywords, operators, literals, and identifiers."
  },
  {
    "question": "How is the Lexer implemented in the `sigma-rust` and `sigmastate-interpreter` projects?",
    "answer": "In `sigma-rust`, the Lexer is implemented using the `Logos` crate, which provides an efficient way to define lexing rules in Rust. In `sigmastate-interpreter`, a custom Scala-based Lexer is used for tokenization."
  },
  {
    "question": "What is the purpose of the Parser (Syntax Analysis) phase in the ErgoScript compiler?",
    "answer": "The purpose of the Parser (Syntax Analysis) phase is to take the list of tokens generated by the Lexer and construct an Abstract Syntax Tree (AST), which represents the syntactical structure of the source code in a tree format."
  },
  {
    "question": "How are the Parser and AST implemented in the `sigma-rust` and `sigmastate-interpreter` projects?",
    "answer": "In `sigma-rust`, the parser uses the `Rowan` library to manage Concrete Syntax Trees (CST) and Abstract Syntax Trees (AST), where AST nodes wrap Rowan's trees and expose node-specific details. In `sigmastate-interpreter`, the Scala implementation utilizes its own parsing strategies to construct the AST from tokens."
  }
]