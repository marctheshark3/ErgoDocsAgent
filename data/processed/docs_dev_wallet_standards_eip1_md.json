{
  "id": "docs_dev_wallet_standards_eip1_md",
  "title": "EIP-0001: UTXO-Set Scanning Wallet API",
  "summary": "The document introduces EIP-0001, which proposes extending the Ergo node wallet to provide a flexible scanning interface for external applications. The key points are:\n\n- Currently, the Ergo node wallet can only search for boxes protected by simple P2PK scripts, which is a barrier for dApp development.\n- The proposed extension would allow the wallet to serve the needs of external applications by providing a flexible scanning interface and the ability for applications to register scans.\n- Scans have a unique ID, and boxes matching a scan are tracked by the wallet and associated with the scan ID.\n- The wallet will provide predefined scans, such as for wallet public keys and mining rewards, and allow users or external applications to add additional scans.\n- The scanning mechanism is based on predicates, which are functions that return a boolean value for a given box.\n- The document specifies the available predicate types, such as checking for a value in a register, checking for a specific asset, and combining multiple predicates.",
  "qa_pairs": [
    {
      "question": "What is this document about?",
      "answer": "---\ntags:\n  - EIP\n---\n\n# EIP-0001: UTXO-Set Scanning Wallet API\n\nMotivation \n----------\n\nCurrently, the Ergo node wallet is able to search for boxes protected only by simplest scripts associated with ..."
    },
    {
      "question": "What is the title of this document?",
      "answer": "EIP-0001: UTXO-Set Scanning Wallet API"
    },
    {
      "question": "What is the 'Introduction' section about?",
      "answer": "---\ntags:\n  - EIP\n---"
    },
    {
      "question": "What is the 'EIP-0001: UTXO-Set Scanning Wallet API' section about?",
      "answer": "Motivation \n----------\n\nCurrently, the Ergo node wallet is able to search for boxes protected only b..."
    }
  ],
  "sections": [
    {
      "heading": "Introduction",
      "level": 0,
      "content": "---\ntags:\n  - EIP\n---"
    },
    {
      "heading": "EIP-0001: UTXO-Set Scanning Wallet API",
      "level": 1,
      "content": "Motivation \n----------\n\nCurrently, the Ergo node wallet is able to search for boxes protected only by simplest scripts associated with P2PK \naddresses which is a large barrier for dApps. This makes development of external applications which use smart contracts \nquite challenging. Development would involve scanning the blockchain state independently by the off-chain portion of \nthe dApp itself with handling forks, confirmation numbers, and so on.\n\nThis Ergo Improvement Proposal focused on extending the wallet to be able to serve the needs of external applications by providing \na flexible scanning interface and the possibility for applications to register scans with the wallet to ensure that they are tracked. Scans that have successfully passed are considered to belong to the application.\n\nEach scan has a given scan ID, and each box found that matches said scan is tracked by the wallet and thus is associated with the scan ID. Among possible scans, there are some pre-defined scans   \nimplemented by the node wallet, to track wallet's public keys and also mining rewards. Other scans are not directly implemented inside of \nthe wallet but can be added by a user or an external application.\n\n\nSpecification: Scanning\n-----------------------\n\nA new request to scan is initiated which [registers](registers.md) said scan to be checked for all future UTXO-set changes (thus it is forward-looking).\n\nA predicate (function which returns a boolean value for a box) is required to register a scan.\nPredicates available are:\n\n* `CONTAINS(register, value)` returns true if certain register contains given value. If *register* argument is missed, R1 (script register) will be scanned\n* `EQUALS(register, value)`returns true if certain register contains only given value. If *register* argument is missed, R1 will be scanned\n* `CONTAINS_ASSET(assetId)`- if a box contains asset with a given id\n* `AND(predicate1, predicate2, ..., predicateN)` - if all the children predicates are true\n* `OR(predicate1, predicate2, ..., predicateN)` - if one of the children predicates is true\n\n*value* field in the predicates above is about encoded sigma value, *assetId* is about just 32-bytes long byte array.\n\nThe following is an example of a predicate which states that the registered scan will search for boxes that contain a \ngiven asset and also the provided bytes in R1 (*\"0e24...\"* in the example is a byte array which contains a script \nrepresented in ErgoTree form).\n\n```haskell\nAND(\n    CONTAINS_ASSET(\"bc01de24311298068c07857d3860625abf3277997e2a2b8ff8ea91dda28d47a5\"), \n    CONTAINS(\"0e240008cd029f2230dbe53f6b84d8a884a3407c3dffe43daf8037445441be7cdcd261feeaa4\")\n   )\n```\n\nThis must be formatted in JSON and sent as a request to register the scan. \nThis is done via the endpoint: `/scan/register`.\nIn addition to root predicate the scheme also requires a scan name \n(UTF-8 characters requiring for up to 255 bytes to be encoded). \n\nThe following is an example of valid JSON for a scan register request for the previous predicate.\n\n```json\n{\n    \"scanName\": \"Asset and script tracker\",\n    \"trackingRule\" : {\n        \"predicate\": \"and\",\n        \"args\":[\n            {\"predicate\": \"contains\", \"value\": \"0e240008cd029f2230dbe53f6b84d8a884a3407c3dffe43daf8037445441be7cdcd261feeaa4\"},\n            {\"predicate\": \"containsAsset\", \"assetId\": \"02dada811a888cd0dc7a0a41739a3ad9b0f427741fe6ca19700cf1a51200c96bf7\"}\n        ]\n    }\n}\n```\n\nThe node API returns an error if something wrong with request. If it is well formed then the wallet will return a new scan ID which the user/dApp can use to reference said scan. The scan identifier(ID) is encoded as 16-bit long signed but always positive integer. \n\nOther basic endpoints include:\n\n- `/scan/listAll` returns all the registered scans\n- `/scan/deregister` stops tracking a given scan based on the ID provided\n\nSpecification: Interaction With the Wallet \n------------------------------------------\n\nIf a scan has found a box which also could be spent by the node wallet, there is a question whether the box should be \nshared with the wallet or not. There are three options for corresponding *walletInteraction* :\n\n* **off** - add found boxes to the scan only\n* **shared** - add found boxes to the scan if they belong to the wallet (so associated with P2PK scripts)\n* **forced** - add found boxes to the wallet\n\nexample: \n\n```json\n{\n    \"scanName\": \"Script tracker\",\n    \"trackingRule\" : {\n        \"predicate\": \"contains\", \n        \"value\": \"0e240008cd029f2230dbe53f6b84d8a884a3407c3dffe43daf8037445441be7cdcd261feeaa4\"       \n    },\n    \"walletInteraction\": \"forced\"\n}\n```\n\n\nSpecification: Adding Boxes Externally\n--------------------------------------\n\nSometimes it is simpler for an external application to find relevant boxes itself without using the\nwallet scanner. For that we have the following endpoint:  \n\n- `/scan/addBox`\n\n\nSpecification: Removing False Positive Boxes\n--------------------------------------------\n\nThe wallet collects boxes according to the scanning rules used. However, a box which passes the predicate filter may still not \nnecessarily be wanted as part of a scan. As such, an application can inform the wallet if a box is not needed to be\ntracked and can be ignored.\n\n- `/scan/stopTracking/{scanId}/{boxId}` - to inform the wallet that a box does not belong to a given scan and \n\t\t\t\t\t  thus should not be tracked anymore\n                            \n                                                                               \nSpecification: Reading Boxes\n-----------------------------\n\nOnce boxes are recognized, an external application can use them. To get all of the boxes that have ever been tracked by a scan, or \ncurrent tracked unspent boxes, the following API methods are proposed:\n\n- `/scan/boxes/{scanId}`\n- `/scan/boxesUnspent/{scanId}`\n\n\nSpecification: List Of All Proposed Endpoints\n-----------------------------\n\n- POST: `/scan/register` - Registers/begins tracking a scan based on a provided predicate\n- POST: `/scan/deregister` - Stops tracking a given scan based on the ID provided\n- POST: `/scan/addBox`\t- Manually add box\n- POST: `/scan/stopTracking` - To inform the wallet that a box does not belong to a given scan\n- GET: `/scan/listAll` - Returns all the registered scans\n- GET: `/scan/boxes/{scanId}` - List all boxes that have ever been tracked by the scan\n- GET: `/scan/boxesUnspent/{scanId}` - List all boxes that have been tracked by the scan and are still unspent/part of the UTXO set\n\n\nSpecification: List Of Implemented Endpoints\n--------------------------------------------\n\n- POST: `/scan/register` - 3.3.0\n- POST: `/scan/deregister` - 3.3.0\n- POST: `/scan/addBox`\n- POST: `/scan/stopTracking` - 3.3.0\n- GET: `/scan/listAll` - 3.3.0\n- GET: `/scan/boxesUnspent/{scanId}` - 3.3.0\n\nObjects and endpoints description can be found in [openapi.yaml file in Ergo protocol reference client repository](https://github.com/ergoplatform/ergo/blob/master/src/main/resources/api/openapi.yaml).\n\n\nSpecification: Predefined Scans\n----------------------------------------\n\nThere are some predefined scans in the node, such as SimplePayments and MiningRewards. External scans has exclusive \npriority over predefined ones, this does mean that if a box could be, for example, associated with both the \nSimplePayments and an external scan, then the box will be associated with the external scan **only**.\n\nThe SimplePayments scan always has id == 10, MiningRewards has id == 9. \nThe SimplePayments default wallet scan is using the `OR(CONTAINS(pk_1), ..., CONTAINS(pk_n))` predicate, where \n`pk_1, ..., pk_n` are script bytes of the P2PK addresses of the wallet. MiningRewards predicate is similarly about \nmining script bytes corresponding to the P2PK addresses of the wallet.\n\nUTXO-Set Scanning dApp Examples\n--------------------\n\nBelow example scenarios for dApp use cases are presented.\n\n* *Crowdfunding*\n\nThe simplest crowdfunding script is provided in Section 2.3 of [ErgoScript Whitepaper](https://ergoplatform.org/docs/ErgoScript.pdf).\n\nThere are two roles in the script, a user and a project. For a user, scanning pledge boxes of self would be \njust `EQUALS(script)`, where `script` are the bytes of a script from the Whitepaper that embeds both the backer and\nproject public keys. The user can withdraw the pledge box if it is still unspent after the crowdfunding deadline.\nHowever, a user may be interested to know the state of the campaign at a given moment. The project also needs to collect all of the pledge boxes.\nFor this, the simplest option is to use `CONTAINS(projectPubKey)` predicate \n, however if the project is using its key for other purposes than the crowdfunding, then the filter will \ngive false-positives. To reduce false positives count, instead of the public key, a larger part of the script which \ncontains *projectPubKey* but does not contain *backerPubKey* could be used within `CONTAINS()`.\n\n* *Mixing*\n\nFor mixing scripts, see Section 3.3.1 of \n[Advanced ErgoScript Tutorial](https://ergoplatform.org/docs/AdvancedErgoScriptTutorial.pdf). To find her half-mix coin\nin the mixing application, Alice can simply watch for her public key. Then she is watching for this box, and once the\nbox is spent, she figures out the outputs of the spending transaction and adds her output manually to the wallet. Bob can \non his side can track a large enough part of the half-mix script not including Alice's pubkey u. \n\n* *LETS*\n\nWe consider a trusted LETS as described [here](trustless-lets.md)\n\nManagement contract uses a singleton token, as does the exchange contract as well. Thus for both the managers\nand the user, boxes can be tracked via `CONTAINS_ASSET()` filter."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/wallet/standards/eip1.md",
  "processed_at": "2025-05-11T19:41:39.884215",
  "ai_processed": true
}