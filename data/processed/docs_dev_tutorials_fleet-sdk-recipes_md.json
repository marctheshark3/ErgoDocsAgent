{
  "id": "docs_dev_tutorials_fleet-sdk-recipes_md",
  "title": "Fleet SDK Recipes",
  "summary": "The document \"Fleet SDK Recipes\" provides useful code snippets, patterns, and troubleshooting tips for common tasks when using the Fleet SDK in TypeScript/JavaScript. It covers the following topics:\n\nValidating Box Ownership (SigmaProp from Register): Extracting the owner's SigmaProp bytes from a register, deserializing them, converting the public key bytes into the owner's P2PK ErgoTree, and comparing it with the ErgoTree of the box being validated.\n\nWorking with Numeric Registers: Extracting numeric values (BigInt) from registers, handling different numeric types like SLong and SInt.\n\nExtracting Token IDs from Registers: Extracting token IDs (hex strings) from registers containing SColl(SByte) format.\n\nDecoding Complex Types (Tuples, Options, Collections): Deserializing complex data types from registers.\n\nCompiling ErgoScript to ErgoTree: Compiling ErgoScript to ErgoTree.\n\nTroubleshooting Common Issues: Addressing ErgoTree comparison failures and unexpected register format issues.\n\nThe document also includes a relationship diagram and related documentation references.",
  "qa_pairs": [
    {
      "question": "What is this document about?",
      "answer": "---\ntags:\n  - fleet-sdk\n  - typescript\n  - javascript\n  - sigmaprop\n  - ergotree\n  - registers\n  - p2pk\n  - validation\n  - tutorial\n  - serialization\n  - deserialization\n  - token-id\n  - numeric-regis..."
    },
    {
      "question": "What is the title of this document?",
      "answer": "Fleet SDK Recipes"
    },
    {
      "question": "What is the 'Introduction' section about?",
      "answer": "---\ntags:\n  - fleet-sdk\n  - typescript\n  - javascript\n  - sigmaprop\n  - ergotree\n  - registers\n  - p..."
    },
    {
      "question": "What is the 'Fleet SDK Recipes' section about?",
      "answer": "This page contains useful code snippets, patterns, and troubleshooting tips for common tasks when us..."
    },
    {
      "question": "What is the 'Table of Contents' section about?",
      "answer": "- [Fleet SDK Recipes](#fleet-sdk-recipes)\n  - [Table of Contents](#table-of-contents)\n  - [Validatin..."
    }
  ],
  "sections": [
    {
      "heading": "Introduction",
      "level": 0,
      "content": "---\ntags:\n  - fleet-sdk\n  - typescript\n  - javascript\n  - sigmaprop\n  - ergotree\n  - registers\n  - p2pk\n  - validation\n  - tutorial\n  - serialization\n  - deserialization\n  - token-id\n  - numeric-registers\n  - compiler\n  - troubleshooting\n---"
    },
    {
      "heading": "Fleet SDK Recipes",
      "level": 1,
      "content": "This page contains useful code snippets, patterns, and troubleshooting tips for common tasks when using the [Fleet SDK](fleet.md) in TypeScript/JavaScript."
    },
    {
      "heading": "Table of Contents",
      "level": 2,
      "content": "- [Fleet SDK Recipes](#fleet-sdk-recipes)\n  - [Table of Contents](#table-of-contents)\n  - [Validating Box Ownership (SigmaProp from Register)](#validating-box-ownership-sigmaprop-from-register)\n    - [Complete Example:](#complete-example)\n  - [Working with Numeric Registers](#working-with-numeric-registers)\n  - [Extracting Token IDs from Registers](#extracting-token-ids-from-registers)\n  - [Decoding Complex Types (Tuples, Options, Collections)](#decoding-complex-types-tuples-options-collections)\n  - [Compiling ErgoScript to ErgoTree](#compiling-ergoscript-to-ergotree)\n  - [Troubleshooting Common Issues](#troubleshooting-common-issues)\n    - [1. ErgoTree Comparison Failures](#1-ergotree-comparison-failures)\n    - [2. Unexpected Register Format](#2-unexpected-register-format)\n  - [Relationship Diagram](#relationship-diagram)\n  - [Related Documentation](#related-documentation)\n\n---"
    },
    {
      "heading": "Validating Box Ownership (SigmaProp from Register)",
      "level": 2,
      "content": "A common requirement when building off-chain logic is to validate conditions that mirror on-chain checks. One such check is verifying that an input box belongs to a specific owner whose public key (as a [SigmaProp](../scs/sigma.md)) is stored in another box's [register](../scs/boxes-and-registers.md). This is often needed for refund scenarios or proving ownership before allowing an action.\n\nThe core task involves:\n\n1. Extracting the owner's SigmaProp bytes from a register (e.g., R4).\n2. Deserializing these bytes correctly.\n3. Converting the public key bytes into the owner's P2PK [ErgoTree](../scs/ergotree.md).\n4. Comparing this derived ErgoTree with the ErgoTree of the box being validated.\n\n**Important:** Directly constructing `ErgoAddress` from `SSigmaProp` is not the correct approach in Fleet SDK. You need to extract the public key bytes first."
    },
    {
      "heading": "Complete Example:",
      "level": 3,
      "content": "```typescript\nimport { \n  Box, \n  ErgoAddress, \n  SByte, // Note: SByte might not be directly needed for deserialization logic\n  SColl, \n  SGroupElement, \n  SSigmaProp \n} from \"@fleet-sdk/core\";\nimport { deserialize } from \"@fleet-sdk/serializer\"; // Fleet's serializer is key\n\n/**\n * Validates if a box belongs to the owner specified in another box's register R4.\n * Assumes R4 contains a serialized SigmaProp representing the owner's public key.\n * @param boxToValidate The box whose ownership we want to verify.\n * @param boxWithOwnerInfo Box containing owner's SigmaProp in R4.\n * @returns boolean indicating if ownership is valid.\n */\nfunction validateBoxOwnership(boxToValidate: Box, boxWithOwnerInfo: Box): boolean {\n  try {\n    // 1. Extract SigmaProp bytes from register R4\n    const registerValueHex = boxWithOwnerInfo.additionalRegisters.R4;\n    if (!registerValueHex) {\n      console.error(\"Register R4 is empty or not present.\");\n      return false;\n    }\n    \n    // 2. Deserialize the register value (hex string)\n    // The register often contains a serialized SigmaProp, typically starting with '07' (SColl(SByte)) or 'cd' (SSigmaProp)\n    const deserializedValue = deserialize(registerValueHex);\n    \n    // 3. Extract the raw public key bytes based on common serialization formats\n    let publicKeyBytes: Uint8Array;\n    \n    if (deserializedValue.type === \"SColl\" && deserializedValue.elemType === \"SByte\") {\n      // Format: SColl(SByte) - a simple collection of bytes\n      publicKeyBytes = new Uint8Array(deserializedValue.value);\n    } else if (deserializedValue.type === \"SSigmaProp\") {\n      // Format: SSigmaProp(SGroupElement(bytes))\n      if (deserializedValue.value?.type === \"SGroupElement\") {\n        publicKeyBytes = new Uint8Array(deserializedValue.value.value);\n      } else {\n        throw new Error(`Unsupported SigmaProp inner type: ${deserializedValue.value?.type}`);\n      }\n    } else {\n      throw new Error(`Unsupported register format type: ${deserializedValue.type}`);\n    }\n\n    // Ensure we got valid public key bytes (typically 33 bytes for compressed keys)\n    if (!publicKeyBytes || publicKeyBytes.length !== 33) {\n        throw new Error(`Extracted public key bytes are invalid (length ${publicKeyBytes?.length})`);\n    }\n    \n    // 4. Create the ErgoAddress from the public key bytes\n    const ownerAddress = ErgoAddress.fromPublicKey(publicKeyBytes);\n    \n    // 5. Get the ErgoTree (P2PK script) from the derived address\n    const ownerErgoTree = ownerAddress.ergoTree;\n    \n    // 6. Compare the derived ErgoTree with the ErgoTree of the box to validate\n    return boxToValidate.ergoTree === ownerErgoTree;\n    \n  } catch (error) {\n    console.error(\"Error validating box ownership:\", error);\n    return false;\n  }\n}\n\n// --- Usage Example ---\n/* \n// Assume 'clientBox' is the box we need to validate\n// Assume 'sessionBox' holds the owner's SigmaProp in R4\nconst clientBox: Box = { ... }; // Populate with actual box data\nconst sessionBox: Box = { ... }; // Populate with actual box data\n\nconst isOwnerValid = validateBoxOwnership(clientBox, sessionBox);\nconsole.log(\"Box ownership validation result:\", isOwnerValid); \n*/\n```\n\n---"
    },
    {
      "heading": "Working with Numeric Registers",
      "level": 2,
      "content": "Contracts often store numeric values like deadlines (timestamps), counts, or amounts in registers. These are typically stored as `SInt` or `SLong`.\n\n```typescript\nimport { Box, SLong, SInt } from \"@fleet-sdk/core\"; // SInt might be needed depending on contract\nimport { deserialize } from \"@fleet-sdk/serializer\";\n\n/**\n * Extracts a numeric value (BigInt) from a specified register.\n * Handles SLong and SInt types.\n * @param box The box containing the register.\n * @param register The register name (R4-R9).\n * @returns The numeric value as BigInt, or null if not found/not a supported number type.\n */\nfunction getNumericFromRegister(box: Box, register: \"R4\" | \"R5\" | \"R6\" | \"R7\" | \"R8\" | \"R9\"): bigint | null {\n  try {\n    const registerValueHex = box.additionalRegisters[register];\n    if (!registerValueHex) {\n        // console.warn(`Register ${register} not found in box ${box.boxId}`);\n        return null;\n    }\n    \n    const deserialized = deserialize(registerValueHex);\n    \n    // Handle different numeric types\n    if (deserialized.type === \"SLong\") {\n      // SLong stores value as string, convert to BigInt\n      return BigInt(deserialized.value); \n    } else if (deserialized.type === \"SInt\") {\n      // SInt stores value as number, convert to BigInt\n      return BigInt(deserialized.value); \n    } else {\n      // console.warn(`Register ${register} has non-numeric type: ${deserialized.type}`);\n      return null;\n    }\n    \n  } catch (error) {\n    console.error(`Error extracting numeric value from ${register} in box ${box.boxId}:`, error);\n    return null;\n  }\n}\n\n// --- Usage Example ---\n/*\nconst contractBox: Box = { ... }; // Populate with actual box data\nconst deadlineTimestamp = getNumericFromRegister(contractBox, \"R4\");\n\nif (deadlineTimestamp !== null) {\n  if (BigInt(Date.now()) > deadlineTimestamp) {\n    console.log(\"Deadline has passed!\");\n  } else {\n    console.log(\"Deadline is still in the future.\");\n  }\n} else {\n  console.log(\"Could not read deadline from R4.\");\n}\n*/\n```\n\n---"
    },
    {
      "heading": "Extracting Token IDs from Registers",
      "level": 2,
      "content": "Token IDs are frequently stored in registers, usually as a collection of bytes (`SColl(SByte)`).\n\n```typescript\nimport { Box } from \"@fleet-sdk/core\";\nimport { deserialize } from \"@fleet-sdk/serializer\";\nimport { Buffer } from 'buffer'; // Use Buffer for hex conversion\n\n/**\n * Extracts a token ID (hex string) from a register containing SColl(SByte).\n * @param box The box containing the register.\n * @param register The register name (R4-R9).\n * @returns The token ID as a hex string, or null if not found or not CollByte format.\n */\nfunction getTokenIdFromRegister(box: Box, register: \"R4\" | \"R5\" | \"R6\" | \"R7\" | \"R8\" | \"R9\"): string | null {\n  try {\n    const registerValueHex = box.additionalRegisters[register];\n    if (!registerValueHex) {\n      // console.warn(`Register ${register} not found in box ${box.boxId}`);\n      return null;\n    }\n    \n    const deserialized = deserialize(registerValueHex);\n    \n    // Handle CollByte format (most common for token IDs / Box IDs / Tx IDs)\n    if (deserialized.type === \"SColl\" && deserialized.elemType === \"SByte\") {\n      // Convert byte array (deserialized.value) to hex string\n      return Buffer.from(deserialized.value).toString('hex');\n    } else {\n      // console.warn(`Register ${register} is not in CollByte format: ${deserialized.type}`);\n      return null;\n    }\n    \n  } catch (error) {\n    console.error(`Error extracting token ID from ${register} in box ${box.boxId}:`, error);\n    return null;\n  }\n}\n\n// --- Usage Example ---\n/*\nconst contractBox: Box = { ... }; // Populate with actual box data\nconst requiredTokenId = getTokenIdFromRegister(contractBox, \"R5\");\n\nif (requiredTokenId) {\n  console.log(`Contract requires token ID: ${requiredTokenId}`);\n  // Now you can check if an input box contains this token\n} else {\n  console.log(\"Could not read required token ID from R5.\");\n}\n*/\n```\n\n---"
    },
    {
      "heading": "Decoding Complex Types (Tuples, Options, Collections)",
      "level": 2,
      "content": "Contracts might store more complex data structures in registers, such as tuples `(TypeA, TypeB)`, optional values `Option[TypeA]`, or collections `Coll[TypeA]`. Fleet's `deserialize` function handles these, returning a nested object structure that mirrors the on-chain type. You need to inspect this structure to extract the individual components.\n\n**General Approach:**\n\n1.  Call `deserialize(registerValueHex)`.\n2.  Check the `type` property of the result (e.g., `\"STuple\"`, `\"SColl\"`, `\"SOption\"`).\n3.  Access the `value` property.\n    *   For `STuple` and `SColl`, `value` is typically an array. Iterate through it, inspecting the `type` and `value` of each element.\n    *   For `SOption`, `value` is either `null` (representing `None`) or an object representing the `Some(value)` content. Check if `value` is `null` before accessing its properties.\n4.  Recursively apply this process for nested structures.\n\n---\n**Example 1: Decoding a Tuple `(SigmaProp, Long)` from R5**\n\nAssume R5 contains a serialized tuple where the first element is a `SigmaProp` (owner's public key) and the second is a `Long` (deadline).\n\n```typescript\nimport { Box } from \"@fleet-sdk/core\";\nimport { deserialize } from \"@fleet-sdk/serializer\";\nimport { Buffer } from 'buffer'; \n\n/**\n * Extracts data from a register assumed to contain a serialized (SigmaProp, Long) tuple.\n * @param box The box containing the register.\n * @param register The register name (R4-R9).\n * @returns An object { ownerPubKeyHex: string, deadline: bigint } or null if format is wrong.\n */\nfunction decodeSigmaPropLongTuple(box: Box, register: \"R4\" | \"R5\" | \"R6\" | \"R7\" | \"R8\" | \"R9\"): { ownerPubKeyHex: string; deadline: bigint } | null {\n  try {\n    const registerValueHex = box.additionalRegisters[register];\n    if (!registerValueHex) return null;\n\n    const deserialized = deserialize(registerValueHex);\n\n    // Expecting STuple with two items\n    if (deserialized.type !== \"STuple\" || !Array.isArray(deserialized.value) || deserialized.value.length !== 2) {\n      console.warn(`Register ${register} is not the expected STuple format.`);\n      return null;\n    }\n\n    const [item1, item2] = deserialized.value;\n\n    // Extract SigmaProp (assuming SSigmaProp(SGroupElement(bytes)))\n    let ownerPubKeyBytes: Uint8Array | null = null;\n    if (item1?.type === \"SSigmaProp\" && item1.value?.type === \"SGroupElement\" && item1.value.value) {\n       ownerPubKeyBytes = new Uint8Array(item1.value.value);\n    } else {\n       console.warn(`First tuple item in ${register} is not the expected SSigmaProp(SGroupElement(...)) format.`);\n       return null;\n    }\n    \n    if (!ownerPubKeyBytes || ownerPubKeyBytes.length !== 33) {\n        console.warn(`Extracted public key bytes from tuple in ${register} are invalid.`);\n        return null;\n    }\n    const ownerPubKeyHex = Buffer.from(ownerPubKeyBytes).toString('hex');\n\n\n    // Extract Long\n    let deadline: bigint | null = null;\n    if (item2?.type === \"SLong\" && typeof item2.value === 'string') {\n        deadline = BigInt(item2.value);\n    } else {\n        console.warn(`Second tuple item in ${register} is not the expected SLong format.`);\n        return null;\n    }\n\n    return { ownerPubKeyHex, deadline };\n\n  } catch (error) {\n    console.error(`Error decoding tuple from ${register} in box ${box.boxId}:`, error);\n    return null;\n  }\n}\n\n// --- Usage Example ---\n/*\nconst contractBox: Box = { ... }; // Populate with actual box data\nconst tupleData = decodeSigmaPropLongTuple(contractBox, \"R5\");\n\nif (tupleData) {\n  console.log(`Owner PubKey Hex: ${tupleData.ownerPubKeyHex}`);\n  console.log(`Deadline: ${tupleData.deadline}`);\n  // You can now use ErgoAddress.fromPublicKey(Buffer.from(tupleData.ownerPubKeyHex, 'hex'))\n} else {\n  console.log(\"Could not decode (SigmaProp, Long) tuple from R5.\");\n}\n*/\n```\n\n---\n**Example 2: Decoding an `Option[Int]` from R6**\n\nAssume R6 might contain an optional integer value.\n\n```typescript\nimport { Box } from \"@fleet-sdk/core\";\nimport { deserialize } from \"@fleet-sdk/serializer\";\n\n/**\n * Extracts an optional integer value from a register assumed to contain Option[Int].\n * @param box The box containing the register.\n * @param register The register name (R4-R9).\n * @returns The integer value if Some(Int), or null if None or wrong format.\n */\nfunction decodeOptionInt(box: Box, register: \"R4\" | \"R5\" | \"R6\" | \"R7\" | \"R8\" | \"R9\"): number | null {\n  try {\n    const registerValueHex = box.additionalRegisters[register];\n    if (!registerValueHex) return null;\n\n    const deserialized = deserialize(registerValueHex);\n\n    // Expecting SOption\n    if (deserialized.type !== \"SOption\") {\n      console.warn(`Register ${register} is not the expected SOption format.`);\n      return null;\n    }\n\n    // Check if value is null (representing None)\n    if (deserialized.value === null) {\n      return null; // It's None\n    }\n\n    // If not null, it should be Some(value). Check the inner type.\n    const innerValue = deserialized.value;\n    if (innerValue?.type === \"SInt\" && typeof innerValue.value === 'number') {\n      return innerValue.value;\n    } else {\n      console.warn(`Inner value of Option in ${register} is not the expected SInt format.`);\n      return null;\n    }\n\n  } catch (error) {\n    console.error(`Error decoding Option[Int] from ${register} in box ${box.boxId}:`, error);\n    return null;\n  }\n}\n\n// --- Usage Example ---\n/*\nconst contractBox: Box = { ... }; // Populate with actual box data\nconst optionalValue = decodeOptionInt(contractBox, \"R6\");\n\nif (optionalValue !== null) {\n  console.log(`R6 contains the value: ${optionalValue}`);\n} else {\n  console.log(\"R6 is empty (None) or has an unexpected format.\");\n}\n*/\n```\n\n---\n**Example 3: Decoding a `Coll[Int]` from R7**\n\nAssume R7 contains a collection (array) of integers.\n\n```typescript\nimport { Box } from \"@fleet-sdk/core\";\nimport { deserialize } from \"@fleet-sdk/serializer\";\n\n/**\n * Extracts an array of integers from a register assumed to contain Coll[Int].\n * @param box The box containing the register.\n * @param register The register name (R4-R9).\n * @returns An array of numbers, or null if wrong format.\n */\nfunction decodeCollInt(box: Box, register: \"R4\" | \"R5\" | \"R6\" | \"R7\" | \"R8\" | \"R9\"): number[] | null {\n  try {\n    const registerValueHex = box.additionalRegisters[register];\n    if (!registerValueHex) return null;\n\n    const deserialized = deserialize(registerValueHex);\n\n    // Expecting SColl with SInt elements\n    if (deserialized.type !== \"SColl\" || deserialized.elemType !== \"SInt\" || !Array.isArray(deserialized.value)) {\n      console.warn(`Register ${register} is not the expected SColl[SInt] format.`);\n      return null;\n    }\n\n    // The value is already an array of numbers for SColl[SInt]\n    return deserialized.value as number[];\n\n  } catch (error) {\n    console.error(`Error decoding Coll[Int] from ${register} in box ${box.boxId}:`, error);\n    return null;\n  }\n}\n\n// --- Usage Example ---\n/*\nconst contractBox: Box = { ... }; // Populate with actual box data\nconst integerArray = decodeCollInt(contractBox, \"R7\");\n\nif (integerArray) {\n  console.log(`R7 contains integers: ${integerArray.join(\", \")}`);\n  // integerArray.forEach(num => console.log(num));\n} else {\n  console.log(\"Could not decode Coll[Int] from R7.\");\n}\n*/\n```\n\n---\n**Note on `SigmaProp` and `Coll[Byte]`:**\n\n*   Decoding a `SigmaProp` (typically to get the underlying public key bytes) is shown in the [Validating Box Ownership](#validating-box-ownership-sigmaprop-from-register) example.\n*   Decoding a simple `Coll[Byte]` (often used for Token IDs, Box IDs, Tx IDs, or sometimes raw public keys) is shown in the [Extracting Token IDs](#extracting-token-ids-from-registers) example.\n\n---"
    },
    {
      "heading": "Compiling ErgoScript to ErgoTree",
      "level": 2,
      "content": "The Fleet SDK includes a compiler module to convert [ErgoScript](../scs/ergoscript.md) source code into its corresponding ErgoTree hex string, which is needed when creating contract boxes.\n\n```typescript\nimport { compile } from \"@fleet-sdk/compiler\";\n\n/**\n * Compiles an ErgoScript string to its ErgoTree hex representation.\n * @param script The ErgoScript source code.\n * @returns Promise resolving to the compiled ErgoTree hex string.\n * @throws Error if compilation fails.\n */\nasync function compileToErgoTree(script: string): Promise<string> {\n  try {\n    // The compile function returns an object with address, ergoTree, template, etc.\n    const result = await compile(script); \n    if (!result || !result.ergoTree) {\n        throw new Error(\"Compilation result did not contain ErgoTree.\");\n    }\n    return result.ergoTree;\n  } catch (error) {\n    console.error(\"ErgoScript Compilation Error:\", error);\n    // Rethrow or handle as needed\n    throw error; \n  }\n}\n\n// --- Usage Example ---\nconst timedContractScript = `{\n  // Contract allows spending only after a certain height (deadline)\n  val deadline = SELF.R4[Long].getOrElse(0L) // Get deadline from R4, default 0\n  sigmaProp(HEIGHT >= deadline) // Proposition is true if current height >= deadline\n}`;\n\nasync function exampleCompilation() {\n  try {\n    const compiledTree = await compileToErgoTree(timedContractScript);\n    console.log(\"Compiled ErgoTree:\", compiledTree);\n    // Use this compiledTree when building an output box\n  } catch (error) {\n    console.error(\"Failed to compile contract script.\");\n  }\n}\n\n// exampleCompilation(); // Uncomment to run\n```\n\n---"
    },
    {
      "heading": "Troubleshooting Common Issues",
      "level": 2,
      "content": "Working with registers and ErgoTrees off-chain can sometimes lead to unexpected issues. Here are some common problems and how to approach them:"
    },
    {
      "heading": "1. ErgoTree Comparison Failures",
      "level": 3,
      "content": "**Problem:** You've derived an ErgoTree from a register's SigmaProp, but it doesn't match the `ergoTree` property of the box you expect it to match, even though you believe they represent the same P2PK address.\n\n**Possible Causes & Solutions:**\n\n*   **Serialization Mismatch:** The most likely cause is that the `deserialize` function didn't correctly interpret the register data into the raw public key bytes needed by `ErgoAddress.fromPublicKey`. Double-check how the SigmaProp was serialized *into* the register on-chain. Common formats include `SColl(SByte)` containing the 33 public key bytes, or `SSigmaProp(SGroupElement(...))` containing the same bytes nested deeper. Use `detectRegisterFormat` below or inspect the raw hex.\n*   **Incorrect Prefix:** ErgoTrees can have different hexadecimal prefixes depending on their structure (e.g., `00` for basic P2PK, `0e` for hashes, etc.). Ensure you are comparing apples to apples. If one tree starts with `0008cd` (standard P2PK) and the other doesn't, they represent different script types.\n*   **Address Type Mismatch:** Are you sure the register contains a standard P2PK SigmaProp? If the contract uses a more complex script (P2S), deriving the ErgoTree from just a public key won't work. You'd need to compile the corresponding ErgoScript.\n\n```typescript\nfunction troubleshootErgoTreeComparison(ergoTree1: string, ergoTree2: string): string {\n  if (ergoTree1 === ergoTree2) return \"Exact Match: Trees are identical.\";\n  \n  // Check for common P2PK prefix (00 + ProveDlog op code + cd)\n  const p2pkPrefix = \"0008cd\";\n  const tree1IsP2PK = ergoTree1.startsWith(p2pkPrefix);\n  const tree2IsP2PK = ergoTree2.startsWith(p2pkPrefix);\n\n  if (tree1IsP2PK && tree2IsP2PK) {\n    // Both seem P2PK, but don't match. Check lengths.\n     if (ergoTree1.length !== ergoTree2.length) {\n         return \"Mismatch: Both seem P2PK but have different lengths. Possible data corruption or different public keys.\";\n     }\n     // If lengths match, the public keys themselves must be different.\n     return \"Mismatch: Both seem P2PK with same length, but represent different public keys.\";\n  } else if (tree1IsP2PK !== tree2IsP2PK) {\n    return `Mismatch: One tree appears P2PK (${p2pkPrefix} prefix), the other does not. Comparing different script types?`;\n  } else {\n    // Neither starts with P2PK prefix, could be complex scripts or other data\n     if (ergoTree1.length !== ergoTree2.length) {\n         return \"Mismatch: Neither seems standard P2PK, and lengths differ.\";\n     }\n     return \"Mismatch: Neither seems standard P2PK, but lengths match. Comparing complex scripts?\";\n  }\n}\n```"
    },
    {
      "heading": "2. Unexpected Register Format",
      "level": 3,
      "content": "**Problem:** You try to deserialize a register value, but the resulting type (`deserialized.type`) is not what you expected (e.g., you expected `SLong` but got `SColl(SByte)`).\n\n**Solution:** Inspect the raw register value (hex string) and use a helper function to guess the format, or consult the contract source code to understand what type *should* be stored.\n\n```typescript\nfunction detectRegisterFormat(registerHex: string): string {\n  if (!registerHex || registerHex.length < 2) return \"Invalid or empty register value\";\n\n  const prefix = registerHex.substring(0, 2);\n  const lengthByte = parseInt(registerHex.substring(2, 4), 16); // For CollByte length\n\n  if (prefix === \"0e\") { // SConstant placeholder + length byte\n      if (registerHex.length === 68) return \"Likely a Blake2b256 hash (0e + 20 + 32 bytes)\";\n      return `Likely some hash or ID prefixed with 0e, length byte ${lengthByte}`;\n  } else if (prefix === \"00\") {\n      if (registerHex.startsWith(\"0008cd\")) return \"Likely a P2PK ErgoTree\";\n      return \"Starts with 00, possibly complex ErgoTree or other structure.\";\n  } else if (prefix === \"04\") { // SInt\n      return \"Likely an SInt (Integer)\";\n  } else if (prefix === \"05\") { // SLong\n      return \"Likely an SLong (Long Integer / BigInt)\";\n  } else if (prefix === \"07\") { // SColl(SByte)\n      return `Likely a CollByte (serialized byte array), length byte indicates ${lengthByte} bytes follow`;\n  } else if (prefix === \"cd\") { // SSigmaProp direct serialization (less common in registers)\n      return \"Likely a raw SSigmaProp (without 00 ErgoTree wrapper)\";\n  } else {\n      // Add more checks for other SType prefixes if needed (e.g., 01 for SBoolean, etc.)\n      // See: https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/sigmastate/src/main/scala/sigmastate/serialization/TypeSerializer.scala\n      return `Unknown format starting with prefix ${prefix}`;\n  }\n}\n\n// --- Usage Example ---\n/*\nconst r4Value = contractBox.additionalRegisters.R4;\nif (r4Value) {\n    console.log(`R4 Format Guess: ${detectRegisterFormat(r4Value)}`);\n}\n*/\n```\n\n---"
    },
    {
      "heading": "Relationship Diagram",
      "level": 2,
      "content": "<!--\n*(Placeholder for a visual diagram illustrating how ErgoAddress, Public Key (GroupElement), SigmaProp, and ErgoTree (P2PK Script) relate to each other)*\n-->\n\n```mermaid\ngraph TD\n    A[Ergo Address String] -->|\"ErgoAddress decode\"| B[Public Key Bytes]\n    B -->|\"ErgoAddress fromPublicKey\"| C[ErgoAddress Object]\n    B -->|\"SGroupElement\"| D[SGroupElement Object]\n    D -->|\"SSigmaProp\"| E[SSigmaProp Object]\n    C -->|\"address ergoTree\"| F[ErgoTree Hex - P2PK Script]\n    E -->|\"ErgoAddress sigmaProp ergoTree\"| F\n\n    style F fill:#f9f,stroke:#333,stroke-width:2px\n    style B fill:#ccf,stroke:#333,stroke-width:2px\n```\n\n*This diagram shows the typical conversion paths for P2PK addresses.*\n\n---"
    },
    {
      "heading": "Related Documentation",
      "level": 2,
      "content": "- [ErgoScript Sigma Propositions](../scs/sigma.md)\n- [Box Registers Specification](../scs/boxes-and-registers.md)\n- [ErgoTree Specification](../scs/ergotree.md)\n- [Fleet SDK GitHub Examples](https://github.com/fleet-sdk/fleet-by-example)\n- [Fleet SDK Compiler](https://fleet-sdk.github.io/docs/compiler)\n- [Fleet SDK Serializer](https://fleet-sdk.github.io/docs/serializer-overview)"
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/tutorials/fleet-sdk-recipes.md",
  "processed_at": "2025-05-11T19:39:08.213269",
  "ai_processed": true
}