{
  "id": "docs_dev_data-model_box_md",
  "title": "The Ergo 'Box' model",
  "summary": "The Ergo 'Box' model is a transactional model similar to Bitcoin's UTXO model, where transactions create and consume single-use entities called 'boxes'. Ergo's boxes are more flexible than traditional UTXOs, as they can contain additional data, scripts, and registers beyond just the unspent transaction output balance. Each box has a unique ID derived from its contents, and transactions consist of both input and output boxes. Boxes are integral to the Ergo protocol, with the active box set authenticated through a hash-based data structure. The document provides details on box properties, functions, and example usage in ErgoScript.",
  "qa_pairs": [
    {
      "question": "What is a 'box' in the context of the Ergo blockchain?",
      "answer": "A box is an immutable unit in the Ergo blockchain that can be created or removed, but never altered. It houses data, code, and registers, with all of its contents exclusively stored in the registers."
    },
    {
      "question": "What are the four pre-defined registers in an Ergo box?",
      "answer": "The four pre-defined registers in an Ergo box contain the box's monetary value, its protection script (the ErgoTree), and the ID of the transaction that created the box."
    },
    {
      "question": "How are Ergo box IDs generated?",
      "answer": "Each box has a unique ID, derived from the unique contents of the box, including the data of the transaction that created it. The box ID is computed by applying the blake2b256 hash function to the box's content, expressed as a Coll[Byte]."
    },
    {
      "question": "What is the purpose of the 'bytesWithoutRef' function in Ergo?",
      "answer": "The 'bytesWithoutRef' function can be used to retrieve a Coll[Byte] that excludes the 'creationInfo' (R3 register) from the box's content, which includes the transaction id and associated output index."
    },
    {
      "question": "What is the 'proof-of-no-premine' box in the Ergo genesis state?",
      "answer": "The 'proof-of-no-premine' box in the Ergo genesis state contains the last block IDs from Bitcoin and Ethereum at the launch time, as well as the latest news headlines, stored in the additional registers (R4-R8)."
    }
  ],
  "sections": [
    {
      "heading": "Introduction",
      "level": 0,
      "content": "---\ntags:\n  - Data Model\n  - Box\n  - UTXO\n  - eUTXO\n---"
    },
    {
      "heading": "The Ergo 'Box' model",
      "level": 1,
      "content": "*(Back to: [Data Model Overview](data-model.md))*\n\nErgo uses a transactional model similar to Bitcoin's [Unspent Transaction Output (UTXO)](eutxo.md) model. In this model, [transactions](transactions.md) create and consume single-use entities called ***'boxes'***.\n\nIn [ErgoScript](ergoscript.md), a 'box' is a versatile version of a UTXO. It represents not only the amount of cryptocurrency owned by an [address](address.md), but also contains '[registers](registers.md)' for additional data. This data can range from simple values to complex structures, which can be used in transactions and [smart contract](ergoscript.md) execution.\n\nThis makes Ergo's box different from a traditional UTXO, which only represents an amount of unspent cryptocurrency associated with a certain address. In UTXO-based cryptocurrencies, each transaction consumes one or more UTXOs as [inputs](transactions.md#anatomy) and creates one or more UTXOs as [outputs](transactions.md#anatomy), with the 'unspent' outputs being the 'coins' that can be spent in future transactions.\n\nThe term 'box' in Ergo's context captures the idea that these entities are like containers holding various types of information (value, [tokens](eip4.md), custom data, etc.), beyond just the unspent transaction output balance. This makes the boxes in Ergo significantly more flexible and functional, enabling more complex operations, such as running [scripts](ergoscript.md) or smart contracts, directly on the blockchain."
    },
    {
      "heading": "Key Points",
      "level": 2,
      "content": "- A box is an immutable unit, which can be created or removed, but never altered.\n- The box is not just a simple coin; it houses data, code, and [registers](registers.md), with all of its contents exclusively stored in the registers.\n- Four pre-defined registers contain the box's monetary value, its protection script (the [ErgoTree](ergotree.md)), and the ID of the transaction that created the box.\n- Each box has a unique ID, derived from the unique contents of the box, including the data of the transaction that created it.\n- Boxes are integral to the Ergo [protocol](protocol-overview.md). The active box set (UTXO set) is authenticated through a [hash-based data structure](structures/merkle/merkle-tree.md), facilitating the development of [lightweight full nodes](light-full-node.md), as detailed in [this paper](https://eprint.iacr.org/2016/994).\n- A box can hold up to six additional [registers](registers.md) (R4-R9) with typed data, accessible by the script.\n- Transactions consist of both *input* and *output* boxes."
    },
    {
      "heading": "An example box",
      "level": 2,
      "content": "Consider the 'proof-of-no-premine' box from the Ergo genesis state. This box contains the last block IDs from Bitcoin and Ethereum at the launch time, as well as the latest news headlines:\n\n```JSON\n     {\n    \"boxId\": \"b8ce8cfe331e5eadfb0783bdc375c94413433f65e1e45857d71550d42e4d83bd\",\n    \"value\": 1000000000,\n    \"ergoTree\": \"10010100d17300\",\n    \"assets\": [],\n    \"creationHeight\": 0,\n    \"additionalRegisters\": {\n      \"R5\": \"0e42307864303761393732393334363864393133326335613261646162326535326132333030396536373938363038653437623064323632336337653365393233343633\",\n      \"R6\": \"0e464272657869743a20626f746820546f727920736964657320706c617920646f776e207269736b206f66206e6f2d6465616c20616674657220627573696e65737320616c61726d\",\n      \"R8\": \"0e45d094d0b8d0b2d0b8d0b4d0b5d0bdd0b4d18b20d0a7d0a2d09fd09720d0b2d18bd180d0b0d181d182d183d18220d0bdd0b02033332520d0bdd0b020d0b0d0bad186d0b8d18e\",\n      \"R7\": \"0e54e8bfb0e8af84efbc9ae5b9b3e8a1a1e38081e68c81e7bbade38081e58c85e5aeb9e28094e28094e696b0e697b6e4bba3e5ba94e5afb9e585a8e79083e58c96e68c91e68898e79a84e4b8ade59bbde4b98be98193\",\n      \"R4\": \"0e4030303030303030303030303030303030303031346332653265376533336435316165376536366636636362363934326333343337313237623336633333373437\"\n    }\n  }\n```"
    },
    {
      "heading": "Additional Box Functions",
      "level": 2,
      "content": "Besides the [registers](registers.md), each box features a unique identification hash that can be referenced using the `id` function in [ErgoScript](ergoscript.md). Box ids are computed by applying the `blake2b256` hash function to the box's content, expressed as a `Coll[Byte]`. You can directly access the un-hashed byte collection representing a box using the `bytes` function. Note that each box\u2019s content and id are cryptographically unique, meaning that no two boxes within the blockchain can share the same id or content bytes. This uniqueness is guaranteed by the inclusion of `creationInfo` (R3 register) in each box, as transaction ids and associated output indexes must be unique to a given UTXO. The `bytesWithoutRef` function can be used to retrieve a `Coll[Byte]` that excludes such information."
    },
    {
      "heading": "Example",
      "level": 3,
      "content": "```scala\n{ // Example ErgoScript using box properties\n\t// Retrieve the value and token multipliers from the registers of the current box (SELF)\n\tval valueMultiplier = SELF.R4[Int].get\n\tval tokenMultiplier = INPUTS(1).R4[Int].get // Accessing register of another input box\n\n\t// Check if the current box being spent (SELF) is the same as the first input box\n\tif(SELF.id == INPUTS(0).id){\n\t\t// If it is, check if the first output box has the correct value and token amounts\n\t\tval outputValue = OUTPUTS(0).value == SELF.value * valueMultiplier\n\t\tval outputTokens = OUTPUTS(0).tokens(0)._2 == SELF.value * tokenMultiplier\n\t\t// Return a Sigma proposition that is true only if both outputValue and outputTokens are true\n\t\tsigmaProp(outputValue && outputTokens)\n\t}else{\n\t\t// If the current box is not the same as the first input box, check if the output goes to a specified address\n\t\tval outputGoesToCheese = {\n\t\t\t// Create a public key that corresponds to a specific address\n\t\t\tPK(\"9etXmP7D3ZkWssDopWcWkCPpjn22RVuEyXoFSbVPWAvvzDbcDXE\").propBytes\n\t\t\t\t== OUTPUTS(0).propositionBytes // propositionBytes holds the script (ErgoTree)\n\t\t}\n\t\t// Return a Sigma proposition that is true only if outputGoesToCheese is true\n\t\tsigmaProp(outputGoesToCheese)\n\t}\n}\n// Context Variables used: SELF, INPUTS, OUTPUTS (See ../scs/blockchain-context.md)\n// Functions used: sigmaProp, PK (See ../scs/sigma.md)\n```"
    },
    {
      "heading": "Additional Resources",
      "level": 2,
      "content": "- See the [Transaction Format](format.md) page for details on how boxes are serialized within transactions.\n- For the box type description in the [ErgoScript language specification](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/docs/LangSpec.md#box-type).\n- Visit [ErgoAddress.scala](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/ec71a6f988f7412bc36199f46e7ad8db643478c7/sigmastate/src/main/scala/org/ergoplatform/ErgoAddress.scala), [ErgoBoxCandidate](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/interpreter/shared/src/main/scala/org/ergoplatform/ErgoBoxCandidate.scala#L24-L43), and [ErgoBox](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/interpreter/shared/src/main/scala/org/ergoplatform/ErgoBox.scala#L22-L59) in the reference client codebase.\n- For an in-depth explanation on Ergo box modeling, see [this page](box_modeling.md)."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/data-model/box.md",
  "processed_at": "2025-05-11T19:19:13.063151",
  "ai_processed": true
}