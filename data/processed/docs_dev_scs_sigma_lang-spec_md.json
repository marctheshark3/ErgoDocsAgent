{
  "id": "docs_dev_scs_sigma_lang-spec_md",
  "title": "ErgoScript Language Description",
  "summary": "ErgoScript is a language used to write contracts for the Ergo blockchain. ErgoScript contracts can be compiled to ErgoTrees, serialized, and stored in UTXOs. The language has features like Scala-like syntax, high-order functions, static typing, and predefined types like Box, SigmaProp, and GroupElement. The document provides an overview of the language features, data types, and examples of using the language with the Ergo Appkit library.",
  "qa_pairs": [
    {
      "question": "What is the purpose of ErgoScript?",
      "answer": "ErgoScript is a language used to write contracts for the Ergo blockchain."
    },
    {
      "question": "What is the relationship between ErgoScript and ErgoTrees?",
      "answer": "ErgoScript contracts can be compiled to ErgoTrees, which are then serialized and stored in UTXOs."
    },
    {
      "question": "What are some key features of the ErgoScript language?",
      "answer": "ErgoScript has features like standard syntax and semantics, high-order language with first-class lambdas, static typing with local type inference, and various data types like Pair, Coll, Option."
    },
    {
      "question": "How can the ErgoScript compiler be used?",
      "answer": "The ErgoScript compiler is published as a library that is cross-compiled for Java 7 and Java 8+, and can be used from any JVM language, Android, or JavaFX."
    },
    {
      "question": "What are some of the operations and constructs available in ErgoScript?",
      "answer": "ErgoScript provides binary operations, predefined primitives, val declarations, if-then-else clauses, collection literals, high-order collection operations, field access, method invocation, and function invocations."
    }
  ],
  "sections": [
    {
      "heading": "ErgoScript Language Description",
      "level": 1,
      "content": "> \ud83d\udd17 From [sigmastate-interpreter](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/docs/LangSpec.md)"
    },
    {
      "heading": "Introduction",
      "level": 3,
      "content": "ErgoScript is a language to write contracts for [Ergo blockchain](https://ergoplatform.org). ErgoScript contracts can be compiled to [ErgoTrees](ergotree.md), [serialized](serialization.md) and stored in UTXOs.\n\nA good starting point to writing contracts is to use [ErgoScript by Example](https://github.com/ergoplatform/ergoscript-by-example) with [Ergo Playgrounds](https://github.com/ergoplatform/ergo-playgrounds) or [Appkit](https://github.com/ergoplatform/ergo-appkit).\n\nThe ErgoScript compiler is [published](https://mvnrepository.com/artifact/org.scorexfoundation/sigma-state)\nas a library which is cross compiled for Java 7 and Java 8+ and can be used from any JVM lanugage, Android or JavaFX.\n\nThe following example shows how source code of ErgoScript contract can be used to create new transaction using [Appkit](https://github.com/ergoplatform/ergo-appkit), see [FreezeCoin.java](https://github.com/aslesarenko/ergo-appkit-examples/blob/master/java-examples/src/main/java/org/ergoplatform/appkit/examples/FreezeCoin.java) for more details.\n\n```scala\n// To create transaction we use a builder obtained from the context\n// the builder keeps relationship with the context to access necessary blockchain data.\nUnsignedTransactionBuilder txB = ctx.newTxBuilder();\n\n// create new box using new builder obtained from the transaction builder\n// in this case we compile new ErgoContract from source ErgoScript code\nOutBox newBox = txB.outBoxBuilder()\n        .value(amountToPay)\n        .contract(ctx.compileContract(\n                ConstantsBuilder.create()\n                        .item(\"freezeDeadline\", ctx.getHeight() + newBoxDelay)\n                        .item(\"pkOwner\", prover.getP2PKAddress().pubkey())\n                        .build(),\n                \"{ \" +\n                \"  val deadlinePassed = sigmaProp(HEIGHT > freezeDeadline)\" +\n                \"  deadlinePassed && pkOwner \" +\n                \"}\"))\n        .build();\n```\n\nThe contract is given as the string literal which contains the block of `val` declarations followed by the logical expression. The expression defines the all possible conditions to spend the box. The contract can also contain _**named\nconstants**_ (which cannot be represented as literals in the source code). \n\nIn the example `freezeDeadline` and `pkOwner` are named constants. The concrete values of named constants should be given to the compiler (see `compileContract` method)\n\n**The following sections describe ErgoScript and its operations. **"
    },
    {
      "heading": "ErgoScript language features overview",
      "level": 4,
      "content": "- Syntax borrowed from Scala\n- Standard syntax and semantics for well known constructs (operations, code blocks, if branches etc.)\n- High-order language with first-class lambdas which are used in collection operations\n- Call-by-value (eager evaluation)\n- Statically typed with local type inference\n- Blocks are expressions \n- Semicolon inference in blocks\n- Type constructors: Pair, Coll, Option"
    },
    {
      "heading": "Operations and constructs overview",
      "level": 4,
      "content": "- Binary operations: `>, <, >=, <=, +, -, &&, ||, ==, !=, |, &, *, /, %, ^, ++`\n- Predefined primitives: `blake2b256`, `byteArrayToBigInt`, `proveDlog` etc. \n- Val declarations: `val h = blake2b256(pubkey)`\n- If-then-else clause: `if (x > 0) 1 else 0`\n- Collection literals: `Coll(1, 2, 3, 4)`\n- Generic high-order collection operations: `map`, `filter`, `fold`, `exists`, `forall`, etc.\n- Accessing fields of any predefined types: `box.value`\n- Method invocation for predefined types: `coll.map({ x => x + 1 })`\n- Function invocations (predefined and user defined): `proveDlog(pubkey)` \n- User defined function declarations: `def isProven(pk: GroupElement) = proveDlog(pk).isProven`\n- Lambdas and high-order methods: `OUTPUTS.exists { (out: Box) => out.value >= minToRaise }`"
    },
    {
      "heading": "Data types",
      "level": 4,
      "content": "In ErgoScript, everything is an object in the sense that we can call member functions and properties on any variable.\nSome of the types can have a special internal representation - for example, numbers and booleans can be\nrepresented as primitive values at runtime - but to the user they look like ordinary classes.\nNOTE: in ErgoScript we use *type*, *class* and *trait* as synonyms, we prefer *type* when talking about primitive values and\n*trait* or *class* when talking about methods.\n\nType Name        |   Description\n-----------------|------------------------------\n`Any`            | a supertype of any other type (not used directly in ErgoScript)\n`Unit`           | a type with a single value `()`\n`Boolean`        | a type with two logical values `true` and `false`\n`Byte`           | 8 bit signed integer\n`Short`          | 16 bit signed integer\n`Int`            | 32 bit signed integer\n`Long`           | 64 bit signed integer\n`BigInt`         | 256 bit signed integer\n`SigmaProp`      | a type representing a _sigma proposition_ which can be verified by executing a Sigma protocol with zero-knowledge proof of knowledge. Every contract should return a value of this type.\n`AvlTree`        | represents a digest of authenticated dynamic dictionary and can be used to verify proofs of operations performed on the dictionary\n`GroupElement`   | elliptic curve points\n`Box`            | a box containing a monetary value (in NanoErgs), tokens and registers along with a guarding proposition\n`Option[T]`      | a container which either have some value of type `T` or none.\n`Coll[T]`        | a collection of arbitrary length with all values of type `T` \n`(T1,T2)`        | a pair of values where T1, T2 can be different types\n\nThe type constructors `Coll`, `(_,_)` can be used to construct complex\ntypes as in the following example.\n\n```scala\n{\n  val keyValues = OUTPUTS(0).R4[Coll[(Int, (Byte, Long))]].get\n  ...\n}\n```"
    },
    {
      "heading": "Literal syntax and Constants",
      "level": 4,
      "content": "Literals are used to introduce values of some types directly in program text\nlike in the following example:\n\n```scala\nval unit: Unit = ()       // unit constant\nval long: Int = 10        // interger value literal\nval bool: Boolean = true  // logical literal\nval arr = Coll(1, 2, 3)   // constructs a collection with given items\nval str = \"abc\"           // string of characters \n```\nNote that many types don't have literal syntax and their values are introduced \nby applying operations, for example `deserialize` function can be used to introduce\na constant of any type by using Base64 encoded string (See [predefined function](#PredefinedFunctions))."
    },
    {
      "heading": "Data Types",
      "level": 3,
      "content": "<a name=\"DataTypes\"></a>"
    },
    {
      "heading": "Primitive Types",
      "level": 4,
      "content": "Below we specify methods of pre-defined types using Scala-like declaration of classes. \n\nNote, the `Boolean` type doesn't have pre-defined methods in addition to the standard operations.\n\n> Note, ErgoScript doesn't allow to define new `class` types, however it has many pre-defined classes with methods defined below.\n\nEvery numeric type has the following methods.\n\n```scala\n/** Base supertype for all numeric types. */\nclass Numeric {\n  /** Convert this Numeric value to Byte. \n   * @throws ArithmeticException if overflow happens. \n   */\n  def toByte: Byte\n  \n  /** Convert this Numeric value to Short. \n   * @throws ArithmeticException if overflow happens. \n   */\n  def toShort: Short\n  \n  /** Convert this Numeric value to Int. \n   * @throws ArithmeticException if overflow happens. \n   */\n  def toInt: Int\n  \n  /** Convert this Numeric value to Long. \n   * @throws ArithmeticException if overflow happens. \n   */\n  def toLong: Long\n  \n  /** Convert this Numeric value to BigInt. */\n  def toBigInt: BigInt\n}\n```\n\nAll the predefined numeric types inherit Numeric class and its methods.\n\nThey can be thought of as being pre-defined, like the following.\n\n```scala \nclass Byte extends Numeric\nclass Short extends Numeric\nclass Int extends Numeric\nclass Long extends Numeric\nclass BigInt extends Numeric\n```"
    },
    {
      "heading": "Context Data",
      "level": 4,
      "content": "Every script is executed in a context, which is a collection of data available\nfor operations in the script. The context data is available using the `CONTEXT`\nvariable which is of pre-defined class `Context` which is shown below. \n\nThere are also shortcut variables which are available in every script to\nsimplify access to the most commonly used context data.\n\nVariable          |  Type               | Shortcut for ...\n------------------|---------------------|----------------------\n`HEIGHT`          | `Int`               | `CONTEXT.HEIGHT`\n`SELF`            | `Box`               | `CONTEXT.SELF` \n`INPUTS`          | `Coll[Box]`         | `CONTEXT.INPUTS`  \n`OUTPUTS`         | `Coll[Box]`         | `CONTEXT.OUTPUTS` \n\nThe following listing shows the methods of pre-defined `Context`, `Header`,\n`PreHeader` types.\n\n```scala\n/** Represents data available in ErgoScript using `CONTEXT` global variable */\nclass Context {\n  /** Height (block number) of the block which is currently being validated. */\n  def HEIGHT: Int\n  \n  /** Box whose proposition is being currently executing */\n  def SELF: Box\n\n  /** Zero based index in `inputs` of `selfBox` */\n  def selfBoxIndex: Int\n  \n  /** A collection of inputs of the current transaction, the transaction where\n    * selfBox is one of the inputs. \n    */\n  def INPUTS: Coll[Box]\n  \n  /** A collection of data inputs of the current transaction. Data inputs are\n    * not going to be spent and thus don't participate in transaction validation\n    * as `INPUTS`, but data boxes are available in guarding propositions of\n    * `INPUTS` and thus can be used in spending logic.\n    */\n  def dataInputs: Coll[Box]\n  \n  /** A collection of outputs of the current transaction. */\n  def OUTPUTS: Coll[Box]\n  \n  /** Authenticated dynamic dictionary digest representing Utxo state before\n    * current state. \n    */\n  def LastBlockUtxoRootHash: AvlTree\n  \n  /** A fixed number of last block headers in descending order (first header is\n    * the newest one) */\n  def headers: Coll[Header]\n\n/** Fields of a new block header, that can be predicted by a miner before block's formation */\n  def preHeader: PreHeader\n  /** Bytes of encoded miner's public key.\n    * Same as `preHeader.minerPk.getEncoded`\n    */\n  def minerPubKey: Coll[Byte] \n}\n\n/** Represents data of the block headers available in scripts. */\nclass Header {  \n  /** Bytes representation of ModifierId of this Header */\n  def id: Coll[Byte]\n\n  /** Block version, to be increased on every soft and hardfork. */\n  def version: Byte\n  \n  /** Id of parent block (as bytes) */\n  def parentId: Coll[Byte] // \n  \n  /** Hash of ADProofs for transactions in a block */\n  def ADProofsRoot: Coll[Byte] // Digest32. Can we build AvlTree out of it? \n\n  /** AvlTree) of a state after block application */\n  def stateRoot: Coll[Byte]  // ADDigest  //33 bytes! extra byte with tree height here!\n\n  /** Root hash (for a Merkle tree) of transactions in a block. */\n  def transactionsRoot: Coll[Byte]  // Digest32\n\n  /** Block timestamp (in milliseconds since beginning of Unix Epoch) */\n  def timestamp: Long\n\n  /** Current difficulty in a compressed view.\n    * NOTE: actually it is unsigned Int*/\n  def nBits: Long  // actually it is unsigned Int \n\n  /** Block height */\n  def height: Int\n\n  /** Root hash of extension section (Digest32) */\n  def extensionRoot: Coll[Byte]\n\n  /** Miner's public key. Should be used to collect block rewards.\n    * Part of Autolykos solution (pk). \n    */\n  def minerPk: GroupElement\n\n  /** One-time public key. Prevents revealing of miners secret. \n    * Part of Autolykos solution (w). \n    */\n  def powOnetimePk: GroupElement\n\n  /** Nonce value found by the miner. Part of Autolykos solution (n). */\n  def powNonce: Coll[Byte]\n\n  /** Distance between pseudo-random number, corresponding to nonce `powNonce`\n    * and a secret, corresponding to `minerPk`. The lower `powDistance` is, the\n    * harder it was to find this solution. \n    * Part of Autolykos solution (d).\n    */\n  def powDistance: BigInt\n\n  /** Miner votes for changing system parameters. */\n  def votes: Coll[Byte]\n}\n\n/** Only header fields that can be predicted by a miner. */\nclass PreHeader { \n  /** Block version, to be increased on every soft and hardfork. */\n  def version: Byte\n\n  /** Id of parent block */\n  def parentId: Coll[Byte] // ModifierId\n\n  /** Block timestamp (in milliseconds since beginning of Unix Epoch) */\n  def timestamp: Long\n\n  /** Current difficulty in a compressed view.\n    * NOTE: actually it is 32-bit unsigned Int */\n  def nBits: Long\n\n  /** Block height */\n  def height: Int\n\n  /** Miner public key. Should be used to collect block rewards. */\n  def minerPk: GroupElement\n\n  /** Miner votes for changing system parameters. */\n  def votes: Coll[Byte]\n}\n\n```"
    },
    {
      "heading": "Box type",
      "level": 4,
      "content": "Box represents a unit of storage in Ergo blockchain. It contains 10 registers\n(indexed 0-9). First 4 are mandatory and the others are optional.\n\n```scala\n/** Representation of Ergo boxes used during execution of ErgoTree operations. */\nclass Box {\n  /** Box monetary value in NanoErg */\n  def value: Long \n  \n  /** Blake2b256 hash of this box's content, basically equals to\n    * `blake2b256(bytes)` \n    */\n  def id: Coll[Byte] \n\n  /** Serialized bytes of guarding script, which should be evaluated to true in\n    * order to open this box. \n    */\n  def propositionBytes: Coll[Byte] \n  \n  /** Serialized bytes of this box's content, including proposition bytes. */\n  def bytes: Coll[Byte] \n  \n  /** Serialized bytes of this box's content, excluding transactionId and index\n    * of output. \n    */\n  def bytesWithoutRef: Coll[Byte]\n    \n  /** If `tx` is a transaction which generated this box, then `creationInfo._1`\n    * is a height of the tx's block. The `creationInfo._2` is a serialized\n    * transaction identifier followed by box index in the transaction outputs.\n    */\n  def creationInfo: (Int, Coll[Byte]) \n  \n  /** Synonym of R2 obligatory register */\n  def tokens: Coll[(Coll[Byte], Long)] \n  \n  /** Extracts register by id and type.\n    * ErgoScript is typed, so accessing a register is an operation which involves some\n    * expected type given in brackets. Thus `SELF.R4[Int]` expression should evaluate to a\n    * valid value of the `Option[Int]` type.\n    *\n    * For example `val x = SELF.R4[Int]` expects the\n    * register, if it is present, to have type `Int`. At runtime the corresponding type\n    * descriptor is passed as `implicit t: RType[T]` parameter of `getReg` method and\n    * checked against the actual value of the register.\n    *\n    * There are three cases:\n    * 1) If the register doesn't exist.\n    *   Then `val x = SELF.R4[Int]` succeeds and returns the None value, which conforms to\n    *   any value of type `Option[T]` for any T. (In the example above T is equal to\n    *   `Int`). Calling `x.get` fails when x is equal to None, but `x.isDefined`\n    *   succeeds and returns `false`.\n    * 2) If the register contains a value `v` of type `Int`.\n    *   Then `val x = SELF.R4[Int]` succeeds and returns `Some(v)`, which is a valid value\n    *   of type `Option[Int]`. In this case, calling `x.get` succeeds and returns the\n    *   value `v` of type `Int`. Calling `x.isDefined` returns `true`.\n    * 3) If the register contains a value `v` of type T other then `Int`.\n    *   Then `val x = SELF.R4[Int]` fails, because there is no way to return a valid value\n    *   of type `Option[Int]`. The value of register is present, so returning it as None\n    *   would break the typed semantics of registers collection.\n    *\n    * In some use cases one register may have values of different types. To access such\n    * register an additional register can be used as a tag.\n    *\n    * <pre class=\"stHighlight\">\n    *   val tagOpt = SELF.R5[Int]\n    *   val res = if (tagOpt.isDefined) {\n    *     val tag = tagOpt.get\n    *     if (tag == 1) {\n    *       val x = SELF.R4[Int].get\n    *       // compute res using value x is of type Int\n    *     } else if (tag == 2) {\n    *       val x = SELF.R4[GroupElement].get\n    *       // compute res using value x is of type GroupElement\n    *     } else if (tag == 3) {\n    *       val x = SELF.R4[ Array[Byte] ].get\n    *       // compute res using value x of type Array[Byte]\n    *     } else {\n    *       // compute `res` when `tag` is not 1, 2 or 3\n    *     }\n    *   }\n    *   else {\n    *     // compute value of res when register is not present\n    *   }\n    * </pre>\n    *\n    * @param i zero-based identifier of the register.\n    * @tparam T expected type of the register.\n    * @return Some(value) if the register is defined AND has the given type.\n    *         None otherwise\n    * @throws special.sigma.InvalidType exception when the type of the register value is\n    *                                   different from T.\n    */\n  def Ri[T]: Option[T]\n\n  /** Executes the script stored in the register `regId` of the `SELF` box.\n    * Similar to `executeFromVar`, this performs a macro-like substitution and\n    * execution of the script (stored as `Coll[Byte]` representing serialized ErgoTree)\n    * found in the specified register.\n    *\n    * **Important Behavior Notes (based on interpreter implementation):**\n    * - **Missing Register:** If register `regId` does not exist in `SELF`, this\n    *   operation fails. Unlike `getVar` or `Ri`, it does **not** return an `Option`\n    *   or handle default values automatically in this case. The script author must\n    *   explicitly check for the register's existence first (e.g., using `SELF.Ri[Coll[Byte]](regId).isDefined`).\n    * - **Type Mismatch:** If the register exists but does not contain valid\n    *   serialized `ErgoTree` (`Coll[Byte]`), or if the executed script's result\n    *   type does not match the expected type `T`, the operation fails.\n    * - **No Automatic Option Wrapping:** The result type `T` is the direct result\n    *   of the executed script. If the executed script itself returns an `Option[X]`,\n    *   then `T` must be `Option[X]`. `executeFromSelfReg` does not automatically\n    *   wrap the result in an `Option`.\n    *\n    * This function is powerful for implementing complex state transitions and\n    * contract patterns where parts of the execution logic are stored within the box itself.\n    *\n    * @param regId zero-based identifier of the register (R4-R9) in the `SELF` box containing the script bytes.\n    * @tparam T expected type of the script's result after execution.\n    * @return The result of executing the script stored in the register.\n    * @throws InterpreterException if the register is not found, does not contain\n    *         valid serialized ErgoTree, or if the script execution fails or results\n    *         in a type different from T.\n    */\n  def executeFromSelfReg[T](regId: Int): T\n}\n```\n\nBesides properties, every box can have up to 10 numbered registers.\nThe following syntax is supported to access registers on box objects:\n\n```scala\nbox.R3[Int].get          // access R3 register, check that its value of type Int and return it\nbox.R3[Int].isDefined    // check that value of R3 is defined and has type Int\nbox.R3[Int].getOrElse(d) //access R3 register, check that its value of type Int, return it if defined, otherwise return `d`\n```"
    },
    {
      "heading": "GroupElement",
      "level": 4,
      "content": "```scala\n/** Base class for points on elliptic curves. */\nclass GroupElement {\n  /** Exponentiate this <code>GroupElement</code> to the given number.\n    * @param k The power.\n    * @return <code>this to the power of k</code>.\n    */\n  def exp(k: BigInt): GroupElement\n\n  /** Group operation. */\n  def multiply(that: GroupElement): GroupElement\n\n  /** Inverse element in the group. */\n  def negate: GroupElement\n\n  /** Get an encoding of the point value.\n    *\n    * @return the point encoding\n    */\n  def getEncoded: Coll[Byte]\n}\n```"
    },
    {
      "heading": "AvlTree",
      "level": 4,
      "content": "```scala\n/** Type of data which efficiently authenticates potentially huge dataset having key-value dictionary interface.\n  * Only root hash of dynamic AVL+ tree, tree height, key length, optional value length, and access flags are stored\n  * in an instance of the datatype.\n  *\n  * Please note that standard hash function from `scorex.crypto.hash` is used, and height is stored along with root hash of\n  * the tree, thus `digest` size is always CryptoConstants.hashLength + 1 bytes.\n  */\nclass AvlTree {\n  /** Returns digest of the state represented by this tree.\n    * Authenticated tree digest = root hash bytes ++ tree height\n    */\n  def digest: Coll[Byte]\n\n  /** Flags of enabled operations packed in single byte.\n    * isInsertAllowed == (enabledOperations & 0x01) != 0\n    * isUpdateAllowed == (enabledOperations & 0x02) != 0\n    * isRemoveAllowed == (enabledOperations & 0x04) != 0\n    */\n  def enabledOperations: Byte\n\n  /** All the elements under the tree have the same length of the keys */\n  def keyLength: Int\n  \n  /** If non-empty, all the values under the tree are of the same length. */\n  def valueLengthOpt: Option[Int]\n\n  /** Checks if Insert operation is allowed for this tree instance. */\n  def isInsertAllowed: Boolean\n\n  /** Checks if Update operation is allowed for this tree instance. */\n  def isUpdateAllowed: Boolean\n\n  /** Checks if Remove operation is allowed for this tree instance. */\n  def isRemoveAllowed: Boolean\n\n  /** Replace digest of this tree producing a new tree.\n    * Since AvlTree is immutable, this tree instance remains unchanged.\n    * @param newDigest   a new digest\n    * @return a copy of this AvlTree instance where `this.digest` replaced by\n    *         `newDigest`\n    */\n  def updateDigest(newDigest: Coll[Byte]): AvlTree\n\n  /** Enable/disable operations of this tree producing a new tree.\n    * Since AvlTree is immutable, `this` tree instance remains unchanged.\n    * @param newOperations a new flags which specify available operations on a\n    *                      new tree.\n    * @return              a copy of this AvlTree instance where\n    *                      `this.enabledOperations` replaced by `newOperations`\n    */\n  def updateOperations(newOperations: Byte): AvlTree\n\n  /** Checks if an entry with key `key` exists in this tree using proof `proof`.\n    * Throws exception if proof is incorrect.\n    *\n    * @note CAUTION! Does not support multiple keys check, use [[getMany]] instead.\n    * Return `true` if a leaf with the key `key` exists\n    * Return `false` if leaf with provided key does not exist.\n    * @param key    a key of an element of this authenticated dictionary.\n    * @param proof data to reconstruct part of the tree enough to perform the check\n    */\n  def contains(key: Coll[Byte], proof: Coll[Byte]): Boolean\n\n  /** Perform a lookup of key `key` in this tree using proof `proof`.\n    * Throws exception if proof is incorrect\n    *\n    * @note CAUTION! Does not support multiple keys check, use [[getMany]] instead.\n    * Return Some(bytes) of leaf with key `key` if it exists\n    * Return None if leaf with provided key does not exist.\n    * @param key    a key of an element of this authenticated dictionary.\n    * @param proof data to reconstruct part of the tree enough to get the value\n    *              by the key\n    */\n  def get(key: Coll[Byte], proof: Coll[Byte]): Option[Coll[Byte]]\n\n  /** Perform a lookup of many keys `keys` in this tree using proof `proof`.\n    *\n    * @note CAUTION! Keys must be ordered the same way they were in lookup\n    * before proof was generated.\n    * For each key return Some(bytes) of leaf if it exists and None if is doesn't.\n    * @param keys  keys of elements of this authenticated dictionary.\n    * @param proof data to reconstruct part of the tree enough to get the values\n    *              by the keys\n    */\n  def getMany(keys: Coll[Coll[Byte]], proof: Coll[Byte]): Coll[Option[Coll[Byte]]]\n\n  /** Perform insertions of key-value entries into this tree using proof `proof`.\n    * Throws exception if proof is incorrect\n    *\n    * @note CAUTION! Pairs must be ordered the same way they were in insert ops\n    * before proof was generated.\n    * Return Some(newTree) if successful\n    * Return None if operations were not performed.\n    * @param operations collection of key-value pairs to insert in this\n    *                   authenticated dictionary.\n    * @param proof data to reconstruct part of the tree\n    */\n  def insert(operations: Coll[(Coll[Byte], Coll[Byte])], proof: Coll[Byte]): Option[AvlTree]\n\n  /** Perform updates of key-value entries into this tree using proof `proof`.\n    * Throws exception if proof is incorrect\n    *\n    * @note CAUTION! Pairs must be ordered the same way they were in update ops\n    * before proof was generated.\n    * Return Some(newTree) if successful\n    * Return None if operations were not performed.\n    * @param operations collection of key-value pairs to update in this\n    *                   authenticated dictionary.\n    * @param proof      data to reconstruct part of the tree\n    */\n  def update(operations: Coll[(Coll[Byte], Coll[Byte])], proof: Coll[Byte]): Option[AvlTree]\n\n  /** Perform removal of entries into this tree using proof `proof`.\n    * Throws exception if proof is incorrect\n    * Return Some(newTree) if successful\n    * Return None if operations were not performed.\n    *\n    * @note CAUTION! Keys must be ordered the same way they were in remove ops\n    * before proof was generated.\n    * @param operations collection of keys to remove from this authenticated\n    *                   dictionary.\n    * @param proof      data to reconstruct part of the tree\n    */\n  def remove(operations: Coll[Coll[Byte]], proof: Coll[Byte]): Option[AvlTree]\n}\n```"
    },
    {
      "heading": "Option[T]",
      "level": 4,
      "content": "```scala\n/** Represents optional values. Instances of `Option`\n *  are either an instance of `Some(x)` or the value `None`.\n */\nclass Option[A] {\n  /** Returns true if the option is an instance of Some(value), false otherwise. \n   */\n  def isDefined: Boolean;\n  \n  /** Returns the option's value if the option is nonempty, otherwise\n    * return the result of evaluating `default`.\n    * NOTE: the `default` is evaluated even if the option contains the value\n    * i.e. not lazily.\n    *\n    * @param default  the default expression.\n    */\n  def getOrElse[B](default: B): B  \n\n  /** Returns the option's value.\n   *  @note The option must be nonempty.\n   *  @throws InterpreterException if the option is empty.\n   */\n  def get: A\n\n  /** Returns a Some containing the result of applying $f to this option's\n   * value if this option is nonempty.\n   * Otherwise return None.\n   *\n   * @note This is similar to `flatMap` except here, $f does not need to wrap its result in an $option.\n   *\n   * @param  f   the function to apply\n   * @since  2.0\n   * @see flatMap\n   */\n  def map[B](f: A => B): Option[B]\n\n  \n  /** Returns this option if it is nonempty '''and''' applying the predicate $p to\n   * this option's value returns true. Otherwise, return $none.\n   *\n   * @param  p   the predicate used for testing.\n   * @since  2.0\n   */\n  def filter(p: A => Boolean): Option[A]\n}\n```"
    },
    {
      "heading": "Coll[T]",
      "level": 4,
      "content": "```scala\n/** Indexed (zero-based) collection of elements of type `A` \n  * @tparam A the collection element type\n  */\nclass Coll[A] {\n  /** The number of elements in the collection */\n  def size: Int\n  \n  /** The element at given index.\n   *  Indices start at `0`; `xs.apply(0)` is the first element of collection `xs`.\n   *  Note the indexing syntax `xs(i)` is a shorthand for `xs.apply(i)`.\n   *\n   *  @param    i   the index\n   *  @return       the element at the given index\n   *  @throws       ArrayIndexOutOfBoundsException if `i < 0` or `length <= i`\n   */\n  def apply(i: Int): A\n  \n  /** The element of the collection or default value. \n   * If an index is out of bounds (`i < 0 || i >= length`) then `default` value is returned.\n   *  @param    i   the index\n   *  @return       the element at the given index or default value if index is out or bounds\n   */\n  def getOrElse(i: Int, default: A): A\n  \n  /** Builds a new collection by applying a function to all elements of this collection.\n   *\n   *  @param f      the function to apply to each element.\n   *  @tparam B     the element type of the returned collection.\n   *  @return       a new collection of type `Coll[B]` resulting from applying the given function\n   *                `f` to each element of this collection and collecting the results.\n   */\n  def map[B](f: A => B): Coll[B]\n\n  /** For this collection (x0, ..., xN) and other collection (y0, ..., yM)\n   * produces a collection ((x0, y0), ..., (xK, yK)) where K = min(N, M) \n   */\n  def zip[B](ys: Coll[B]): Coll[(A, B)]\n\n  /** Tests whether a predicate holds for at least one element of this collection.\n   *  @param   p     the predicate used to test elements.\n   *  @return        `true` if the given predicate `p` is satisfied by at least one element of this collection, otherwise `false`\n   */\n  def exists(p: A => Boolean): Boolean\n  \n  /** Tests whether a predicate holds for all elements of this collection.\n   *  @param   p   the predicate used to test elements.\n   *  @return      `true` if this collection is empty or the given predicate `p`\n   *               holds for all elements of this collection, otherwise `false`.\n   */\n  def forall(p: A => Boolean): Boolean\n  \n  /** Selects all elements of this collection which satisfy a predicate.\n   *  @param p     the predicate used to test elements.\n   *  @return      a new collection consisting of all elements of this collection that satisfy the given\n   *               predicate `p`. The order of the elements is preserved.\n   */\n  def filter(p: A => Boolean): Coll[A]\n  \n  /** Applies a binary operator to a start value and all elements of this collection,\n   *  going left to right.\n   *\n   *  @param   z    the start value.\n   *  @param   op   the binary operator.\n   *  @tparam  B    the result type of the binary operator.\n   *  @return  the result of inserting `op` between consecutive elements of this collection,\n   *           going left to right with the start value `z` on the left:\n   *           {{{\n   *             op(...op(z, x_1), x_2, ..., x_n)\n   *           }}}\n   *           where `x,,1,,, ..., x,,n,,` are the elements of this collection.\n   *           Returns `z` if this collection is empty.\n   */\n  def fold[B](z: B, op: (B, A) => B): B\n\n  /** Produces the range of all indices of this collection [0 .. size-1] */\n  def indices: Coll[Int]\n\n  /**\n    * Builds a new collection by applying a function to all elements of this collection\n    * and using the elements of the resulting collections.\n    *\n    * Function `f` is constrained to be of the form `x => x.someProperty`, otherwise\n    * it is illegal.\n    * \n    * @param f the function to apply to each element.\n    * @tparam B the element type of the returned collection.\n    * @return a new collection of type `Coll[B]` resulting from applying the given collection-valued function\n    *         `f` to each element of this collection and concatenating the results.\n    */\n  def flatMap[B](f: A => Coll[B]): Coll[B]\n\n  /** Produces a new collection where a slice of elements in this collection is replaced by another sequence.\n    *\n    *  @param  from     the index of the first replaced element\n    *  @param  patch    the replacement sequence\n    *  @param  replaced the number of elements to drop in the original collection\n    *  @return          a new collection consisting of all elements of this collection\n    *                   except that `replaced` elements starting from `from` are replaced by `patch`.\n    */\n  def patch(from: Int, patch: Coll[A], replaced: Int): Coll[A]\n\n  /** A copy of this collection with one single replaced element.\n    *  @param  index  the position of the replacement\n    *  @param  elem   the replacing element\n    *  @return a new collection which is a copy of this collection with the element at position `index` replaced by `elem`.\n    *  @throws IndexOutOfBoundsException if `index` does not satisfy `0 <= index < length`.\n    */\n  def updated(index: Int, elem: A): Coll[A]\n\n  /** Returns a copy of this collection where elements at `indexes` are replaced\n    * with `values`. \n    */\n  def updateMany(indexes: Coll[Int], values: Coll[A]): Coll[A]\n\n  /** Selects an interval of elements.  The returned collection is made up\n   *  of all elements `x` which satisfy the invariant:\n   *  {{{\n   *    from <= indexOf(x) < until\n   *  }}}\n   *  @param from   the lowest index to include from this collection.\n   *  @param until  the lowest index to EXCLUDE from this collection.\n   */\n  def slice(from: Int, until: Int): Coll[A]\n  \n  /** Puts the elements of other collection after the elements of this\n    * collection (concatenation of 2 collections).\n    */\n  def append(other: Coll[A]): Coll[A]\n  \n  /** Finds index of first occurrence of some value in this collection after or\n    * at some start index.\n    *  @param   elem   the element value to search for.\n    *  @param   from   the start index\n    *  @return  the index `>= from` of the first element of this collection that is equal (as determined by `==`)\n    *           to `elem`, or `-1`, if none exists.\n    */\n  def indexOf(elem: A, from: Int): Int\n}\n```\n\nEach item can be accessed by constant index, for example:\n```scala\nval myOutput = OUTPUTS(0)\nval myInput = INPUTS(0)\n```\n\nAny collection have the `size` property which returns the number of elements in\nthe collection.\n\n```scala\nval size = OUTPUTS.size\n```\n\nThe following script check the existence of some element in the collection\nsatisfying some predicate (condition)\n\n```scala\nval ok = OUTPUTS.exists { (box: Box) => box.value > 1000 }\n```"
    },
    {
      "heading": "Predefined global functions",
      "level": 3,
      "content": "<a name=\"PredefinedFunctions\"></a>\n\nErgoScript standard library include predefined functions that can be called \nwithout prior declaration. \n\nThe following function declarations are automatically imported into any script:\n\n```scala \n/** Returns true if all the elements in collection are true. */\ndef allOf(conditions: Coll[Boolean]): Boolean\n\n/** Returns true if at least on element of the conditions is true */\ndef anyOf(conditions: Coll[Boolean]): Boolean\n\n/** Similar to allOf, but performing logical XOR operation instead of `&&` */\ndef xorOf(conditions: Coll[Boolean]): Boolean \n\n/** Returns SigmaProp value which can be ZK proven to be true \n * if at least k properties can be proven to be true. \n */\ndef atLeast(k: Int, properties: Coll[SigmaProp]): SigmaProp\n    \n/** Embedding of Boolean values to SigmaProp values. As an example, this\n * operation allows boolean expressions to be used as arguments of\n * `atLeast(..., sigmaProp(myCondition), ...)` operation.\n */\ndef sigmaProp(condition: Boolean): SigmaProp\n        \n/** Cryptographic hash function Blake2b256 (See scorex.crypto.hash.Blake2b256) */\ndef blake2b256(input: Coll[Byte]): Coll[Byte]\n\n/** Cryptographic hash function Sha256 (See scorex.crypto.hash.Sha256) */\ndef sha256(input: Coll[Byte]): Coll[Byte]\n\n/** Create BigInt from a collection of bytes. */\ndef byteArrayToBigInt(input: Coll[Byte]): BigInt\n\n/** Create Long from a collection of bytes. */\ndef byteArrayToLong(input: Coll[Byte]): Long  \n\n/** Returns bytes representation of Long value. */\ndef longToByteArray(input: Long): Coll[Byte]\n\n/** Convert bytes representation of group element (ECPoint) \n  * to a new value of GroupElement (using\n  * org.bouncycastle.math.ec.ECCurve.decodePoint())\n  */\ndef decodePoint(bytes: Coll[Byte]): GroupElement \n\n\n/** Extracts Context variable by id and type.\n  * ErgoScript is typed, so accessing a the variables is an operation which involves\n  * some expected type given in brackets. Thus `getVar[Int](id)` expression should\n  * evaluate to a valid value of the `Option[Int]` type.\n  *\n  * For example `val x = getVar[Int](10)` expects the variable, if it is present, to have\n  * type `Int`. \n  *\n  * There are three cases:\n  * 1) If the variable doesn't exist.\n  *   Then `val x = getVar[Int](id)` succeeds and returns the None value, which conforms to\n  *   any value of type `Option[T]` for any T. (In the example above T is equal to\n  *   `Int`). Calling `x.get` fails when x is equal to None, but `x.isDefined`\n  *   succeeds and returns `false`.\n  * 2) If the variable contains a value `v` of type `Int`.\n  *   Then `val x = getVar[Int](id)` succeeds and returns `Some(v)`, which is a valid value\n  *   of type `Option[Int]`. In this case, calling `x.get` succeeds and returns the\n  *   value `v` of type `Int`. Calling `x.isDefined` returns `true`.\n  * 3) If the variable contains a value `v` of type T other then `Int`.\n  *   Then `val x = getVar[Int](id)` fails, because there is no way to return a valid value\n  *   of type `Option[Int]`. The value of variable is present, so returning it as None\n  *   would break the typed semantics of variables collection.\n  *\n  * In some use cases one variable may have values of different types. To access such\n  * variable an additional variable can be used as a tag.\n  *\n  * <pre class=\"stHighlight\">\n  *   val tagOpt = getVar[Int](id)\n  *   val res = if (tagOpt.isDefined) {\n  *     val tag = tagOpt.get\n  *     if (tag == 1) {\n  *       val x = getVar[Int](id2).get\n  *       // compute res when value x is of type Int\n  *     } else if (tag == 2) {\n  *       val x = getVar[GroupElement](id2).get\n  *       // compute res when value x is of type GroupElement\n  *     } else if (tag == 3) {\n  *       val x = getVar[ Array[Byte] ](id2).get\n  *       // compute res when value x of type Array[Byte]\n  *     } else {\n  *       // compute `res` when `tag` is not 1, 2 or 3\n  *     }\n  *   }\n  *   else {\n  *     // compute value of res when the variable is not present\n  *   }\n  * </pre>\n  *\n  * @param id zero-based identifier of the variable.\n  * @tparam T expected type of the variable.\n  * @return Some(value) if the variable is defined in the context AND has the given type.\n  *         None otherwise\n  * @throws special.sigma.InvalidType exception when the type of the variable value is\n  *                                   different from cT.\n  */\ndef getVar[T](tag: Int): Option[T]\n\n/** Executes the script stored in the Context variable with the given tag.\n  * This is distinct from `getVar`, which simply retrieves the evaluated value stored\n  * in the variable. `executeFromVar` performs a macro-like substitution: it takes\n  * the script (typically stored as `Coll[Byte]` representing serialized ErgoTree)\n  * from the variable and executes it in the current context.\n  *\n  * This is particularly useful for advanced contract patterns like MAST (Merkleized\n  * Abstract Syntax Trees) where script fragments are stored and executed dynamically.\n  *\n  * @param tag zero-based identifier of the context variable containing the script bytes.\n  * @tparam T expected type of the script's result after execution.\n  * @return The result of executing the script stored in the variable.\n  * @throws InterpreterException if the variable is not found, does not contain\n  *         valid serialized ErgoTree, or if the script execution fails or results\n  *         in a type different from T.\n  */\ndef executeFromVar[T](tag: Int): T\n\n/** Construct a new SigmaProp value representing public key of Diffie Hellman\n  * signature protocol. When executed as part of Sigma protocol allow to provide\n  * for a verifier a zero-knowledge proof of secret knowledge.\n  */\ndef proveDHTuple(g: GroupElement, h: GroupElement, \n                 u: GroupElement, v: GroupElement): SigmaProp\n                 \n/** Construct a new SigmaProp value representing public key of discrete\n  * logarithm signature protocol. When executed as part of Sigma protocol allow\n  * to provide for a verifier a zero-knowledge proof of secret knowledge.\n  */\ndef proveDlog(value: GroupElement): SigmaProp\n\n/** Transforms Base16 encoded string literal into constant of type BigInt.\n  * It is a compile-time operation and only string literal (constant) can be its\n  * argument.\n  */\ndef fromBase16(input: String): Coll[Byte]\n\n/** Transforms Base58 encoded string literal into constant of type Coll[Byte].\n  * It is a compile-time operation and only string literal (constant) can be its\n  * argument.\n  */\ndef fromBase58(input: String): Coll[Byte]\n\n/** Transforms Base64 encoded string literal into constant of type Coll[Byte].\n  * It is a compile-time operation and only string literal (constant) can be its\n  * argument.\n  */\ndef fromBase64(input: String): Coll[Byte]\n\n/** It is executed in compile time. The compiler takes Base58 encoding of public\n  * key as String literal and create GroupElement constant. Then the compiler\n  * used this constant to construct proveDlog public key out of it.\n  */\ndef PK(input: String): SigmaProp\n    \n/** Deserializes values from Base58 encoded binary data at compile time into a\n  * value of type T.\n  */\ndef deserialize[T](string: String): T\n\n/**\n  * Transforms serialized bytes of ErgoTree with segregated constants by\n  * replacing constants at given positions with new values. This operation allow\n  * to use serialized scripts as pre-defined templates.\n\n  * The typical usage is \"check that output box have proposition equal to given\n  * script bytes, where minerPk (constants(0)) is replaced with currentMinerPk\".\n  * Each constant in original scriptBytes have SType serialized before actual\n  * data (see ConstantSerializer). During substitution each value from newValues\n  * is checked to be an instance of the corresponding type. This means, the\n  * constants during substitution cannot change their types.\n  *\n  * @param scriptBytes serialized ErgoTree with ConstantSegregationFlag set to 1.\n  * @param positions zero based indexes in ErgoTree.constants array which should\n  *                  be replaced with new values\n  * @param newValues new values to be injected into the corresponding positions\n  *                  in ErgoTree.constants array\n  * @return original scriptBytes array where only specified constants are\n  *         replaced and all other bytes remain exactly the same\n  */\ndef substConstants[T](scriptBytes: Coll[Byte], positions: Coll[Int], newValues: Coll[T]): Coll[Byte]\n```"
    },
    {
      "heading": "Examples",
      "level": 2,
      "content": "See [white paper for examples](https://ergoplatform.org/docs/ErgoScript.pdf)"
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/scs/sigma/lang-spec.md",
  "processed_at": "2025-05-11T19:31:15.705206",
  "ai_processed": true
}