{
  "id": "docs_dev_wallet_payments_standards_eip17_md",
  "title": "Proxy contracts",
  "summary": "Proxy contracts are a proposed solution to outsource transaction generation to an external service or dApp, addressing issues such as wallet limitations and scaling dApp infrastructure. The document outlines the motivation, background, and structure of proxy contracts, highlighting how they can be designed to prevent dApp developers or attackers from taking advantage of user funds and preserve the integrity of the dApp infrastructure. The proposed contract structure ensures that users receive what they are paying for and prevents attacks like stealing UI fees or preventing user requests from being executed.",
  "qa_pairs": [
    {
      "question": "What is the purpose of proxy contracts?",
      "answer": "The purpose of proxy contracts is to outsource transaction generation to an external service or dApp, such as avoiding wallet limitations or scaling dApps to fulfill many requests without double-spending or data invalidation."
    },
    {
      "question": "What are some examples of dApp infrastructure violations that proxy contracts should prevent?",
      "answer": "Proxy contracts should prevent malicious activities such as a whale trying to steal UI fees, prevent user requests from being executed, or imitate the bank box to take fees."
    },
    {
      "question": "What are the general design goals for proxy contracts?",
      "answer": "Proxy contracts should be designed to prevent dApp developers or attackers from taking advantage of user's funds, and to preserve the integrity of the whole dApp infrastructure."
    },
    {
      "question": "What is the background of proxy contracts?",
      "answer": "The idea of proxy contracts came to life with the Ergo Assembler, which helped dApp developments like Ergo Auction House, ErgoUtils, and SigmaUSD web interface, despite the lack of a wallet-bridge like MetaMask in the Ergo ecosystem."
    },
    {
      "question": "How did the structure of proxy contracts evolve over time?",
      "answer": "The initial structure of proxy contracts focused on protecting users from losing their funds, but proved insufficient for preserving the integrity of the whole dApp infrastructure, leading to the need for a more comprehensive design."
    }
  ],
  "sections": [
    {
      "heading": "Introduction",
      "level": 0,
      "content": "---\ntags:\n  - EIP\n---"
    },
    {
      "heading": "Proxy contracts",
      "level": 1,
      "content": "> \ud83d\udd17 From [EIP-0017](https://raw.githubusercontent.com/ergoplatform/eips/master/eip-0017.md)\n\n* Author: anon_real\n* Status: Proposed\n* Created: 05-May-2021\n* License: CC0\n* Forking: not needed"
    },
    {
      "heading": "Motivation",
      "level": 2,
      "content": "Outsourcing transaction generation to an external service/dApp can be useful or even needed in various circumstances. For example, avoiding wallet limitations to generate any transaction on behalf of the user - [Ergo Assembler](https://github.com/anon-real/ergo-assembler) is designed for this purpose. Another example is to scale dApps to be able to fulfill many requests without double-spending or data invalidation - SigmaUSD dApp can use proxy contracts to avoid bank double-spending and ERG/USD oracle data invalidation."
    },
    {
      "heading": "Background",
      "level": 2,
      "content": "The idea of proxy contracts came to life with the [Ergo Assembler](https://github.com/anon-real/ergo-assembler) which helped dApp developments like [Ergo Auction House](https://ergoauctions.org/), [ErgoUtils](https://ergoutils.org/), and [SigmaUSD web interface](https://sigmausd.io/#/) despite not having a wallet-bridge like MetaMask (Ethereum wallet) in the ecosystem.\n\nDuring this time, the structure of proxy contracts evolved as some malicious users tried to take advantage of some minor vulnerabilities, mostly in the [SigmaUSD dApp](https://sigmausd.io/#/)."
    },
    {
      "heading": "The structure",
      "level": 2,
      "content": "In the beginning, the sole purpose of proxy contracts was to protect users from losing their funds (not to be cheated) when they outsource their assets to engage with some dApp. While the initial structure succeeded to achieve this, it proved to be not sufficient for the whole dApp infrastructure to work without malicious activities. Some examples of dApp infrastructure violations are as follows:\n\n- A malicious whale tried to take advantage of this simple structure by stealing UI fees from SigmaUSD web interface developers for some period of time. This happened because the proxy contracts were simply only trying to protect users from malicious activities, not the dApp infrastructure.\n\n- The same whale tried to prevent user's requests (minting/redeeming) from being executed by the assembler service by retuning their funds as soon as funds were broadcasted in the network. This happened also because of the same reasons.\n\n- Moreover, the whale tried to sell SigUSD/SigRSV tokens to users by imitating the bank box. He succeeded to do that and take 2.25% fee for each request which was supposed to go to the SigRSV holders (2%) and UI devs (0.25%).\n\nThe above attacks were possible because proxy contracts were not designed to preserve the integrity of the whole dApp infrastructure but only the user's funds.\n\nGenerally, proxy contracts should be designed to:  \n\n- prevent dApp developers or any other attacker from taking advantage of user's funds in any manner\n- preserve the integrity of the dApp by preventing attacks like the ones explained in the above examples.\n\nTo achieve all of the above, the below contract structure is proposed as an example:\n\n```scala\n{\n  // dApp-specific part ensuring that user will receive what he is paying for\n  val properFundUsage = {\n    val userOut = OUTPUTS(1)\n    userOut.propositionBytes == fromBase64(\"$userAddress\") && // user must be the recipient\n      userOut.tokens(0)._1 == fromBase64(\"$scTokenId\") && // user must receive SigmaUSD\n      userOut.tokens(0)._2 >= $scAmountL && // the amount of SigmaUSD must be at least what user is paying for\n      HEIGHT < $timestampL // this part is always true (timestamp is the unix-timestamp at the time of the request), it will cause compiled address to differ everytime\n  }\n  \n  // ensuring dApp integrity is preserved - any dApp specific condition to ensure designed procedures won't be violated\n  val UIFeeOk = OUTPUTS(2).propositionBytes == fromBase64(\"$implementor\") && OUTPUTS.size == 4 // UI fee must go to UI devs not any random person who assembles the transaction\n  val properBank = OUTPUTS(0).tokens(2)._1 == fromBase64(\"$bankNFT\") // the real bank box of the sigmaUSD protocol must be used so not any random person can behave as the bank box\n  val dAppWorksFine = properFundUsage && UIFeeOk && properBank\n\n  // in any case, whether assembler refuses to execute the request or the request fails for any reason, user must be able to get back his funds\n  val returnFunds = { \n    val total = INPUTS.fold(0L, {(x:Long, b:Box) => x + b.value}) - $returnFee // only refund transactions's fee must be deducted from user's funds\n    OUTPUTS(0).value >= total && OUTPUTS(0).propositionBytes == fromBase64(\"$userAddress\") // user must receive the appropriate amount\n    && (PK(\"$assemblerNodeAddr\") || HEIGHT > $refundHeightThreshold) && // either dApp-specific node can return user's funds or some time (block) has to be passed first. This is useful for many reasons.\n    OUTPUTS.size == 2 // only refund box and transaction fee box is needed\n  }\n\n  sigmaProp(dAppWorksFine || returnFunds) // either dApp must work as it is supposed to or user's funds must be returned\n}\n```\nThe above contract is the proxy contract of minting operation in the [SigmaUSD dApp](https://sigmausd.io/#/). Anything started with `$` in the contract must be provided to it based on the user's request at the time of compilation.\n\nThe contract has three main parts:  \n\n- Ensuring proper usage of user's funds, i.e., user will receive what he is paying for in proper amount without anyone being able to cheat.\n- Ensuring the integrity of the dApp procedures.\n- Ensuring that user will be refunded in any case of failures.\n\n\nNow we will go through some parts of the above contract which are both important and ambiguous at the first glance.\n\n- `(PK(\"$assemblerNodeAddr\") || HEIGHT > $refundHeightThreshold)`: Either dApps's specific node can refund the user (at any time) or some time has to be passed for refunding without any secrets involved. This part prevents malicious users from sending refunds to users, preventing user's request (minting, in this case) from being executed. The same logic can be used to only allow a certain (or multiple) entities to execute requests. This enables dApps to control the order of execution which makes scaling dApps possible as it allows them to control double-spending and other similar problems.\n- `HEIGHT < $timestampL`: This will result in different address every time the contract is compiled. This is useful from the UI perspective to be able to track user's requests in an address-specific manner."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/wallet/payments/standards/eip17.md",
  "processed_at": "2025-05-11T19:41:07.699106",
  "ai_processed": true
}