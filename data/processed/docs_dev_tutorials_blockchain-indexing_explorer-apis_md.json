{
  "id": "docs_dev_tutorials_blockchain-indexing_explorer-apis_md",
  "title": "Indexing Strategy: Using Public Explorer APIs",
  "summary": "The document provides an overview of using public explorer APIs to access indexed Ergo blockchain data for dApps and services. It covers the concept of public explorers maintaining indexed blockchain data and exposing it through APIs, the steps involved in using these APIs (identifying the explorer, making API requests, and processing the responses), common API endpoints, and code examples in JavaScript/TypeScript and Python. The document highlights the trade-offs of this approach compared to running a node or indexer, such as reduced control, performance, and flexibility.",
  "qa_pairs": [
    {
      "question": "What are the trade-offs of using public explorer APIs for indexing blockchain data?",
      "answer": "Using public explorer APIs avoids the need to run your own node or indexer, but comes with trade-offs regarding control, performance, and flexibility."
    },
    {
      "question": "What are the key steps to using public explorer APIs for indexing blockchain data?",
      "answer": "1. Identify Explorer & API Docs, 2. Make API Requests, 3. Process Response."
    },
    {
      "question": "What are some common API endpoints available from the Ergo Explorer API?",
      "answer": "Common API endpoints include those for retrieving blockchain data, such as blocks, transactions, and addresses."
    },
    {
      "question": "What are the key considerations when using public explorer APIs, such as rate limiting?",
      "answer": "Developers should review the API documentation carefully to understand available queries, request/response formats, authentication (if any), and usage limitations (especially rate limits)."
    },
    {
      "question": "What are some of the programming languages and libraries that can be used to interact with public explorer APIs?",
      "answer": "Developers can use libraries like `axios` (JS/TS), `requests` (Python), or built-in fetch functions to make API requests and process the responses."
    }
  ],
  "sections": [
    {
      "heading": "Introduction",
      "level": 0,
      "content": "---\ntags:\n  - Indexing\n  - Explorer API\n  - Public API\n  - Off-Chain\n  - REST API\n  - Examples\n  - Rate Limiting\n---"
    },
    {
      "heading": "Indexing Strategy: Using Public Explorer APIs",
      "level": 1,
      "content": "One of the simplest ways to access indexed Ergo blockchain data for your dApp or service is by utilizing the public APIs provided by blockchain explorers. This approach avoids the need to run your own node or indexer but comes with trade-offs regarding control, performance, and flexibility."
    },
    {
      "heading": "Concept",
      "level": 2,
      "content": "Public explorers like [explorer.ergoplatform.com](https://explorer.ergoplatform.com/en/), [ergexplorer.com](https://ergexplorer.com/), and [sigmaspace.io](https://sigmaspace.io/) maintain their own indexed databases of the Ergo blockchain. They expose this data through public APIs, often RESTful, allowing developers to query for information programmatically."
    },
    {
      "heading": "How It Works",
      "level": 2,
      "content": "1.  **Identify Explorer & API Docs:** Choose an explorer whose API provides the endpoints you need. Review their API documentation carefully to understand available queries, request/response formats, authentication (if any), and usage limitations (especially rate limits).\n    *   Ergo Explorer API Docs: [api.ergoplatform.com/api/v1/docs/](https://api.ergoplatform.com/api/v1/docs/)\n    *   ErgExplorer API Docs: [ergexplorer.com/api/v1/docs/](https://ergexplorer.com/api/v1/docs/)\n2.  **Make API Requests:** Your application makes standard HTTP requests (GET, POST, etc.) to the explorer's API endpoints using libraries like `axios` (JS/TS), `requests` (Python), or built-in fetch functions.\n3.  **Process Response:** Your application parses the JSON (or other format) response from the API and uses the data. Implement robust error handling for network issues, API errors (like 404 Not Found or 429 Too Many Requests), and unexpected response formats."
    },
    {
      "heading": "Common API Endpoints",
      "level": 2,
      "content": "Below are examples of common endpoints available from the main Ergo Explorer API (`api.ergoplatform.com`). Other explorers often provide similar functionality, but check their specific documentation."
    },
    {
      "heading": "Ergo Explorer API (`api.ergoplatform.com`)",
      "level": 3,
      "content": "| Endpoint                                      | Description                      | Example URL                                                                                                |\n| :-------------------------------------------- | :------------------------------- | :--------------------------------------------------------------------------------------------------------- |\n| `/api/v1/addresses/{address}`                 | Get address summary info         | `https://api.ergoplatform.com/api/v1/addresses/9iMoHi8FUVh2RdFv3YD6xjjfxZ6nPqEjQbmxQzHbpBFE6hWxouq`          |\n| `/api/v1/addresses/{address}/transactions`    | Get address transactions         | `https://api.ergoplatform.com/api/v1/addresses/9iMoHi8FUVh2RdFv3YD6xjjfxZ6nPqEjQbmxQzHbpBFE6hWxouq/transactions` |\n| `/api/v1/addresses/{address}/balance/confirmed` | Get confirmed balance            | `https://api.ergoplatform.com/api/v1/addresses/9iMoHi8FUVh2RdFv3YD6xjjfxZ6nPqEjQbmxQzHbpBFE6hWxouq/balance/confirmed` |\n| `/api/v1/boxes/unspent/byAddress/{address}`   | Get unspent boxes by address     | `https://api.ergoplatform.com/api/v1/boxes/unspent/byAddress/9iMoHi8FUVh2RdFv3YD6xjjfxZ6nPqEjQbmxQzHbpBFE6hWxouq` |\n| `/api/v1/boxes/unspent/byErgoTree/{ergoTree}` | Get unspent boxes by ErgoTree    | `https://api.ergoplatform.com/api/v1/boxes/unspent/byErgoTree/{ergoTreeHex}`                               |\n| `/api/v1/boxes/unspent/byTokenId/{tokenId}`   | Get unspent boxes containing token | `https://api.ergoplatform.com/api/v1/boxes/unspent/byTokenId/03faf2cb329f2e90d6d23b58d91bbb6c046aa143261cc21f52fbe2824bfcbf04` |\n| `/api/v1/boxes/{boxId}`                       | Get box by ID                    | `https://api.ergoplatform.com/api/v1/boxes/851dd1bdd06a0f0f8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a` |\n| `/api/v1/transactions/{txId}`                 | Get transaction by ID            | `https://api.ergoplatform.com/api/v1/transactions/851dd1bdd06a0f0f8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a` |\n| `/api/v1/tokens/{tokenId}`                    | Get token information            | `https://api.ergoplatform.com/api/v1/tokens/03faf2cb329f2e90d6d23b58d91bbb6c046aa143261cc21f52fbe2824bfcbf04` |\n| `/api/v1/blocks/{blockId}`                    | Get block by ID                  | `https://api.ergoplatform.com/api/v1/blocks/851dd1bdd06a0f0f8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a8e7a0e0a` |\n| `/api/v1/info`                                | Get blockchain info              | `https://api.ergoplatform.com/api/v1/info`                                                                 |\n\n*(Note: Replace placeholders like `{address}`, `{ergoTreeHex}`, `{tokenId}`, `{boxId}`, `{txId}`, `{blockId}` with actual values.)*"
    },
    {
      "heading": "Code Examples",
      "level": 2,
      "content": ""
    },
    {
      "heading": "JavaScript/TypeScript (with Axios)",
      "level": 3,
      "content": "```typescript\nimport axios from 'axios';\n\n// Configuration\nconst explorerBaseUrl = 'https://api.ergoplatform.com/api/v1';\n\n// Create a reusable client with error handling\nconst explorerClient = axios.create({\n  baseURL: explorerBaseUrl,\n  timeout: 10000, // 10 second timeout\n  headers: {\n    'Accept': 'application/json',\n  }\n});\n\n// Add response interceptor for detailed error logging\nexplorerClient.interceptors.response.use(\n  response => response,\n  error => {\n    if (error.response) {\n      // Request made and server responded with a status code outside 2xx range\n      console.error('Explorer API Error:', error.response.status, error.response.data);\n    } else if (error.request) {\n      // Request made but no response received\n      console.error('Explorer API No Response:', error.request);\n    } else {\n      // Error setting up the request\n      console.error('Explorer API Request Setup Error:', error.message);\n    }\n    return Promise.reject(error); // Propagate the error\n  }\n);\n\n// Get address information\nasync function getAddressInfo(address: string) {\n  try {\n    const response = await explorerClient.get(`/addresses/${address}`);\n    return response.data;\n  } catch (error) {\n    console.error(`Failed to get info for address ${address}`);\n    // Optionally return null or a default object instead of throwing\n    return null; \n  }\n}\n\n// Get address balance (confirmed)\nasync function getAddressBalance(address: string) {\n  try {\n    const response = await explorerClient.get(`/addresses/${address}/balance/confirmed`);\n    return response.data;\n  } catch (error) {\n    console.error(`Failed to get balance for address ${address}`);\n    return null;\n  }\n}\n\n// Get unspent boxes for an address (first page)\nasync function getUnspentBoxes(address: string, limit: number = 50) {\n  try {\n    // API might use 'items' array and 'total' count for pagination\n    const response = await explorerClient.get(`/boxes/unspent/byAddress/${address}`, { params: { limit } });\n    return response.data.items || []; // Return items array or empty array\n  } catch (error) {\n    console.error(`Failed to get unspent boxes for address ${address}`);\n    return [];\n  }\n}\n\n// Get token information\nasync function getTokenInfo(tokenId: string) {\n  try {\n    const response = await explorerClient.get(`/tokens/${tokenId}`);\n    return response.data;\n  } catch (error) {\n    console.error(`Failed to get info for token ${tokenId}`);\n    return null;\n  }\n}\n\n// Example usage\nasync function main() {\n  const address = '9iMoHi8FUVh2RdFv3YD6xjjfxZ6nPqEjQbmxQzHbpBFE6hWxouq'; // Example address\n  \n  const addressInfo = await getAddressInfo(address);\n  if (addressInfo) console.log('Address Info:', addressInfo);\n  \n  const balance = await getAddressBalance(address);\n  if (balance) console.log('Balance:', balance);\n  \n  const unspentBoxes = await getUnspentBoxes(address);\n  console.log(`Found ${unspentBoxes.length} unspent boxes (first page)`);\n  \n  if (unspentBoxes.length > 0 && unspentBoxes[0].assets.length > 0) {\n    const tokenId = unspentBoxes[0].assets[0].tokenId;\n    const tokenInfo = await getTokenInfo(tokenId);\n    if (tokenInfo) console.log('Token Info:', tokenInfo);\n  }\n}\n\nmain().catch(e => console.error(\"Main execution failed:\", e));\n```"
    },
    {
      "heading": "Python Example",
      "level": 3,
      "content": "```python\nimport requests\nimport time\nfrom typing import Dict, List, Any, Optional\n\nclass ErgoExplorerClient:\n    \"\"\"A simple client for interacting with the Ergo Explorer API v1.\"\"\"\n    \n    def __init__(self, base_url: str = \"https://api.ergoplatform.com/api/v1\"):\n        self.base_url = base_url\n        self.session = requests.Session()\n        self.session.headers.update({\n            \"Accept\": \"application/json\",\n            \"User-Agent\": \"ErgoDocsPythonClient/1.0\" # Good practice to identify your client\n        })\n    \n    def _request(self, method: str, endpoint: str, **kwargs) -> Optional[Dict[str, Any]]:\n        \"\"\"Internal method to handle API requests with retries and error logging.\"\"\"\n        url = f\"{self.base_url}/{endpoint.lstrip('/')}\"\n        max_retries = 3\n        retry_delay = 1  # seconds\n        \n        for attempt in range(max_retries):\n            try:\n                response = self.session.request(method, url, timeout=10, **kwargs) # 10 second timeout\n                response.raise_for_status() # Raises HTTPError for bad responses (4xx or 5xx)\n                return response.json()\n            except requests.exceptions.HTTPError as e:\n                print(f\"HTTP Error: {e.response.status_code} for URL {url}. Response: {e.response.text}\")\n                if e.response.status_code == 429: # Rate limited\n                    retry_after = int(e.response.headers.get('Retry-After', retry_delay))\n                    print(f\"Rate limited. Retrying after {retry_after} seconds...\")\n                    time.sleep(retry_after)\n                    retry_delay = retry_after + 1 # Add buffer\n                elif attempt < max_retries - 1:\n                    print(f\"Retrying in {retry_delay} seconds...\")\n                    time.sleep(retry_delay)\n                    retry_delay *= 2 # Exponential backoff\n                else:\n                    print(f\"Request failed after {max_retries} attempts.\")\n                    return None # Return None on final failure\n            except requests.exceptions.RequestException as e:\n                print(f\"Request failed: {e}. Attempt {attempt + 1}/{max_retries}\")\n                if attempt < max_retries - 1:\n                    time.sleep(retry_delay)\n                    retry_delay *= 2\n                else:\n                    print(f\"Request failed after {max_retries} attempts.\")\n                    return None # Return None on final failure\n        return None\n\n    def get_address_balance(self, address: str, confirmed: bool = True) -> Optional[Dict[str, Any]]:\n        \"\"\"Get address balance (confirmed or total).\"\"\"\n        balance_type = \"confirmed\" if confirmed else \"total\"\n        return self._request(\"GET\", f\"/addresses/{address}/balance/{balance_type}\")\n    \n    def get_unspent_boxes(self, address: str, offset: int = 0, limit: int = 50) -> Optional[List[Dict[str, Any]]]:\n        \"\"\"Get unspent boxes for an address (paginated).\"\"\"\n        params = {\"offset\": offset, \"limit\": limit}\n        response = self._request(\"GET\", f\"/boxes/unspent/byAddress/{address}\", params=params)\n        return response.get(\"items\") if response else None\n\n    def get_token_info(self, token_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get token information.\"\"\"\n        return self._request(\"GET\", f\"/tokens/{token_id}\")\n        \n    def get_blockchain_info(self) -> Optional[Dict[str, Any]]:\n        \"\"\"Get general blockchain information.\"\"\"\n        return self._request(\"GET\", \"/info\")"
    },
    {
      "heading": "Example usage",
      "level": 1,
      "content": "if __name__ == \"__main__\":\n    client = ErgoExplorerClient()\n    address = \"9iMoHi8FUVh2RdFv3YD6xjjfxZ6nPqEjQbmxQzHbpBFE6hWxouq\" # Example address\n\n    info = client.get_blockchain_info()\n    if info:\n        print(f\"Current Height: {info.get('height', 'N/A')}\")\n\n    balance_info = client.get_address_balance(address)\n    if balance_info:\n        erg_balance = balance_info.get('nanoErgs', 0) / 1e9\n        print(f\"Address Balance: {erg_balance:.9f} ERG\")\n        if balance_info.get('tokens'):\n            print(\"Tokens:\")\n            for token in balance_info['tokens']:\n                 print(f\"  ID: {token['tokenId'][:10]}..., Amount: {token['amount']}\")\n\n    boxes = client.get_unspent_boxes(address)\n    if boxes is not None: # Check for None in case of API failure\n        print(f\"Found {len(boxes)} unspent boxes (first page).\")\n        if boxes and boxes[0].get('assets'):\n            token_id = boxes[0]['assets'][0]['tokenId']\n            token_info = client.get_token_info(token_id)\n            if token_info:\n                print(f\"First token info ({token_id[:10]}...): Name: {token_info.get('name', 'N/A')}, Decimals: {token_info.get('decimals', 'N/A')}\")\n```"
    },
    {
      "heading": "Rate Limiting and Best Practices",
      "level": 2,
      "content": "Public APIs are shared resources. To ensure reliable operation and avoid being blocked, follow these best practices:\n\n*   **Understand Rate Limits:** Check the API documentation or community resources for stated rate limits (e.g., requests per second per IP). The main Ergo Explorer API often has limits around 10-20 req/sec. Exceeding limits can lead to `429 Too Many Requests` errors or temporary IP bans.\n*   **Implement Caching:** Avoid fetching the same data repeatedly. Cache responses locally (in memory for short durations, or using persistent stores like Redis for longer) with appropriate Time-To-Live (TTL) values. Re-fetch only when the cache expires or specific events indicate data might have changed.\n    ```javascript\n    // Simple in-memory cache concept (JS)\n    const cache = new Map();\n    const CACHE_TTL = 60000; // 1 minute\n\n    async function getCachedData(url) {\n      const now = Date.now();\n      if (cache.has(url) && (now - cache.get(url).timestamp < CACHE_TTL)) {\n        return cache.get(url).data;\n      }\n      // Fetch fresh data if not cached or expired\n      const response = await fetch(url); // Use fetchWithRetry here\n      if (!response.ok) throw new Error(`API Error: ${response.status}`);\n      const data = await response.json();\n      cache.set(url, { data, timestamp: now });\n      return data;\n    }\n    ```\n*   **Use Retry Logic with Exponential Backoff:** If a request fails (especially due to rate limiting or transient network issues), don't immediately retry. Wait for a short period and increase the delay exponentially for subsequent retries. Respect the `Retry-After` header if provided in a `429` response.\n    ```python\n    # Conceptual retry logic within the Python client's _request method (see above)\n    # Handles retries with increasing delay for transient errors and respects Retry-After\n    ```\n*   **Be Specific:** Request only the data you need. Use API parameters (`limit`, `offset`, specific endpoints) to narrow down results instead of fetching large datasets and filtering client-side.\n*   **Identify Your Client:** Use a descriptive `User-Agent` header in your requests so API providers can identify your application's traffic if issues arise.\n*   **Consider Alternatives:** If your application requires high volume, low latency, or complex queries, relying solely on public APIs might not be sustainable. Explore [querying your own node](./node-api-direct.md) or building a [custom indexer](./custom-indexer.md)."
    },
    {
      "heading": "Pros & Cons Summary",
      "level": 2,
      "content": "*   **Pros:** Simple to start, convenient endpoints.\n*   **Cons:** Third-party reliance, rate limits, limited query flexibility, potential latency, centralization risk."
    },
    {
      "heading": "When to Use",
      "level": 2,
      "content": "*   Simple applications, prototypes, low-volume tools.\n*   When reliance on a third party is acceptable.\n*   When required data fits well with available API endpoints.\n\nWhile convenient, the limitations often lead developers towards more robust solutions for production applications."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/tutorials/blockchain-indexing/explorer-apis.md",
  "processed_at": "2025-05-11T19:38:56.830671",
  "ai_processed": true
}