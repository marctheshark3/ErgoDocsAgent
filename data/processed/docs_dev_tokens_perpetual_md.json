{
  "id": "docs_dev_tokens_perpetual_md",
  "title": "Perpetual Tokens",
  "summary": "The document discusses two key concepts in ErgoScript:\n\n1. Perpetual Tokens: ErgoScript allows the creation of perpetual tokens, which are designed to exist indefinitely unless removed by garbage collection. The provided code snippet ensures the persistence of a collection of perpetual tokens.\n\n2. Multi-Stage Protocols: Multi-stage protocols enable scripts to reference the scripts of subsequent stages. This is beneficial when multiple scripts need to interact, but it can lead to cyclic reference problems. The document explains how to overcome this issue by storing script hashes in box registers.\n\nThe document also mentions that the \"max-once-per-block-use\" perpetual token offers more flexibility and power compared to the \"vanilla\" perpetual token, and should be considered as a distinct design pattern.",
  "qa_pairs": [
    {
      "question": "What is this document about?",
      "answer": "# Perpetual Tokens\n\nErgoScript allows the creation of a '*perpetual token*', a token that is designed to exist indefinitely, unless it is removed by garbage collection.\n\n```scala\n    {\n      val isPer..."
    },
    {
      "question": "What is the title of this document?",
      "answer": "Perpetual Tokens"
    },
    {
      "question": "What is the 'Perpetual Tokens' section about?",
      "answer": "ErgoScript allows the creation of a '*perpetual token*', a token that is designed to exist indefinit..."
    },
    {
      "question": "What is the 'Multi-Stage Protocols' section about?",
      "answer": "Multi-stage protocols are beneficial in situations where multiple scripts need to interact. In these..."
    }
  ],
  "sections": [
    {
      "heading": "Perpetual Tokens",
      "level": 1,
      "content": "ErgoScript allows the creation of a '*perpetual token*', a token that is designed to exist indefinitely, unless it is removed by garbage collection.\n\n```scala\n    {\n      val isPerpetual = {(b: Box) =>\n        b.propositionBytes == SELF.propositionBytes && b.tokens == SELF.tokens\n      }\n\n      sigmaProp(OUTPUTS.exists(isPerpetual))\n    }\n```\nThis code snippet ensures the persistence of a collection of perpetual tokens, even if the collection's size is zero. If you protect a single token using this script, it guarantees that the token will only be removed by garbage collection.\n\nFor a comprehensive discussion, refer to [this thread](https://www.ergoforum.org/t/a-perpetual-token/205/3)."
    },
    {
      "heading": "Multi-Stage Protocols",
      "level": 2,
      "content": "Multi-stage protocols are beneficial in situations where multiple scripts need to interact. In these protocols, a script can reference the script of a subsequent stage.\n\nFor instance, consider the following example:\n\nIn `script1`, we have the statement:\n\n```scala\nhash(OUTPUTS(0).propositionBytes) == script2Hash\n```\n\nHere, `script1` verifies if the hash of the first output's `propositionBytes` matches the hash of `script2`.\n\nBut, if we want `script2` to refer back to `script1`, as shown below:\n\n```scala\nhash(OUTPUTS(0).propositionBytes) == script1Hash\n```\n\nWe face a cyclic reference problem, as both scripts are referencing each other.\n\nTo overcome this, we can store `script1Hash` in a register of the [box](box.md) that contains `script2`. We also need to modify `script1` to ensure that the corresponding register of any box containing `script2` equals `hash(SELF.propositionBytes)`.\n\nWhile the \"vanilla\" perpetual token is intriguing, the \"max-once-per-block-use\" perpetual token offers more flexibility and power, and should be considered as a distinct design pattern."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/tokens/perpetual.md",
  "processed_at": "2025-05-11T19:38:01.015179",
  "ai_processed": true
}