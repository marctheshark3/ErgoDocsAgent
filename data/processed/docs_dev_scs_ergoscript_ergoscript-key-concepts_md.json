{
  "id": "docs_dev_scs_ergoscript_ergoscript-key-concepts_md",
  "title": "Core Concepts and Key Principles of ErgoScript",
  "summary": "The document discusses the core concepts and key principles of ErgoScript, the scripting language used in the Ergo blockchain platform. Key points:\n\n- Ergo operates on the UTXO (Unspent Transaction Output) model and employs Proof-of-Work consensus. It introduces an extended-UTXO model to enable complex financial contracts.\n- ErgoScript is aligned with the UTXO model and incorporates UTXO-specific constructs like Box, INPUTS, and OUTPUTS.\n- ErgoScript's syntax is a subset of Scala's, but proficiency in Scala is not required. It supports functional programming concepts.\n- An ErgoScript program consists of a sequence of boolean predicates connected by AND and OR.\n- ErgoScript provides cryptographic operations via BigInt and GroupElement types.\n- The spending process involves a prover constructing a cryptographic statement and a proof, which is then verified by a verifier.",
  "qa_pairs": [
    {
      "question": "What is the core difference between Ergo's UTXO model and Ethereum's account-based model?",
      "answer": "Ergo introduces an extended-UTXO model that enables the execution of intricate financial contracts, similar to those supported by Ethereum's account-based model."
    },
    {
      "question": "What are the key constructs in ErgoScript that are aligned with Ergo's UTXO model?",
      "answer": "Key constructs in ErgoScript include `Box`, `INPUTS`, and `OUTPUTS`."
    },
    {
      "question": "How does ErgoScript's syntax compare to Scala's, and what are the key differences?",
      "answer": "ErgoScript's syntax is a subset of Scala's, but it does not support the `var` keyword, and all defined elements are immutable."
    },
    {
      "question": "What are the two main steps involved in the spending process for an Ergo coin?",
      "answer": "The two main steps are: 1) Reduction - the prover uses the ErgoTree interpreter to reduce the ErgoTree proposition to a cryptographic statement, and 2) Signing - the prover turns the cryptographic statement into a signature that can be verified."
    },
    {
      "question": "What are the three inputs required by the verifier to allow valid coin spending?",
      "answer": "The three inputs are: 1) A guarding proposition given by an ErgoTree, 2) The blockchain context, and 3) The proof produced by the prover."
    }
  ],
  "sections": [
    {
      "heading": "Core Concepts and Key Principles of ErgoScript",
      "level": 1,
      "content": ""
    },
    {
      "heading": "ErgoScript and the UTXO Model",
      "level": 2,
      "content": "- Ergo is a blockchain platform that operates on the UTXO (Unspent Transaction Output) model and employs a Proof-of-Work consensus mechanism.\n- Ergo introduces an *extended-UTXO model* that enables the execution of intricate financial contracts, akin to those supported by Ethereum's account-based model.\n- ErgoScript, being aligned with Ergo's UTXO model, incorporates numerous UTXO-specific constructs such as `Box`, `INPUTS`, and `OUTPUTS`. A comprehensive list of these constructs can be found in the [LangSpec](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/docs/LangSpec.md).\n- A [Box](box.md), essentially a UTXO, can accommodate up to ten [registers](registers.md) for data storage. Analogous to Bitcoin, an Ergo transaction consumes one or more existing boxes (represented by the `INPUTS` array) and produces one or more new boxes (represented by the `OUTPUTS` array).\n- ErgoScript is not Turing complete, but it is possible to build Turing-complete applications, as demonstrated in [this peer-reviewed paper](https://arxiv.org/pdf/1806.10116v1.pdf)."
    },
    {
      "heading": "ErgoScript Syntax",
      "level": 2,
      "content": "- ErgoScript's syntax is a subset of Scala's. However, proficiency in Scala is not a prerequisite for learning ErgoScript. The Scala elements used in ErgoScript are minimal and straightforward, such as `val`. Unlike Java or Python, both Scala and ErgoScript access arrays using round parentheses. Hence, `OUTPUTS(0)` denotes the first element of the `OUTPUTS` array. In contrast to Scala, ErgoScript does not support the `var` keyword; all defined elements are immutable. ErgoScript, like Scala, supports functional programming, which simplifies interactions with collections using concepts such as `foreach`, `exists`, `fold`, etc.\n- An ErgoScript program, akin to ErgoTree, consists of a sequence of boolean predicates connected using `&&` (AND) and `||` (OR).\n- ErgoScript provides cryptographic operations via `BigInt` and `GroupElement` (Elliptic curve point) types, along with associated operations like addition, multiplication, and exponentiation. It's important to note that `BigInt` operations in ErgoScript are performed modulo `2^256`, unlike in Scala, hence overflow needs to be carefully managed."
    },
    {
      "heading": "Spending",
      "level": 2,
      "content": "An interacting party willing to spend the coin first constructs a [prover](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/interpreter/shared/src/main/scala/sigmastate/interpreter/ProverInterpreter.scala) with a set of secrets it knows, and then the prover is executed in two steps:\n\n- **Reduction**: The prover uses the ErgoTree interpreter, which deterministically reduces the ErgoTree proposition to a compound _cryptographic statement_ (aka sigma proposition, \u03a3-protocol) by evaluating ErgoTree over the known shared context (state of the blockchain system and a spending transaction). This step produces a value of the [SigmaBoolean](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/interpreter/shared/src/main/scala/sigmastate/Values.scala) type.\n- **Signing**: The prover turns the obtained (and possibly complex) \u03a3-proposition into a signature with the help of a [Fiat-Shamir transformation](https://en.wikipedia.org/wiki/Fiat-Shamir_heuristic). This step produces a _proof_ that the party knows the secrets, such that the knowledge can be verified before the spending transaction is added to the blockchain.\n\nTo allow valid coin spending, a [verifier](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/interpreter/shared/src/main/scala/sigmastate/interpreter/Interpreter.scala) runs the ErgoTree interpreter with the following three inputs:\n\n- A guarding proposition given by an ErgoTree\n- The blockchain **_context_** of the transaction being verified\n- A **_proof_** (aka transaction signature) generated by a **_prover_**\n\nThe verifier is executed as part of transaction validation for each input and proceeds in three steps:"
    },
    {
      "heading": "Reduction",
      "level": 3,
      "content": "Same as the prover, the verifier uses the ErgoTree interpreter and deterministically produces a value of the [SigmaBoolean](sigmaboolean.md) type. However, this step must finish the evaluation for any possible inputs within a concrete fixed time limit (aka maximum cost), which the interpreter checks."
    },
    {
      "heading": "Cost estimation",
      "level": 3,
      "content": "The verifier estimates the complexity of the cryptographic Sigma proposition (based on the size and the concrete nodes of the SigmaBoolean tree). The spending fails if the estimated cost exceeds the maximum limit."
    },
    {
      "heading": "Signature verification",
      "level": 3,
      "content": "The signature checker takes:\n\n1. The *proof*\n2. The *SigmaBoolean* (aka [sigma protocol](https://en.wikipedia.org/wiki/Proof_of_knowledge#Sigma_protocols) proposition)\n3. The *signed message* (e.g., transaction bytes).\n\nThe checker then verifies the proof, which means it verifies that all the necessary secrets were known and used to construct the proof (i.e., sign the transaction)."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/scs/ergoscript/ergoscript-key-concepts.md",
  "processed_at": "2025-05-11T19:28:30.686000",
  "ai_processed": true
}