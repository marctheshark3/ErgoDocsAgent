{
  "id": "docs_dev_stack_mosaik_tutorial4_md",
  "title": "Ergo Mosaik: A UI system for Ergo dApps",
  "summary": "Ergo Mosaik is a UI system for Ergo dApps. This tutorial series covers the implementation of a \"Send Funds\" screen as an example application for executing transactions on the Ergo network based on user input.\n\nThe tutorial covers:\n- Implementing the UI for the \"Send Funds\" screen using Mosaik components like AddressChooseButton, ErgAddressInputField, and FiatOrErgAmountInputField.\n- Building a reduced transaction based on user input using the Ergo SDK (ergo-appkit).\n- Wrapping the reduced transaction in the ErgoPay protocol to allow the user to sign the transaction.\n- Integrating the ErgoPay signing request into the Mosaik UI.\n\nThe tutorial demonstrates how a single Spring Boot process can serve multiple separated Mosaik apps and how to leverage the ErgoPay protocol to enable secure transaction signing in Ergo dApps.",
  "qa_pairs": [
    {
      "question": "What is the purpose of the Ergo Mosaik UI system?",
      "answer": "Ergo Mosaik is a UI system for creating dApps on the Ergo blockchain."
    },
    {
      "question": "What are the main components used to implement the Send Funds screen?",
      "answer": "The main components used are AddressChooseButton, ErgAddressInputField, FiatOrErgAmountInputField, and a button to send the transaction."
    },
    {
      "question": "How is the reduced transaction created for the ErgoPay protocol?",
      "answer": "The reduced transaction is created using the ergo-appkit SDK, by building an unsigned transaction and then reducing it to a context-independent form."
    },
    {
      "question": "What are the two main steps involved in using ErgoPay?",
      "answer": "The two main steps are: 1) Building a reduced transaction based on user input, and 2) Wrapping the reduced transaction into the ErgoPay protocol."
    },
    {
      "question": "How can a single Spring Boot process serve multiple separated Mosaik apps?",
      "answer": "A single Spring Boot process can serve multiple separated Mosaik apps by adding new controller classes and using new endpoints for each app."
    }
  ],
  "sections": [
    {
      "heading": "Ergo Mosaik: A UI system for Ergo dApps",
      "level": 1,
      "content": ""
    },
    {
      "heading": "Part 4: Implementing Sending Funds screen",
      "level": 2,
      "content": "Welcome back to the Ergo Mosaik tutorial series! In this part of the series, we want to implement a Send Funds screen as an example application on how to execute transactions on the ergo network based on user input. \nFor this, we use the lessons learned in Part 2 (implementing a simple screen) and Part 3 (processing data) of this tutorial, and mix in some new knowledge regarding ErgoPay. You can find an in-depth tutorial for \nErgoPay in [1], but we cover everything needed here as well.\n\nOur plan is the following: We want to implement a screen where the user can connect his wallet and can enter a recipient and an ERG amount to send. When clicking send, the user should be able to sign a \ntransaction reflecting the entered data - and we are done.\n\nImplementing the screen is, after completing the former tutorials, just a simple exercise for us.\n\n\n\n* We will lay out all elements in a Column\n* Connecting the wallet is done with an \u201cAddressChooseButton\u201d (we could also use the \u201cWalletChooseButton\u201d, but we keep it a bit simpler for this exercise)\n* Recipient address is done with an \u201cErgAddressInputField\u201d\n* Entering the ERG amount is done with a \u201cFiatOrErgAmountInputField\u201d (we could also use \u201cErgAmountInputField\u201d, but why not use the free extra functionality?)\n* User can send the amount by pushing a button"
    },
    {
      "heading": "Implementing the UI",
      "level": 4,
      "content": "We will implement our new send funds app in our existing tutorial project, but we will add a new controller class and use a new endpoint to separate it from our former demo app we\u2019ve implemented so far.\nThis serves also as an example that a single Spring Boot process can serve multiple separated Mosaik apps, if this is needed. Our bare new controller will look like this (see Part 2 \u201cA first simple screen\u201d)\n\n\n```\n@RestController\nclass SendFundsAppController {\n   @GetMapping(\"/sendfunds\")\n   fun getSendFundsApp(): MosaikApp {\n\n   }\n}\n```\n\n\nSo, let\u2019s get to it and fill it with actual useful content!\n\n\n```\nprivate val idSenderAddress = \"ergaddress\"\nprivate val idRecipient = \"recipient\"\nprivate val idAmountToSend = \"amount\"\n\n@GetMapping(\"/sendfunds\")\nfun getSendFundsApp(): MosaikApp {\n   return mosaikApp(\n       \"Send Funds Mosaik App\",\n       appVersion = 1\n   ) {\n       card {\n           column(Padding.DEFAULT) {\n\n               ergoAddressChooser(idSenderAddress)\n\n               ergAddressInputField(idRecipient, \"Recipient\", mandatory = true)\n\n               ergAmountInputField(idAmountToSend, \"Amount\", canUseFiatInput = true) {\n                   minValue = 1000 * 1000\n               }\n\n               button(\"Send\")\n           }\n       }\n   }\n}\n```\n\n\nThere is no surprise here, we reused all our knowledge from part 2 and part 3 and took some inspiration from the view element demo app\u2019s source code as well. Running the app in \nthe demo executor shows the expected:\n\n\n![Mosaik 1](../../../assets/img/mosaik/tutorial4-1.png)\n\n\nA remark regarding the functionality of the \u201cChoose an address\u2026\u201d button: The desktop debugger will show an ugly input dialog to enter an address when clicked. This is of course not \nwhat an end user will see. When using the Android app and clicking the button, the user will get presented the known address selection dialog:\n\n![Mosaik 2](../../../assets/img/mosaik/tutorial4-2.png)\n\n\nWhat is missing is the actual action of the send button."
    },
    {
      "heading": "ErgoPay: Preparing a transaction for the user to sign",
      "level": 4,
      "content": "When the Send button is clicked, we want to prepare a transaction with the entered data which the user needs to sign before submitting it to the ergo network. This is exactly what ErgoPay \nis intended for: ErgoPay is a protocol to transfer a prepared \u201creduced transaction\u201d to a wallet and let the user sign and submit it. What is a \u201creduced transaction\u201d? It is an unsigned \ntransaction with all blockchain context-dependent variables already replaced by actual data (In case of a simple payment without any smart contracts, it is nearly the same as an unsigned \ntransaction). That means we have three task to tackle:\n\n\n\n* Building a reduced transaction based on user input\n* wrap it into ErgoPay protocol\n* make the send button use ErgoPay"
    },
    {
      "heading": "Building a reduced transaction based on user input",
      "level": 4,
      "content": "This task is already completely covered by [1]. We will do all necessary steps here together, but without much explanation - you can find more explanation in [1].\n\nTo build a reduced transaction, we need to import ergo-appkit, Ergo\u2019s SDK for JVM languages into our project. We do this by adding it as a dependency to our build.gradle.kts file \nin the dependencies section:\n\n\n```\n    // ErgoPay\n    implementation (\"org.ergoplatform:ergo-appkit_2.12:4.0.10\")\n```\n\n\nWhen we have done that, we can add a helper method that builds a reduced transaction to send a given nanoerg amount from a given sender to a given recipient:\n\n\n```\nprivate fun getReducedSendTx(\n   amountToSend: Long,\n   sender: Address,\n   recipient: Address\n): ReducedTransaction {\n   val networkType = recipient.networkType\n   return RestApiErgoClient.create(\n       getDefaultNodeUrl(networkType),\n       networkType,\n       \"\",\n       RestApiErgoClient.getDefaultExplorerUrl(networkType)\n   ).execute { ctx: BlockchainContext ->\n       val contract = recipient.toErgoContract()\n       val unsignedTransaction = BoxOperations.createForSender(sender, ctx)\n           .withAmountToSpend(amountToSend)\n           .putToContractTxUnsigned(contract)\n       ctx.newProverBuilder().build().reduce(unsignedTransaction, 0)\n   }\n}\n\n// this class processes all requests from the an ErgoPay wallet application\nval nodeMainnet = \"http://213.239.193.208:9053/\"\nval nodeTestnet = \"http://213.239.193.208:9052/\"\n\nprivate fun getDefaultNodeUrl(networkType: NetworkType): String =\n   if (networkType == NetworkType.MAINNET) nodeMainnet else nodeTestnet\n```\n\n\nYou can change the node used here to your own, or find another one on [2]."
    },
    {
      "heading": "Wrapping the reduced transaction",
      "level": 4,
      "content": "Now we have to wrap this transaction into the ErgoPay protocol. ErgoPay protocol is defined in [3]: according to it, we need to wrap the transaction into a \njson with the following content:\n\n\n      - transaction: ReducedTransaction (optional*)\n\n\n      - p2pkaddress: String (optional)\n\n\n      - message: String (optional*)\n\n\n      - messageSeverity: String (optional) \"INFORMATION\", \"WARNING\", \"ERROR\"\n\n\n      - replyToUrl: String (optional)\n\nModel classes like \u201cErgoPay for ErgoPay are already defined to be used in Spring projects in another dependency that we can pull in by adding it to our build.gradle.kts file:\n\n\n```\n    implementation (\"com.github.MrStahlfelge:ergoplatform-jackson:4.0.10\")\n```\n\n\nThe json should be served on an own http endpoint, so we add the ErgoPay endpoint to our SendFundsAppController class:\n\n\n```\n@GetMapping(\"/sendFunds/{sender}/{recipient}/{amount}\")\nfun sendFundsSigningRequest(\n   @PathVariable sender: String,\n   @PathVariable recipient: String,\n   @PathVariable amount: Long\n): ErgoPayResponse {\n   val response = ErgoPayResponse()\n   try {\n       val reduced = getReducedSendTx(amount, Address.create(sender), Address.create(recipient)).toBytes()\n       response.reducedTx = Base64.getUrlEncoder().encodeToString(reduced)\n       response.address = sender\n       response.message = \"Please sign the transaction.\"\n       response.messageSeverity = ErgoPayResponse.Severity.INFORMATION\n   } catch (t: Throwable) {\n       response.messageSeverity = ErgoPayResponse.Severity.ERROR\n       response.message = t.message\n   }\n   return response\n}\n```\n\n\nAs you can see, the ErgoPay endpoint URL contains exactly the parameters the user can enter. Because we added the @PathVariable annotation, Spring will automatically map the URL path placeholders to the method parameters. The returned ErgoPayResponse object will be converted to json by Spring, too."
    },
    {
      "heading": "Make the Send button use ErgoPay",
      "level": 4,
      "content": "All we have to do now is map the Mosaik user inputs to the ErgoPay endpoint URL and make the executing wallet application fetch it as an ErgoPay input.\n\nWe know from part 3 of the tutorial series, that we can process user inputs with a ServerRequestAction/BackendRequest, and that this request will return a new action. When we \nreturn an ErgoPayAction here, we will get exactly the needed behavior. So we make the send button perform a backend request:\n\n\n```\n    button(\"Send\") {\n       onClickAction(backendRequest(\"sendfundsClicked\"))\n    }\n```\n\n\n\n\nWe also need to provide the endpoint for this request:\n\n\n```\n@PostMapping(\"/sendfunds/sendfundsClicked\")\nfun sendFundsClicked(@RequestBody values: Map<String, Any?>, request: HttpServletRequest): FetchActionResponse {\n   val sender = values[idSenderAddress] as? String\n   val recipient = values[idRecipient] as? String\n   val amount = (values[idAmountToSend] as? Number)?.toLong()   // 1\n\n   // 2\n   val ok =\n       sender != null && recipient != null && amount != null && (amount >= Parameters.MinChangeValue)\n\n   val responseAction: Action = if (!ok) {\n       showDialog(\"Inputs are not valid\", id = \"errorDialog\")\n   } else {\n       // 3\n       val thisEndpointHostname = request.requestURL.toString().substringAfter(\"://\").substringBefore(\"/\")\n       val ergoPayUrl = \"ergopay://$thisEndpointHostname/sendFunds/$sender/$recipient/$amount\"\n       invokeErgoPay(ergoPayUrl, id = \"epSendFunds\")\n   }\n\n   return backendResponse(\n       1,\n       responseAction\n   )\n}\n```\n\n\nSo far, this is how we\u2019ve learned it, but there are some marked lines to comment on:\n\nFor 1), the cast to number and then conversion to long might surprise. We know that the ErgAmountInputField always use Long - what is going on here? To understand this, \nyou must remind yourself that the actual long value is transmitted by JSON format and automatically converted back by Spring. JSON has only a number format, and when Spring \nconverts this number back into a JVM object, it does not know if this number is a Long or an Integer, so it choses Integer when the value is not too large. That\u2019s why the amount \nvalue can be wrapped in an Integer or a Long object. Casting to Number and converting to Long makes sure we have a Long value in our amount variable.\n\nFor 2), our backend request makes sure all values are set with valid inputs, so this check seems unnecessary. We recommend you to double check values: The executor-side checks\nare more meant for convenience for the user, but you should not rely on them. Different Mosaik executors might do less strict checks.\n\nFinally, we have 3): The ergoPay url is build with the use of request.requestUrl, with request being a HttpServletRequest object automatically provided by Spring when \ndeclared on an endpoint method. This is used here to automatically use the hostname the client wallet used to connect to our endpoint to; the hostname can be completely different, \nfor example, while testing, you might connect to [http://localhost:8080](http://localhost:8080) or from within your network to [http://192.178.0.10:8080](http://192.178.0.10:8080). \nBy using the HttpServletRequest, you can make sure to build the ergoPay Url in a way the client can reach it.\n\nWhen you run this Mosaik app in the desktop debugger, it gives the expected behavior. Far more fun is it to run the app in the Android wallet app, which will really make a \ntransaction on the ergo network. The only task left is a minor issue: When the ErgoPay transaction was performed, we are sent back to the Mosaik app which is still showing the \nformer inputs. It is better to empty them by simply reloading the app. You will find this implemented in the GitHub repository for this example [4]."
    },
    {
      "heading": "Conclusion",
      "level": 4,
      "content": "We implemented a Mosaik app that sends funds based on user inputs in a trustless way. Your app don\u2019t need access to the user\u2019s secrets, and the user can review every transaction \nmade from your app before signing it. This is all done from a single simple codebase in Kotlin, served by a Spring Boot process.\n\nThe tutorial on implementations is now done. The next part will take a look at what comes next: Deployment, and how you can make your Mosaik app working on web browsers. See you next time!\n\n\n---\n\n[1] [https://medium.com/@bschulte19e/implement-a-dapp-using-ergopay-d95e17a51410](https://medium.com/@bschulte19e/implement-a-dapp-using-ergopay-d95e17a51410)\n\n[2] [https://api.tokenjay.app/peers/list](https://api.tokenjay.app/peers/list)\n\n[3] [https://github.com/ergoplatform/eips/blob/master/eip-0020.md](https://github.com/ergoplatform/eips/blob/master/eip-0020.md)\n\n[4] [https://github.com/MrStahlfelge/mosaik-tutorial-series/blob/af520069f88163aa833d330a060cde136d7a070e/src/main/kotlin/com/example/ergomosaik/mosaikapp/SendFundsAppController.kt](https://github.com/MrStahlfelge/mosaik-tutorial-series/blob/af520069f88163aa833d330a060cde136d7a070e/src/main/kotlin/com/example/ergomosaik/mosaikapp/SendFundsAppController.kt)"
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/stack/mosaik/tutorial4.md",
  "processed_at": "2025-05-11T19:36:12.347102",
  "ai_processed": true
}