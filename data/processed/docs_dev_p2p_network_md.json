{
  "id": "docs_dev_p2p_network_md",
  "title": "Network Messages in Ergo's P2P Protocol",
  "summary": "This document provides a detailed overview of the network messages in Ergo's P2P protocol. It covers the message format, which includes magic bytes, message code, message body length, handshake body checksum, and message body. It also discusses the different types of records used in the protocol, such as Peer, Feature, Modifier, and Header records, and how they are serialized. Finally, it describes the various messages used for communication between nodes, including Get Peers, Peers, Sync Info, Inv, Request Modifier, and Modifier messages.",
  "qa_pairs": [
    {
      "question": "What are the magic bytes used for the Ergo mainnet and testnet?",
      "answer": "{1, 0, 2, 4} for mainnet, {2, 0, 0, 1} for testnet."
    },
    {
      "question": "What is the format of the Peer record in the Ergo P2P protocol?",
      "answer": "The Peer record includes fields for agent name, version, peer name, whether a public address exists, the public IP address, the port, and a list of peer features."
    },
    {
      "question": "How is the length of the IP address field encoded in the Peer record?",
      "answer": "The length of the IP address field is encoded as an unsigned byte that is 4 more than the actual length. When decoding, the value must be subtracted by 4 to get the actual length."
    },
    {
      "question": "What is the purpose of the handshake body checksum field in the message format?",
      "answer": "The handshake body checksum field contains the first four bytes of the blake2b256 hash of the message body."
    },
    {
      "question": "What other types of records are used in the Ergo P2P protocol besides the Peer record?",
      "answer": "Other records used in the protocol include Feature, Modifier, and Header records."
    }
  ],
  "sections": [
    {
      "heading": "Introduction",
      "level": 0,
      "content": "---\ntags:\n  - P2P\n---"
    },
    {
      "heading": "Network Messages in Ergo's P2P Protocol",
      "level": 1,
      "content": "This document provides a detailed overview of the network messages in Ergo's P2P protocol. Understanding these messages is crucial for interacting with the Ergo network at a low level. Each message in the protocol has a specific format and serves a unique purpose in the communication between nodes."
    },
    {
      "heading": "Message Format",
      "level": 2,
      "content": "Every message in the P2P protocol has the following format:\n\n| Data type         | Field name              | Details                                                                                                                      |  \n|:------------------|:------------------------|:-----------------------------------------------------------------------------------------------------------------------------|\n| byte\\[4\\]         | Magic bytes             | For the mainnet, the magic bytes are `{1, 0, 2, 4}`. For testnet, `{2, 0, 0, 1}`.                                            |              \n| unsigned byte     | Message code            | One byte describing message type                                                                                             |\n| int               | Message body length     | No `VLQ` or `ZigZag` encoding is used for the message length (for historical reasons); bytes are coming in big-endian order. |\n| byte\\[4\\]         | Handshake body checksum | First four bytes of blake2b256(message body)                                                                                 |                                        \n| byte\\[bodyLength] | Message body            | Message body                                                                                                                 |\n\nFor more detailed implementation, you can check out the [Ergo Node View Synchronizer](https://github.com/ergoplatform/ergo/blob/master/src/main/scala/org/ergoplatform/network/ErgoNodeViewSynchronizer.scala) in the Ergo repository."
    },
    {
      "heading": "Records",
      "level": 2,
      "content": "Records are structured data types used in the P2P protocol. They include Peer, Feature, Modifier, and Header records."
    },
    {
      "heading": "Peer",
      "level": 3,
      "content": "| Data type               | Field name                    | Details                                                           |\n|:------------------------|:------------------------------|:------------------------------------------------------------------|\n| unsigned byte           | *Length of next field*        |\n| UTF-8 String            | Agent name                    |\n| byte\\[3\\]               | Version                       | For example, `{4, 0, 25}`                                         |\n| unsigned byte           | *Length of next field*        |\n| UTF-8 String            | Peer name                     |\n| boolean                 | Whether public address exists |\n| (unsigned byte)         | Length of the IP **plus 4**   | When decoding, subtract the value with 4 to get the actual length |\n| (byte\\[ipLength - 4\\])  | The public IP address         |\n| (VLQ unsigned **int**)  | Port                          |\n| unsigned byte           | Count of peer features        |\n| Feature\\[featureCount\\] | Features                      |"
    },
    {
      "heading": "Feature",
      "level": 3,
      "content": "| Data type          | Field name   |\n|:-------------------|:-------------|\n| unsigned byte      | Feature code |\n| VLQ unsigned short | Body length  |\n| byte\\[bodyLength\\] | Body         |"
    },
    {
      "heading": "Modifier (Record)",
      "level": 3,
      "content": "| Data type            | Field name       |\n|:---------------------|:-----------------|\n| byte\\[32\\]           | Modifier ID      |\n| VLQ unsigned int     | Length of object |\n| byte\\[objectLength\\] | Object           |"
    },
    {
      "heading": "Header",
      "level": 3,
      "content": "| Data type          | Field name      |\n|:-------------------|:----------------|\n| VLQ unsigned short | Length of bytes |\n| byte\\[length]      | Bytes           |\n\nFor a deeper understanding of how records are serialized, check out the [Ergo Serialization Documentation](https://github.com/ergoplatform/ergo/blob/master/ergo-core/src/main/scala/org/ergoplatform/serialization/ErgoSerializer.scala)."
    },
    {
      "heading": "Messages",
      "level": 2,
      "content": "Messages are the primary means of communication between nodes in the P2P network. They include Get Peers, Peers, Sync Info, Inv, Request Modifier, and Modifier messages."
    },
    {
      "heading": "Get Peers",
      "level": 3,
      "content": "**Code = 1**\n\nThe body is empty."
    },
    {
      "heading": "Peers",
      "level": 3,
      "content": "**Code = 2**\n\nSent in response to Get Peers. Contains all the peers that are currently connected to. Used for node discovery.\n\n| Data type         | Field name     |\n|:------------------|:---------------|\n| VLQ ZZ int        | Count of peers |\n| [Peer](#peer)\\[\\] | Peers          |\n\nFor the Java implementation of the `GetPeers` message, refer to [Ergonnection](https://github.com/Satergo/Ergonnection/blob/master/src/main/java/com/satergo/ergonnection/messages/GetPeers.java)."
    },
    {
      "heading": "Sync Info",
      "level": 3,
      "content": "**Code = 65**\n\n**New (Added in 4.0.16)**\n\nIt is sent only to nodes that report a version of 4.0.16 or higher. For older nodes, the [Sync Info (old)](#sync-info-old) is sent.\n\nRequests an [Inv](#inv) message that provides modifier IDs required by the sender to synchronize their blockchain with the recipient. It allows a peer which has been disconnected or started for the first time to get the data it needs to request the blocks it hasn't seen.\n\n| Data type                        | Field name              |\n|:---------------------------------|:------------------------|\n| VLQ unsigned short               | The constant value `0`  |\n| byte                             | The constant value `-1` |\n| unsigned byte                    | Count of headers        |\n| [Header](#header)\\[headerCount\\] | Headers                 |"
    },
    {
      "heading": "Sync Info (old)",
      "level": 3,
      "content": "**Code = 65**\n\nThe old (before 4.0.16) version of the Sync Info message.\n\n| Data type                       | Field name                       |\n|:--------------------------------|:---------------------------------|\n| VLQ unsigned short              | Count of last header IDs         |\n| byte\\[32\\]\\[lastHeaderIdCount\\] | Last header IDs (ID byte arrays) |"
    },
    {
      "heading": "Inv",
      "level": 3,
      "content": "**Code = 55**\n\nTransmits one or more inventories of objects known to the transmitting peer.\n\nIt can be sent unsolicited to announce new transactions or blocks, or it can be sent in reply to a [Sync Info](#sync-info) message.\n\n| Data type                  | Field name                |\n|:---------------------------|:--------------------------|\n| unsigned byte              | Type ID                   |\n| VLQ unsigned int           | Count of elements         |\n| byte\\[32\\]\\[elementCount\\] | Elements (ID byte arrays) |\n\nFor an example of how INV messages are handled, see [InvSpec.scala](https://github.com/ergoplatform/ergo/blob/master/ergo-core/src/main/scala/org/ergoplatform/network/message/InvSpec.scala)."
    },
    {
      "heading": "Request Modifier",
      "level": 3,
      "content": "**Code = 22**\n\nRequests one or more modifiers from another node. The objects are requested by an inventory, which the requesting node typically received previously with an [Inv](#inv) message.\n\nThis message cannot be used to request arbitrary data, such as historic transactions no longer in the memory pool. Full nodes may not even be able to provide older blocks if they've pruned old transactions from their block database.\n\nFor this reason, this message should usually only be used to request data from a node that previously advertised it had that data by sending an [Inv](#inv) message.\n\n| Data type                  | Field name                |\n|:---------------------------|:--------------------------|\n| unsigned byte              | Modifier type ID          |\n| VLQ unsigned int           | Count of elements         |\n| byte\\[32\\]\\[elementCount\\] | Elements (ID byte arrays) |"
    },
    {
      "heading": "Modifier",
      "level": 3,
      "content": "**Code = 33**\n\nSent in response to Request Modifier.\n\n| Data type                                     | Field name         |\n|:----------------------------------------------|:-------------------|\n| unsigned byte                                 | Type ID            |\n| VLQ unsigned int                              | Count of modifiers |\n| [Modifier](#modifier-record)\\[modifierCount\\] | Modifiers          |"
    },
    {
      "heading": "Pull Requests (PRs) & Tests",
      "level": 2,
      "content": "The [NiPoPoW powered bootstrapping PR #1365](https://github.com/ergoplatform/ergo/issues/1365) is a relevant enhancement that introduces a method to bootstrap nodes using Non-Interactive Proofs of Proof-of-Work (NiPoPoWs). \n\nTests for parsing networking messages against test vectors are discussed in PR [#1264](https://github.com/ergoplatform/ergo/pull/1264), which includes:\n\n- Enhanced validation with `require()` for non-elidable checks.\n- Simplified test vectors for invalid PoW solution validation and handshake parsing.\n- Introduced SyncInfo networking message parsing test (can be used as a simple spec).\n\nThese tests ensure robust handling of network messages in Ergo\u2019s P2P protocol."
    },
    {
      "heading": "Demo Applications",
      "level": 2,
      "content": "Demo applications are available for practical implementation, such as:\n\n- **Address Generation**: [AddressGenerationDemo](https://github.com/ergoplatform/ergo/blob/master/ergo-wallet/src/test/java/org/ergoplatform/wallet/AddressGenerationDemo.java)\n- **Transaction JSON Printing**: [CreateTransactionDemo](https://github.com/ergoplatform/ergo/blob/master/ergo-wallet/src/test/java/org/ergoplatform/wallet/CreateTransactionDemo.java)\n\nThese demos provide examples of how to generate addresses and print transactions using the Ergo wallet functionalities."
    },
    {
      "heading": "Resources",
      "level": 2,
      "content": "- A simple implementation of VLQ and ZigZag encoding can be found [here](https://gist.github.com/satsen/5e7bcc38565ad193cf7d906a856f804e).\n- A complete implementation of the P2P protocol written in Java can be found in [Ergonnection](https://github.com/Satergo/Ergonnection)."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/p2p/network.md",
  "processed_at": "2025-05-11T19:23:15.221767",
  "ai_processed": true
}