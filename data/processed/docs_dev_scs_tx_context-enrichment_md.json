{
  "id": "docs_dev_scs_tx_context-enrichment_md",
  "title": "Context Enrichment",
  "summary": "The document discusses context enrichment in Bitcoin and other UTXO-based blockchain systems. It introduces four levels of context, with Level 2 and above being suitable for supporting transaction trees. The document shows how to create efficient Ethereum-like contracts in the UTXO model using transaction trees, with examples including a Rock-Paper-Scissors game, an ICO campaign, and reversible addresses. It also discusses the need for efficient emulation of Turing completeness beyond the use of Rule 110 cellular automation, and how code in context Level 2 and higher can ensure that each stage of a multi-stage protocol is followed.",
  "qa_pairs": [
    {
      "question": "What is the minimum level of context required for a UTXO-based system to support transaction trees?",
      "answer": "Level 2: current transaction (inputs and outputs)"
    },
    {
      "question": "What are the four levels of context defined in the document?",
      "answer": "1. current UTXO, height and timestamp, 2. current transaction (inputs and outputs), 3. current block header and block solution, 4. current block (other sibling transactions)"
    },
    {
      "question": "Which level of context does Bitcoin operate at?",
      "answer": "Level 1"
    },
    {
      "question": "Which level of context does Ergo operate at?",
      "answer": "Level 3"
    },
    {
      "question": "What are the two conditions checked in the example Scala code to ensure the protocol is followed?",
      "answer": "1. Whether the propositionBytes of the out box is equal to state_n_code, 2. Whether the R4 register of the out box is equal to the R4 register of the current SELF box"
    }
  ],
  "sections": [
    {
      "heading": "Context Enrichment",
      "level": 1,
      "content": "In Bitcoin and other existing UTXO systems, the *context* is just the UTXO being processed. \n\nIn order for a UTXO-based system to support transaction trees, the context must be rich enough to contain at least the entire spending transaction.\n\nMore formally, for any UTXO based blockchain, we can define the following levels of context, each extending the previous:\n\n- **Level 1**: current UTXO, height and timestamp\n- **Level 2**: current transaction (inputs and outputs)\n- **Level 3**: current block header and block solution\n- **Level 4**: current block (other sibling transactions)\n \nAny platform at Level 2 and above is suitable for transaction trees. In this regard, Bitcoin operates at Level 1 and Ergo at Level 3. \n\nNote that in Level 4 we cannot check validity of transactions independently of other transactions in the block. Hence it is more complex to implement Level 4.\n\n\nIn this work we show via examples how to create efficient Ethereum-like contracts in the UTXO model using transaction trees. The examples include a Rock-Paper-Scissors game, an Initial Coin Offering (ICO) campaign and a new primitive called reversible addresses for securely storing funds."
    },
    {
      "heading": "Enriched Context Levels",
      "level": 3,
      "content": "- Script code can have predicates on objects in context. \n    - Example `OUTPUT(0).value >= 1000`\n- It is known that Level 2 can emulate Turing complete (hence Ethereum)\nHowever, the proof uses Rule 110 cellular automation. Reduction is not efficient\n- We need something more efficient than Rule 110. This is our contribution."
    },
    {
      "heading": "How to ensure that each stage follows protocol?",
      "level": 2,
      "content": "Code in context Level 2 and higher allows multistage protocols\n\nSpending transactions must create another UTXO with the required properties. \n\n```scala\nout.propositionBytes == state_n_code && \nout.R4[Int].get == SELF.R4[Int].get // ensure data is propagated\n```\n\nThis code is checking two conditions:\n\n- Whether the propositionBytes of the out box is equal to state_n_code.\n- Whether the R4 register of the out box is equal to the R4 register of the current SELF box.\n\nThe first condition checks if the script of the output box matches the expected script (as represented by state_n_code). If this condition is not satisfied, the script will reject the transaction.\n\nThe second condition ensures that a certain data value stored in the R4 register is propagated from the current box to the output box. If this condition is not satisfied, the script will reject the transaction."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/scs/tx/context-enrichment.md",
  "processed_at": "2025-05-11T19:31:43.078921",
  "ai_processed": true
}