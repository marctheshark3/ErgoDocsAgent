{
  "id": "docs_dev_lib_plasma_md",
  "title": "Plasma",
  "summary": "Plasma is a library on top of Ergo Appkit that provides an abstraction layer to simplify the process of integrating AVL Trees (Plasma) into off-chain code. It aims to give developers an easy way to use this Layer-2 scaling solution in contracts, off-chain code, and distributed systems managing the Plasma itself. The library uses the default versioned storage implementation powered by LevelDB, with another SwayDB implementation in the works. It provides Plasma Maps, Local Plasma Maps, and Proxy Plasma Maps to interact with the AVL Trees. The document also includes references to example projects and resources related to Plasma.",
  "qa_pairs": [
    {
      "question": "What is the purpose of the GetBlok Plasma library?",
      "answer": "The GetBlok Plasma library provides an abstraction layer to simplify the process of integrating AVL Trees (Plasma) into off-chain code, giving developers an easy way to use this Layer-2 scaling solution in contracts, off-chain code, and distributed systems managing the Plasma itself."
    },
    {
      "question": "How are Plasma Maps different from normal Scala maps?",
      "answer": "Plasma Maps use 32 byte digests and Blake2b256 hashing, and can store any class so long as there is a corresponding implicit ByteConversion for that class."
    },
    {
      "question": "What is the purpose of a ProxyPlasmaMap?",
      "answer": "A ProxyPlasmaMap applies changes on a temporary tree which allows you to receive proofs for the operations you perform, but none of these changes are saved to storage until the commitChanges() function is called, ensuring that unexpected errors can be dealt with easily."
    },
    {
      "question": "How do you create a LocalPlasmaMap?",
      "answer": "To create a LocalPlasmaMap, you must use a VersionedLDBAVLStorage and an LDBVersionedStore, and pass these to the constructor of the LocalPlasmaMap class."
    },
    {
      "question": "What is the difference between a normal Plasma Map and a LocalPlasmaMap?",
      "answer": "A normal Plasma Map is un-stored / temporary, while a LocalPlasmaMap is locally stored and uses a VersionedLDBAVLStorage and LDBVersionedStore to persist the data."
    }
  ],
  "sections": [
    {
      "heading": "Introduction",
      "level": 0,
      "content": "---\ntags:\n  - Plasma\n  - AVL Trees\n  - Layer 2\n  - Library\n  - GetBlok\n---"
    },
    {
      "heading": "Plasma",
      "level": 1,
      "content": "[GetBlok Plasma](https://github.com/GetBlok-io/GetBlok-Plasma) is a library on top of Ergo [Appkit](appkit.md) that provides an abstraction layer to simplify the process of integrating AVL Trees (AKA Plasma) into off-chain code. The goal is to give developers an easy way to use this Layer-2 scaling solution in contracts, off-chain code, and distributed systems managing the Plasma itself. GetBlok Plasma uses the default versioned storage implementation powered by LevelDB, with another SwayDB implementation in the works. **This allows for distributed systems to keep track of the key-value pairs held in digests stored on-chain.**\n\nSee these documents to get started;\n\n- [AVL Trees / Plasma In ErgoScript: Basics, Tips, and Design Patterns](https://github.com/GetBlok-io/GetBlok-Plasma/blob/master/documents/AVL_Trees.MD)\n- [Mining Pool Operating At Layer 2](https://github.com/GetBlok-io/GetBlok-Plasma/blob/master/documents/SmartPool_Plasma.MD)"
    },
    {
      "heading": "Details",
      "level": 2,
      "content": "Creating and managing AVL Trees is greatly simplified when using the library. To create a normal,\nun-stored / temporary AVL Tree, we use *Plasma Maps*. Plasma Maps look similar to normal Scala maps on the surface\nwith a few changes that make them compatible with on-chain AVL Trees.\n\n```scala\nimport io.getblok.getblok_plasma.PlasmaParameters\nimport io.getblok.getblok_plasma.collections.PlasmaMap\nimport org.ergoplatform.appkit.ErgoId\nimport sigmastate.{AvlTreeFlags, Values}\n// Plasma Map that uses ErgoId's as keys, and ErgoTrees as values\nval plasmaMap = new PlasmaMap[ErgoId, Values.ErgoTree](AvlTreeFlags.AllOperationsAllowed, PlasmaParameters.default)\n```\n\nAll Plasma Maps use 32 byte digests and Blake2b256 hashing. Any class may be inserted into a Plasma Map\nso long as there is a corresponding implicit `ByteConversion` for that class.\n\n```scala\nimport io.getblok.getblok_plasma.ByteConversion\nimport org.ergoplatform.appkit.ErgoId\nimport sigmastate.Values\nimport sigmastate.serialization.ErgoTreeSerializer\n\n// Default ByteConversions for ErgoId and ErgoTree\nimplicit val convertsId: ByteConversion[ErgoId] = new ByteConversion[ErgoId] {\n  override def convertToBytes(t: ErgoId): Array[Byte] = t.getBytes\n\n  override def convertFromBytes(bytes: Array[Byte]): ErgoId = new ErgoId(bytes)\n}\n\nimplicit val convertsErgoTree: ByteConversion[Values.ErgoTree] = new ByteConversion[Values.ErgoTree] {\n  override def convertToBytes(t: Values.ErgoTree): Array[Byte] = t.bytes\n\n  override def convertFromBytes(bytes: Array[Byte]): Values.ErgoTree = ErgoTreeSerializer.DefaultSerializer.deserializeErgoTree(bytes)\n}\n```\n\nCustom classes may also be used with their own definitions to allow for flexibility in contracts:\n\n```scala\nimport com.google.common.primitives.{Ints, Longs}\nimport io.getblok.getblok_plasma.ByteConversion\nimport org.bouncycastle.util.encoders.Hex\nimport org.ergoplatform.appkit.{ErgoType, ErgoValue}\nimport sigmastate.eval.Colls\nimport special.collection.Coll\n\ncase class StateScore(score: Long, paid: Boolean) {\n  def toBytes: Array[Byte] = Longs.toByteArray(score) ++ Array(if(paid) 1.toByte else 0.toByte)\n}\n\ndef getPaid(byte: Byte): Boolean = {\n  byte match {\n    case 0 =>\n      false\n    case 1 =>\n      true\n    case _ =>\n      throw new Exception(\"A payment byte was serialized incorrectly!\")\n  }\n}\n  implicit val scoreConversion: ByteConversion[StateScore] = new ByteConversion[StateScore] {\n    override def convertToBytes(t: StateScore): Array[Byte] = t.toBytes\n\n    override def convertFromBytes(bytes: Array[Byte]): StateScore = StateScore(Longs.fromByteArray(bytes.slice(0, 8)), getPaid(bytes.slice(8, 9).head))\n  }\n```\n\nOnce a Plasma Map is created, operations may be performed on it. All operations done on a Plasma Map\nreturn some `OpResult` that wraps the Plasma Map's *value* field. The set of these `OpResult`s\nare returned in a `ProvenResult`, which holds the returned values along with a `Proof` object that holds\nthe corresponding proof for the batched set of operations. `OpResult`s are all returned in the order in \nwhich they were entered.\n\n```scala\nimport io.getblok.getblok_plasma.PlasmaParameters\nimport io.getblok.getblok_plasma.collections.{OpResult, PlasmaMap, Proof, ProvenResult}\nimport io.getblok.getblok_plasma.ByteConversion.convertsLongVal\nimport org.ergoplatform.appkit.ErgoId\nimport sigmastate.AvlTreeFlags\nval tokenMap = new PlasmaMap[ErgoId, Long](AvlTreeFlags.AllOperationsAllowed, PlasmaParameters.default)\n\nval cometId: ErgoId = ErgoId.create(\"0cd8c9f416e5b1ca9f986a7f10a84191dfb85941619e49e53c0dc30ebf83324b\")\nval tokenData: Seq[(ErgoId, Long)] = Seq(cometId -> 100L)\n\nval result: ProvenResult[Long] = tokenMap.insert(tokenData: _*)\n\nval opResults: Seq[OpResult[Long]] = result.response\nval proof: Proof = result.proof\n\n```\n\nAll of these classes have functions to convert between common types used in Ergo Appkit. This allows for easy\ninteractions between Plasma Map's and on-chain contracts.\n\n```scala\nimport io.getblok.getblok_plasma.collections.{PlasmaMap, Proof}\nimport org.ergoplatform.appkit.{ErgoClient, ErgoContract, ErgoId, Parameters}\n\nimplicit val ergoClient: ErgoClient\nimplicit val myContract: ErgoContract\nimplicit val myMap: PlasmaMap[ErgoId, Long]\nimplicit val myProof: Proof\nergoClient.execute {\n  ctx =>\n    val txB = ctx.newTxBuilder()\n    val outB = txB.outBoxBuilder()\n    val outBox = outB\n            .value(Parameters.OneErg)\n            .contract(myContract)\n            .registers(myMap.ergoValue, myProof.ergoValue)\n            .build()\n}\n```"
    },
    {
      "heading": "LocalPlasmaMap",
      "level": 2,
      "content": "Interacting with a locally stored Plasma Map is done in a similar way, except that you must use the\n`LocalPlasmaMap` class instead.\n```scala\nimport io.getblok.getblok_plasma.PlasmaParameters\nimport io.getblok.getblok_plasma.collections.LocalPlasmaMap\nimport io.getblok.getblok_plasma.ByteConversion.convertsLongKey\nimport scorex.crypto.authds.avltree.batch.VersionedLDBAVLStorage\nimport scorex.crypto.hash.{Blake2b256, Digest32}\nimport scorex.db.LDBVersionedStore\nimport sigmastate.{AvlTreeFlags, Values}\nimport java.io.File\n\nval ldbStore = new LDBVersionedStore(new File(\"./level\"), 10)\nval avlStorage = new VersionedLDBAVLStorage[Digest32](ldbStore, PlasmaParameters.default.toNodeParams)(Blake2b256)\nval localMap = new LocalPlasmaMap[Long, Values.ErgoTree](avlStorage, AvlTreeFlags.AllOperationsAllowed, PlasmaParameters.default)\n```"
    },
    {
      "heading": "ProxyPlasmaMap",
      "level": 2,
      "content": "It can be useful to apply changes to a tree without necessarily committing to them. This is especially\ntrue in the context of chained transactions or unexpected errors. For example, if changes are applied to the\ntree but latency causes connection to the node to be lost, then the locally stored tree may have changes\nthat do not exist on-chain!\n\nTo deal with this problem, you can use a `ProxyPlasmaMap`. This PlasmaMap applies changes on a temporary\ntree which allows you to receive proofs for the operations you perform. However, none of these changes\nare saved to storage until the `commitChanges()` function is called. This ensures that unexpected errors\ncan be dealt with easily.\n\nWhen dealing with the `ProxyPlasmaMap`, changes must first be explicitly enabled by calling\n`initiate()`. This function initializes the internal temporary map. Following this, operations\nmay be performed on the map. All operations are applied to the temporary map, but are also kept\ntrack of inside an internal Queue. Once `commitChanges()` is called, the Queued operations are applied\nto persistent storage, and the temporary map is destroyed.\n\n```scala\nimport io.getblok.getblok_plasma.PlasmaParameters\nimport io.getblok.getblok_plasma.collections.{LocalPlasmaMap, ProxyPlasmaMap}\nimport org.ergoplatform.appkit.ErgoId\nimport scorex.crypto.authds.avltree.batch.VersionedLDBAVLStorage\nimport scorex.crypto.hash.{Blake2b256, Digest32}\nimport scorex.db.LDBVersionedStore\nimport sigmastate.{AvlTreeFlags, Values}\nimport io.getblok.getblok_plasma.ByteConversion.convertsLongVal\nimport java.io.File\n\nval ldbStore = new LDBVersionedStore(new File(\"./level\"), 10)\nval avlStorage = new VersionedLDBAVLStorage[Digest32](ldbStore, PlasmaParameters.default.toNodeParams)(Blake2b256)\nval proxyMap = new ProxyPlasmaMap[ErgoId, Long](avlStorage, AvlTreeFlags.AllOperationsAllowed, PlasmaParameters.default)\nval ergopadId: ErgoId = ErgoId.create(\"d71693c49a84fbbecd4908c94813b46514b18b67a99952dc1e6e4791556de413\")\nval tokenDataErgoPad: Seq[(ErgoId, Long)] = Seq(ergopadId -> 100L)\n\n\n// This will fail due to the ProxyMap being un-initiated\nproxyMap.insert(tokenDataErgoPad: _*)\n\n// Initiates operations on the tree\nproxyMap.initiate()\n\n// This will be successfully applied to the internal temporary tree, while also queueing this\n// operation for later application into persistence\nproxyMap.insert(tokenDataErgoPad: _*)\n\n// This commits ALL of the changes made on the temporary tree into persistent storage, while also\n// destroying the temporary tree\nproxyMap.commitChanges()\n\nval cometId: ErgoId = ErgoId.create(\"0cd8c9f416e5b1ca9f986a7f10a84191dfb85941619e49e53c0dc30ebf83324b\")\nval tokenDataComet: Seq[(ErgoId, Long)] = Seq(cometId -> 100L)\n\nproxyMap.initiate()\nproxyMap.insert(tokenDataComet: _*)\n\n// This commits only the next operation that exists in the Queue. This does NOT destroy\n// the temporary map.\nproxyMap.commitNextOperation()\n\n// This drops any uncommitted changes and destroys the temporary map. In this case,\n// all changes were already committed since only one operation was performed.\n\nproxyMap.dropChanges()\n```"
    },
    {
      "heading": "Resources",
      "level": 2,
      "content": "- [Plasma Example: Off-chain Bank operating at Layer 2](https://www.ergoforum.org/t/offchain-bank-operating-at-layer-2/3367)\n- [GetBlok Plasma](https://github.com/GetBlok-io/GetBlok-Plasma)\n- [GetBlok: SmartPool Plasma](https://github.com/GetBlok-io/GetBlok-Plasma/blob/master/documents/SmartPool_Plasma.MD)\n- [Paideia - Plasma Staking](https://github.com/ergo-pad/paideia-contracts/blob/main/paideia_contracts/contracts/plasma_staking/ergoscript/latest/plasmaStaking.es)"
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/lib/plasma.md",
  "processed_at": "2025-05-11T19:22:09.021330",
  "ai_processed": true
}