{
  "id": "docs_dev_scs_sigma_verifying_md",
  "title": "Schnorr Signatures",
  "summary": "Schnorr Signatures is a key cryptographic primitive in Ergo, allowing for efficient, simple, and secure signatures. Ergo uses the Secp256k1 elliptic curve for its Schnorr signature scheme, which allows a user to prove knowledge of a private key without revealing the key itself. The document explains the Schnorr signing process, the Schnorr identification process, and the Schnorr signature verification process. It also provides an example of on-chain verification of a Schnorr signature in ErgoScript, demonstrating how to reconstruct the commitment U and verify the signature.",
  "qa_pairs": [
    {
      "question": "What is the Schnorr signature scheme?",
      "answer": "The Schnorr signature scheme is a key cryptographic primitive in Ergo, allowing for efficient, simple, and secure signatures."
    },
    {
      "question": "What elliptic curve does Ergo use for its Schnorr signature scheme?",
      "answer": "Ergo uses the Secp256k1 elliptic curve (the same curve used in Bitcoin), denoted as G, for its Schnorr signature scheme."
    },
    {
      "question": "How is the public key generated from the secret key in the Schnorr signature scheme?",
      "answer": "The public key is Y = g^x, where x is the secret key and g is the generator of the elliptic curve group G."
    },
    {
      "question": "What are the steps in the Schnorr signing process?",
      "answer": "1. Generate a random integer r and compute U = g^r. 2. Compute the challenge c = Hash(U || M). 3. Compute the response s = r - cx."
    },
    {
      "question": "What is the format of the Schnorr signature?",
      "answer": "The signature is the pair (c, s), which is sent to the verifier."
    }
  ],
  "sections": [
    {
      "heading": "Schnorr Signatures",
      "level": 1,
      "content": "The **Schnorr signature** scheme is a key cryptographic primitive in Ergo, allowing for efficient, simple, and secure signatures. Whether verifying a transaction or proving the ownership of a private key on-chain, Schnorr signatures play a central role. This page explains how to verify a Schnorr signature in **ErgoScript**, starting from basic signing and verification steps to advanced on-chain validation."
    },
    {
      "heading": "Overview",
      "level": 2,
      "content": "Ergo uses the **Secp256k1** elliptic curve (the same curve used in Bitcoin), denoted as **G**, for its Schnorr signature scheme. The Schnorr signature allows a user to prove knowledge of a private key without revealing the key itself."
    },
    {
      "heading": "Key Setup:",
      "level": 3,
      "content": "1. The **secret key** is an integer **x**.\n2. The corresponding **public key** is **Y = g^x**, where **g** is the generator of the elliptic curve group **G**."
    },
    {
      "heading": "Schnorr Signing Process",
      "level": 2,
      "content": "To sign a message **M** (the hash of the message), follow these steps:\n\n1. Generate a random integer **r** and compute **U = g^r**.\n2. Compute the challenge **c = Hash(U || M)**.\n3. Compute the response **s = r - cx**.\n\nThe signature is the pair **(c, s)**, which is sent to the verifier."
    },
    {
      "heading": "Schnorr Signature Verification",
      "level": 2,
      "content": ""
    },
    {
      "heading": "Schnorr Identification",
      "level": 3,
      "content": "Before diving into signature verification, it's helpful to understand the Schnorr identification process, a variant of Schnorr signatures:\n\n- Instead of sending **(c, s)**, the prover sends **(U, s)** (a group element and an integer).\n- The verifier computes **c = Hash(U || M)** and checks if:\n  \\[\n  g^s = U / Y^c\n  \\]\n  This works because:\n  \\[\n  g^s = g^{r - cx} = g^r / (g^x)^c = U / Y^c\n  \\]"
    },
    {
      "heading": "Schnorr Signature Verification",
      "level": 3,
      "content": "For Schnorr signatures, the signature **(c, s)** is verified differently. The verifier computes **U = g^s \\cdot Y^c** and checks if:\n  \\[\n  c = Hash(U || M)\n  \\]\nThis process ensures that the signature is valid and was produced by the holder of the secret key corresponding to the public key **Y**.\n\n---"
    },
    {
      "heading": "On-Chain Verification in ErgoScript",
      "level": 2,
      "content": "In ErgoScript, verifying a Schnorr signature involves reconstructing **U** on-chain and checking the challenge."
    },
    {
      "heading": "ErgoScript Example:",
      "level": 3,
      "content": "```scala\n{ \n  // Getting the generator of the elliptic curve group \n  val g: GroupElement = groupGenerator\n\n  // Getting the public key Y from R4\n  val Y = SELF.R4[GroupElement].get\n\n  // Getting the message M from R5\n  val M = SELF.R5[Coll[Byte]].get\n\n  // Retrieving the c value (challenge) from context variable 0\n  val cBytes = getVar .get\n  val c = byteArrayToBigInt(cBytes)\n\n  // Retrieving the s value (response) from context variable 1\n  val s = getVar .get\n  \n  // Calculating U = g^s * Y^c\n  val U = g.exp(s).multiply(Y.exp(c)).getEncoded // as a byte array\n  \n  // Checking if the Schnorr signature is valid\n  sigmaProp(cBytes == sha256(U ++ M))\n}\n```"
    },
    {
      "heading": "Script Explanation:",
      "level": 3,
      "content": "- The generator of the elliptic curve group (`g`) is retrieved using the global value `groupGenerator`.\n- The public key (`Y`) is retrieved from register R4 of the box being spent (`SELF`).\n- The message hash (`M`) is retrieved from register R5 of the box being spent.\n- The signature components, challenge (`cBytes`) and response (`s`), are provided as context variables by the prover during transaction creation.\n- The script reconstructs the commitment `U` using the formula `g^s * Y^c`.\n- Finally, it verifies the signature by hashing the reconstructed `U` concatenated with the message `M` (`sha256(U ++ M)`) and comparing the result with the original challenge `cBytes`. If they match, the signature is valid, and the `sigmaProp` evaluates to true."
    },
    {
      "heading": "Reference Test:",
      "level": 3,
      "content": "The complete off-chain and on-chain interaction, including signature generation and verification, can be seen in [this test case](https://github.com/ergoplatform/ergo-jde/blob/main/kiosk/src/test/scala/kiosk/schnorr/SchnorrSpec.scala).\n\n---"
    },
    {
      "heading": "Advanced Schnorr Validation Off-Chain",
      "level": 2,
      "content": ""
    },
    {
      "heading": "Alternative On-Chain Verification (Using Identification Scheme Logic):",
      "level": 3,
      "content": "While the above method directly verifies the Schnorr signature `(c, s)`, an alternative approach based on the Schnorr *identification* scheme logic can sometimes be simpler, though it requires providing `U` (or `a` in the code below) instead of `c` as part of the proof.\n\n*Note: The primary challenge with on-chain verification is that ErgoScript's `BigInt` is limited to 256 bits. Off-chain signature generation must ensure the response `s` (or `z` below) fits within this limit.*\n\n```scala\n{\n    val message = ...\n    // Compute challenge\n    val e: Coll[Byte] = blake2b256(message)\n    val eInt = byteArrayToBigInt(e) // Challenge as big integer\n          \n    // Retrieve a of signature (a, z)\n    val a = getVar .get\n    val aBytes = a.getEncoded\n\n    // Retrieve z of signature (a, z)\n    val zBytes = getVar .get\n    val z = byteArrayToBigInt(zBytes)\n\n    // Verify signature by checking if g^z = a * Y^e\n    val properSignature = g.exp(z) == a.multiply(holder.exp(eInt))\n    \n    sigmaProp(properSignature)\n}\n```"
    },
    {
      "heading": "Off-Chain Signature Generation (Ensuring Size Limit):",
      "level": 3,
      "content": "To ensure the response **z** fits within 255 bits (required for ErgoScript's `BigInt`), the off-chain signing code might need to iterate until a suitable random nonce `r` is found:\n\n```scala\n  def randBigInt: BigInt = {\n    val random = new SecureRandom()\n    val values = new Array \n    random.nextBytes(values)\n    BigInt(values).mod(SecP256K1.q)\n  }\n\n  @tailrec // Scala annotation for tail recursion optimization\n  def sign(msg: Array[Byte], secretKey: BigInt): (GroupElement, BigInt) = {\n    val r = randBigInt // Generate random nonce\n    val g: GroupElement = CryptoConstants.dlogGroup.generator\n    val a: GroupElement = g.exp(r.bigInteger) // Calculate U = g^r\n    // Calculate challenge e = H(a || msg) - using Blake2b256 here\n    val e = BigInt(scorex.crypto.hash.Blake2b256(a.getEncoded ++ msg)) \n    // Calculate response z = r + x*e (mod q) - Note: Schnorr formula is typically r - x*e or r + x*e depending on convention\n    val z = (r + secretKey * e) % CryptoConstants.groupOrder \n\n    // Check if z fits within 255 bits for ErgoScript compatibility\n    if(z.bigInteger.bitLength <= 255) { \n      (a, z) // Return signature (a, z)\n    } else {\n      sign(msg, secretKey) // Retry with a new random nonce r\n    }\n  }\n```\n\nFor further examples of constructing off-chain transactions and verifying them on-chain, refer to the [ChainCash repository](https://github.com/kushti/chaincash/blob/master/src/test/scala/kiosk/ChainCashSpec.scala).\n\n---"
    },
    {
      "heading": "Considerations and Limitations",
      "level": 2,
      "content": "- **Weak Fiat-Shamir Transformation**: The standard Schnorr signature verification shown (`c = H(U || M)`) uses a basic form of the Fiat-Shamir transformation. This is generally secure when the public key `Y` is fixed and known. However, be aware of potential security implications in more complex protocols where public keys might be dynamic or interact in unexpected ways. Stronger transformations might be needed in such advanced scenarios.\n  \n---"
    },
    {
      "heading": "Conclusion",
      "level": 2,
      "content": "Schnorr signatures in Ergo provide a powerful, efficient, and flexible way to handle cryptographic authentication both on-chain and off-chain. Whether it's a simple transaction signature or a complex proof involving multi-signatures or privacy-preserving mechanisms, ErgoScript\u2019s built-in support for Schnorr signatures makes it easy to implement.\n\nFor more details, explore:\n\n- The [SchnorrSpec test case](https://github.com/ergoplatform/ergo-jde/blob/main/kiosk/src/test/scala/kiosk/schnorr/SchnorrSpec.scala), which demonstrates both on-chain verification of Schnorr signatures and off-chain signature generation in ErgoScript.\n- The [ChainCash repository](https://github.com/kushti/chaincash/blob/master/src/test/scala/kiosk/ChainCashSpec.scala) for further examples of Schnorr-based signature transactions and how to integrate them in more complex use cases.\n\nBy understanding and leveraging Schnorr signatures in Ergo, you can implement secure, efficient, and scalable cryptographic proofs for a variety of applications, ranging from simple transactions to privacy-preserving protocols like atomic swaps, ring signatures, and threshold signatures.\n\n---"
    },
    {
      "heading": "Resources",
      "level": 2,
      "content": "1. **Schnorr Signature Paper**: [MuSig: A New Multi-Signature Standard](https://eprint.iacr.org/2018/068) \u2013 A foundational paper on Schnorr multi-signatures.\n2. **Adaptor Signatures**: [Adaptor Signatures for Cross-Chain Protocols](https://eprint.iacr.org/2018/123.pdf) \u2013 A deep dive into the use of Schnorr signatures for atomic swaps and privacy-preserving transactions.\n3. **Elliptic Curve Cryptography**: [SecP256K1 Curve Information](https://en.bitcoin.it/wiki/Secp256k1) \u2013 Detailed information on the elliptic curve used in both Bitcoin and Ergo.\n4. **SigmaBoolean Documentation**: [SigmaBoolean in Ergo](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/docs/sigma-dsl.md) \u2013 Documentation on how to use SigmaBoolean and generalized Schnorr proofs in Ergo smart contracts."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/scs/sigma/verifying.md",
  "processed_at": "2025-05-11T19:31:29.663732",
  "ai_processed": true
}