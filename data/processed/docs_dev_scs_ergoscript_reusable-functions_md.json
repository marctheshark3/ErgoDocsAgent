{
  "id": "docs_dev_scs_ergoscript_reusable-functions_md",
  "title": "reusable-functions.md",
  "summary": "This document provides a collection of reusable functions and debugging techniques for working with the Ergo platform. It covers topics such as:\n\n- Checking dependency versions and updating the Nautilus wallet to resolve issues\n- Techniques for debugging on-chain boxes, including modifying contract conditions and replacing ErgoTree\n- Guidance on mocking boxes in unit tests\n- Explanations for common questions related to EIP-3 secrets, converting proposition bytes, handling duplicate tokens, fixing signing errors, and learning ErgoScript as a beginner\n- Details on how dApp fees are handled in ErgoScript contracts\n- Examples of using Option types and collection operations like fold, map, and reduce in ErgoScript",
  "qa_pairs": [
    {
      "question": "What is the recommended approach for mocking boxes in unit tests?",
      "answer": "For mocking boxes in unit tests, use the `mockUTxO` function from `@fleet-sdk/mock-chain` instead of manually editing box contents."
    },
    {
      "question": "How can you convert a Coll[Byte] of proposition bytes to the SigmaProp type?",
      "answer": "The `decodePoint` method is likely what you need to convert proposition bytes (`Coll[Byte]`) into a `SigmaProp`."
    },
    {
      "question": "Can you insert two tokens with the same ID but different amounts into a box?",
      "answer": "Yes, you can, but be aware that some off-chain code might become confused. The amounts will be merged into a single entry in the box's tokens array."
    },
    {
      "question": "What is the recommended approach for debugging issues with on-chain boxes?",
      "answer": "When encountering issues with on-chain boxes, you can try the following: 1. Make temporary contract edits, 2. Compile the modified contract and obtain the new ErgoTree hex, 3. Replace the ErgoTree of the problematic box with the new hex (off-chain), 4. Attempt to sign the transaction (this should work locally even if the modified tree wouldn't validate on-chain, helping isolate signing issues)."
    },
    {
      "question": "How is the EIP-3 Secret similar to an account index for derived public keys?",
      "answer": "Yes, the EIP-3 secret functions similarly to an account index for deriving public keys. As confirmed by user 'Aberg (Satergo dev)', the Satergo wallet refers to this as the \"address index,\" and custom indices can be utilized."
    }
  ],
  "sections": [
    {
      "heading": "Debugging Techniques",
      "level": 2,
      "content": "- Check the versions of dependencies like `ergo-lib-wasm-nodejs` and `ergo-lib-wasm-browser` to ensure you have the latest fixes.\n- If an issue is suspected to originate from the Nautilus wallet, try manually replacing the `.wasm` file in the extension directory with an updated version from `sigma-rust`.\n- Building Nautilus from source with updated dependencies can help identify issues.\n- When encountering issues with on-chain boxes, you can try the following:\n  1. Make temporary contract edits (e.g., set a condition to always evaluate to `true`).\n  2. Compile the modified contract and obtain the new ErgoTree hex.\n  3. Replace the ErgoTree of the problematic box with the new hex (off-chain).\n  4. Attempt to sign the transaction (this should work locally even if the modified tree wouldn't validate on-chain, helping isolate signing issues).\n- For mocking boxes in unit tests, use the `mockUTxO` function from `@fleet-sdk/mock-chain` instead of manually editing box contents."
    },
    {
      "heading": "FAQs",
      "level": 2,
      "content": ""
    },
    {
      "heading": "Is the EIP-3 Secret similar to an account index for derived public keys?",
      "level": 3,
      "content": "Yes, the EIP-3 secret functions similarly to an account index for deriving public keys. As confirmed by user 'Aberg (Satergo dev)', the Satergo wallet refers to this as the \"address index,\" and custom indices can be utilized."
    },
    {
      "heading": "How do I convert a Coll[Byte] of proposition bytes to the SigmaProp type?",
      "level": 3,
      "content": "The `decodePoint` method is likely what you need to convert proposition bytes (`Coll[Byte]`) into a `SigmaProp`."
    },
    {
      "heading": "Can I insert two tokens with the same ID but different amounts into a box?",
      "level": 3,
      "content": "Yes, you can, but be aware that some off-chain code might become confused. The amounts will be merged into a single entry in the box's tokens array."
    },
    {
      "heading": "How do I fix the \"Tree root should be real but was UnprovenSchnorr(ProveDlog(Ecp(...\" error?",
      "level": 3,
      "content": "This error usually indicates that the transaction was signed using an incorrect private key (i.e., one that doesn't correspond to the public key expected by the script)."
    },
    {
      "heading": "As a complete coding beginner, should I learn Java then Scala before ErgoScript?",
      "level": 3,
      "content": "It's generally recommended to focus on understanding UTXO model concepts first, rather than diving deep into Java or Scala initially. The courses available at https://docs.ergoplatform.com/dev/get-started/ provide a good starting point without requiring prior Java or Scala knowledge."
    },
    {
      "heading": "How are dApp fees handled in ErgoScript contracts?",
      "level": 3,
      "content": "In ErgoScript, fees are handled explicitly during the transaction building process, not directly within the script logic itself. The script verifies conditions based on the transaction outputs. See the Token Sale Service contract example for illustration: \nhttps://github.com/ergoplatform/ergoscript-by-example/blob/main/tokenSalesService.md\n\nKey aspects:  \n\n- The transaction fee (`MinTxFee`) must be included in one of the output boxes (typically the last one, designated for the miner).\n- Other output boxes handle the distribution of payment and token amounts according to the contract's logic.\n- The fee is paid from the value contained within the input boxes being spent."
    },
    {
      "heading": "How can Option/Some(...) be used in ErgoScript outside of registers and context variables?",
      "level": 3,
      "content": "The use of `Option` types (like `Some(...)`) is effectively limited to values originating from registers (`box.R<N>[Type]`) and context variables (`getVar[T](...)`). A potential workaround for other scenarios involves using a \"dummy\" optional register value and applying a map operation: `box.R4[Boolean].map(r => <some expression which doesn't depend on r>)`."
    },
    {
      "heading": "What's the proper syntax for fold/map/reduce operations in ErgoScript?",
      "level": 3,
      "content": "Here are some examples demonstrating common collection operations:\n```scala\n// Simple sum using fold with an explicitly defined function\ndef sumFunc(a: Long, b: Box): Long = a + b.value\nval totalValue = INPUTS.fold(0L, sumFunc)\n\n// Using fold with an inline lambda function\nval totalValueLambda = INPUTS.fold(0L, { (accum: Long, box: Box) => accum + box.value })\n\n// Declaring a generic function (though type parameter often inferred)\n// def sumGeneric[T](a: T, b: Box): T = ??? // Example structure\n// val totalGeneric = INPUTS.fold(0L, sumGeneric) // Type parameter usually not needed here\n\n// Note: Upcoming Sigma 6.0 might introduce more direct methods like:\n// val total = INPUTS.sumBy(b => b.value) \n```"
    },
    {
      "heading": "How can I store a script hash in a register using Fleet for later comparison?",
      "level": 3,
      "content": "To store the bytes of a script (ErgoTree) in a register, allowing an ErgoScript contract to later verify that an output box is protected by that specific script:\n```js\n// In your off-chain Fleet code (JavaScript/TypeScript):\n// Create an output box and set register R8 to the hex representation \n// of the target script's ErgoTree bytes.\nnew OutputBuilder(SAFE_MIN_BOX_VALUE, /* Some Address */)  \n  // ... other builder methods\n  .setAdditionalRegisters({\n    R8: SConstant(SColl(SByte, ErgoAddress.fromBase58(TARGET_SCRIPT_ADDRESS).ergoTree)).toHex() \n  });\n```\n\n```scala\n// In your ErgoScript contract:\n{\n  // Retrieve the expected script bytes from the register\n  val expectedScriptBytes = SELF.R8[Coll[Byte]].get \n  \n  // Get the actual script bytes of an output box\n  val outputBoxScriptBytes = OUTPUTS(0).propositionBytes \n\n  // Verify that the output box uses the expected script\n  expectedScriptBytes == outputBoxScriptBytes\n  // ... other conditions\n}\n```"
    },
    {
      "heading": "Noted Issues",
      "level": 2,
      "content": "- A bug existed in `sigma-rust` where `coll.slice` did not gracefully handle empty collections, differing from the Scala version used in nodes. This caused issues for approximately 3 weeks until fixed by user 'greenhat'. The fix has been merged into the `develop` branch of `sigma-rust`.\n- This fix needs to propagate through the dependency tree (including updates to libraries like `ergo-lib-wasm` and wallets like Nautilus) before fully resolving issues for all end users.\n- Some unexpected exceptions have been reported when using `.toBigInt` on `Long` register values in ErgoScript. Further investigation is needed.\n- With ErgoNames, if a token representing a registered name is burned, that name registration is permanently lost. Potential solutions are being researched."
    },
    {
      "heading": "Tutorial Code Snippets",
      "level": 2,
      "content": "**Summing nanoErgs of all inputs:**\n```scala \n// Define a function to add a box's value to an accumulator\ndef sumValues(accum: Long, box: Box): Long = accum + box.value\n// Use fold to apply the sum function across all INPUTS, starting with 0L\nval totalNanoErgs = INPUTS.fold(0L, sumValues) \n```\n\n**Storing a script hash in a register using Fleet:**\n```js\n// Off-chain code to create an output box storing the target script's hash in R8\nconst targetAddress = \"TARGET_SCRIPT_ADDRESS\"; // Replace with the actual address\nconst targetErgoTreeBytes = ErgoAddress.fromBase58(targetAddress).ergoTree;\n\nnew OutputBuilder(SAFE_MIN_BOX_VALUE, /* Some Address */)\n  .setAdditionalRegisters({ \n    R8: SConstant(SColl(SByte, targetErgoTreeBytes)).toHex() \n  });\n```"
    },
    {
      "heading": "Additional Resources",
      "level": 2,
      "content": "- ErgoScript Language Specification: https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/docs/LangSpec.md\n- Ergo Playground/eScript IDE: https://escript.online/"
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/scs/ergoscript/reusable-functions.md",
  "processed_at": "2025-05-11T19:28:51.198746",
  "ai_processed": true
}