{
  "id": "docs_dev_stack_assembler_md",
  "title": "Assembler",
  "summary": "The document discusses a proposed off-chain transaction assembler service for Ergo dApps. The service aims to bypass the node requirements for dApps by allowing users to deposit their assets to a specified address, and the service will then assemble the necessary transactions on behalf of the dApp. The document outlines the problem, a proposed solution, trust issues, and potential service provider incentives. It also mentions a related tool called \"Tx Builder\" that can be used to create transactions for Ergo application protocols. The document provides an example script for creating a timestamp using the proposed service.",
  "qa_pairs": [
    {
      "question": "What is the main problem that the transaction assembler service aims to address?",
      "answer": "The main problem is that current wallets don't support some key features needed by dApps, such as specifying input boxes, p2s protected boxes in inputs, specifying output registers, and supporting dApp requests. This prevents users from using their assets to participate in dApps."
    },
    {
      "question": "How does the transaction assembler service work to bypass the node requirements for dApps?",
      "answer": "The off-chain service allows dApps to register requests by providing an address (which the user will deposit assets to) and other specifications. The service then assembles the transaction for the dApp, without the user needing to run their own node."
    },
    {
      "question": "What are the potential solutions for addressing the trust issues between dApps, users, and the transaction assembler service?",
      "answer": "The potential solutions include: 1) the service being open-sourced and provided by a trusted party, 2) dApps running the service for themselves, and 3) using well-designed p2s addresses to prevent the service from stealing the user's assets."
    },
    {
      "question": "What are the potential incentives for the transaction assembler service provider?",
      "answer": "The service provider can offer free transaction assembly for a limited time, and then charge dApps to continue following the request if the conditions are not met. This can provide a revenue model for the service provider."
    },
    {
      "question": "How can the transaction assembler service benefit users even after wallets provide APIs for dApps?",
      "answer": "Even after some wallets provide APIs for dApps, users can still benefit from the transaction assembler service by using any wallet they wish, without being limited to the features and support provided by the wallet."
    }
  ],
  "sections": [
    {
      "heading": "Assembler",
      "level": 1,
      "content": "> More likely you'll want to use [dApp-dev](dApp.md)\n\nThe transaction assembler service allows you to bypass the node requirements for dApps."
    },
    {
      "heading": "The Problem",
      "level": 3,
      "content": "Currently, with libraries like ergo-appkit, ergo-lib (aka sigma-rust), and ergo-ts, development on Ergo has become a lot more convenient and is becoming easier with further developments of ergo-lib.\nHowever, there are some big barriers for dApps to be extensively used by ordinary users. One of the main ones is that users can't use their assets to participate in dApps because current wallets don't support some key features needed by dApps like:  \n\n- specifying input boxes\n- p2s protected boxes in inputs\n- specifying output registers\n- and simply not supporting dApp requests\n\nThese issues will be resolved in the future for sure with wallets like Yoroi, but not so soon, maybe!\nIn this situation, dApps have no workarounds other than requiring users to have their node running or implement a kind of a wallet themselves and ask users to trust and deposit there! The former is the case with Ergo Auction House which prevents it from being extensively used by everyone!\n\nSpecifically, the problem that this topic is going to address is to bypass the node requirements by having an off-chain service to assemble arbitrary transactions for dApps."
    },
    {
      "heading": "A Solution",
      "level": 3,
      "content": "The off-chain service will allow dApps to register some requests by providing an address (which the user will deposit her assets) and some other specifications.\nThis topic is just for getting feedback, and I still haven't designed the APIs to provide concrete examples, however:\n\n```json\n{\n  \"address\":\"address which user deposits to\", // p2s address explained in Trusting Issues section\n  \"returnTo\":\"address to return assets to in case of failure\",\n  \"startWhen\":{ // start assembling when all needed assets are deposited maybe with multiple transactions\n    \"erg\":1002000000,\n    \"d01bdce3959ff6b675f7ab40ec2479ca5ce1edf3ae6314631f09c0f9807752aa\":71\n  },\n  \"txSpec\":{\n    \"requests\":[\n      {\n        \"address\":\"MFrQp7bsMkG9u1AQT33hn5ydUAcrqNMxhocS1RvvJqmUcHaiyXcCE3Sg7DbphepEXHXPkhEBzC6Kqw7jzQDzd4a9SX9M96b4NV8vTVp1zJGepnX41yuLzdWPzbB3k1XRTCUe7An26NDozTD3L5brAu5Nu5Pxkk28kNiFMtfG76n4yfF5YB1wbzXrfoaM9qVTFKhjLTRpJ1pwFZgzPnDC3LXEDyk4EPRjqnRe4WSnMhqa6ngfdGG79J4ZphMuDtamsJY7RD1PoWwxvidk9by7iQrQ3v9EGn1QkrtpxFN9Di7nsyKzUzQS6vxhpdcGXTRBhghaZPMnqRyzdhtspJxiYewSB14Q2cF1uR7vz3m6cqLuS7Fw8jKMpfsY9wXLRaHqUnzfJtEf7LTJfGHtCxifo2iuiHowkLWtwgZDNjH5UAiwAXubSuCzFVSZaDDyxdA5mqBSSRbSC8LoZvQwPcfFLvjjnx2nNznokdG6vA7LU8BbmXrnVXR\",\n        \"value\":1000000000,\n        \"assets\":[\n          {\n            \"tokenId\":\"d01bdce3959ff6b675f7ab40ec2479ca5ce1edf3ae6314631f09c0f9807752aa\",\n            \"amount\":71\n          }\n        ],\n        \"registers\":{\n          \"R4\":\"0e240008cd02d84d2e1ca735ce23f224bd43cd43ed67053356713a8a6920965b3bde933648dc\",\n          \"R5\":\"04bacf2a\",\n          \"R6\":\"0580a8d6b907\",\n          \"R7\":\"0e0131\",\n          \"R8\":\"0e240008cd02d84d2e1ca735ce23f224bd43cd43ed67053356713a8a6920965b3bde933648dc\",\n          \"R9\":\"0e1c313030303030303030302c313030303030303030302c333439313433\"\n        }\n      }\n    ],\n    \"inputs\":[\n      \"$userIns\",\n      \"boxId1\",\n      \"boxId2\",\n      \"...\"\n    ],\n    \"dataInputs\":[\n      \"boxId1\",\n      \"...\"\n    ],\n    \"fee\":2000000\n  }\n}\n```\nThe above is a potential request that Ergo Auction House can register to the service, which will start a new auction! So the Ergo Auction House app will ask the user to deposit the required assets to the _address_ (will discuss what this _address_ is in the next sections) using their favourite wallet and registers the request to the service.\n\nAfter such a request, the service will follow the _address_ and, when the conditions are met, assembles the transaction and makes sure it will be mined. In case of failures, assets will be returned to the user; for example, if the transaction is for placing a bid and someone else places a bid before us!\n\nNote that all input and data input boxes are in ids, and no input raw will be required, which makes it safe for dApps to avoid running nodes for themselves or using random nodes in the network to get raw inputs.\n\nAlso, note that the above approach doesn't solve the problem of finding necessary boxes (e.g. in case of placing a bid, the auction box) for dApps, and it isn't the aim of this topic as well!\n\nFurthermore, the _txSpec_ is pretty raw, can be improved so that the service encodes the register to make it easier for dApps, but with the mentioned libraries around, I don't see it as a problem for dApps to encode registers themselves.\n\nWith some improvements on the node's side, the service can be very fast and effective by using chained transactions to avoid wasting time for the deposits to be mined! So basically, it will be like the user is running a node and is generating the transaction directly without intermediate operations.\n\n\nLast but not least, the service will, of course, provide some other APIs for dApps to see the result of their registered requests."
    },
    {
      "heading": "Trusting Issues",
      "level": 3,
      "content": "How dApps and users should trust such a service is still a big problem. Several solutions:  \n\n- With the service being open-sourced and maybe being provided by a trusted party\n- dApps can run the service for themselves, resolving the trust issue for at least themselves\n- Using well-designed p2s addresses to prevent the service from stealing\n\nAlthough one can argue that the first two options can work under some circumstances, the last option is the one which I think is applicable for most use-cases and doesn't require trust!\nFor example, the Ergo Auction House can use p2s addresses, which will allow the assets to be spent only for placing a specific bid, and the user's address is specified as auction's bidder in the auction box and register; it to the service!"
    },
    {
      "heading": "Service Provider Incentives",
      "level": 3,
      "content": "Although there are no plans to make profits out of the service, one can have multiple options and plans to make some profits with the service. For example, the service can follow the registered request for some minutes for free, and after that remove the request if the conditions are not met to assemble the transaction, then dApps can pay the service to follow the request longer!\n\nUntil the dApp bridge in wallets is built, I think such a service will help a lot for the growth of dApps. Even after some wallets provide APIs for dApps, users still can benefit from such a service by using any wallet they wish!\nPlease let me know if something is overlooked."
    },
    {
      "heading": "Motivation",
      "level": 3,
      "content": "Currently, to craft a transaction, we need to use Kiosk, sigma-rust, Appkit or some other tool, which makes the entry barrier quite high. \nMotivated from @anon_real's Tx Assembler and other proposals, I had been working on a tool to automate tx building for the off-chain components of an Ergo dApp.\n\nThe tool called simply \"Tx Builder\" can be used to create transactions for participating in several Ergo application protocols. The goal of Tx Builder is to allow people with just knowledge of Json to craft a transaction following certain rules."
    },
    {
      "heading": "Documentation",
      "level": 3,
      "content": "There is a very short introduction [here](https://github.com/scalahub/Kiosk/blob/master/src/main/scala/kiosk/offchain/readme.md). \nFor further details, please refer to the source code [here](https://github.com/scalahub/Kiosk/tree/master/src/main/scala/kiosk/offchain) and the examples [here](https://github.com/scalahub/Kiosk/tree/master/src/test/scala/kiosk/offchain).\n\nMore details will follow soon."
    },
    {
      "heading": "Example Script",
      "level": 3,
      "content": "As an example, the [following Json](https://github.com/scalahub/Kiosk/blob/master/src/test/scala/kiosk/offchain/timestamp.json) can be used for creating a timestamp using the service described [here](https://www.ergoforum.org/t/a-trustless-timestamping-service-for-boxes/432/9)\n\n    \n```JSON\n{\n  \"constants\": [\n    {\n      \"name\": \"myBoxId\",\n      \"type\": \"CollByte\",\n      \"value\": \"ae57e4add0f181f5d1e8fd462969e4cc04f13b0da183676660d280ad0b64563f\"\n    },\n    {\n      \"name\": \"emissionAddress\",\n      \"type\": \"Address\",\n      \"value\": \"2z93aPPTpVrZJHkQN54V7PatEfg3Ac1zKesFxUz8TGGZwPT4Rr5q6tBwsjEjounQU4KNZVqbFAUsCNipEKZmMdx2WTqFEyUURcZCW2CrSqKJ8YNtSVDGm7eHcrbPki9VRsyGpnpEQvirpz6GKZgghcTRDwyp1XtuXoG7XWPC4bT1U53LhiM3exE2iUDgDkme2e5hx9dMyBUi9TSNLNY1oPy2MjJ5seYmGuXCTRPLqrsi\"\n    },\n    {\n      \"name\": \"timestampAddress\",\n      \"type\": \"Address\",\n      \"value\": \"4MQyMKvMbnCJG3aJ\"\n    },\n    {\n      \"name\": \"myTokenId\",\n      \"type\": \"CollByte\",\n      \"value\": \"dbea46d988e86b1e60181b69936a3b927c3a4871aa6ed5258d3e4df155750bea\"\n    },\n    {\n      \"name\": \"minTokenAmount\",\n      \"type\": \"Long\",\n      \"value\": \"2\"\n    },\n    {\n      \"name\": \"one\",\n      \"type\": \"Long\",\n      \"value\": \"1\"\n    },\n    {\n      \"name\": \"minStorageRent\",\n      \"type\": \"Long\",\n      \"value\": \"2000000\"\n    }\n  ],\n  \"dataInputs\": [\n    {\n      \"id\": {\n        \"value\": \"myBoxId\"\n      }\n    }\n  ],\n  \"inputs\": [\n    {\n      \"address\": {\n        \"value\": \"emissionAddress\"\n      },\n      \"tokens\": [\n        {\n          \"index\": 0,\n          \"id\": {\n            \"value\": \"myTokenId\"\n          },\n          \"amount\": {\n            \"name\": \"inputTokenAmount\",\n            \"value\": \"minTokenAmount\",\n            \"filter\": \"Ge\"\n          }\n        }\n      ],\n      \"nanoErgs\": {\n        \"name\": \"inputNanoErgs\"\n      }\n    }\n  ],\n  \"outputs\": [\n    {\n      \"address\": {\n        \"value\": \"emissionAddress\"\n      },\n      \"tokens\": [\n        {\n          \"index\": 0,\n          \"id\": {\n            \"value\": \"myTokenId\"\n          },\n          \"amount\": {\n            \"value\": \"balanceTokenAmount\"\n          }\n        }\n      ],\n      \"nanoErgs\": {\n        \"value\": \"inputNanoErgs\"\n      }\n    },\n    {\n      \"address\": {\n        \"value\": \"timestampAddress\"\n      },\n      \"registers\": [\n        {\n          \"value\": \"myBoxId\",\n          \"num\": \"R4\",\n          \"type\": \"CollByte\"\n        },\n        {\n          \"value\": \"HEIGHT\",\n          \"num\": \"R5\",\n          \"type\": \"Int\"\n        }\n      ],\n      \"tokens\": [\n        {\n          \"index\": 0,\n          \"id\": {\n            \"value\": \"myTokenId\"\n          },\n          \"amount\": {\n            \"value\": \"one\"\n          }\n        }\n      ],\n      \"nanoErgs\": {\n        \"value\": \"minStorageRent\"\n      }\n    }\n  ],\n  \"binaryOps\": [\n    {\n      \"name\": \"balanceTokenAmount\",\n      \"first\": \"inputTokenAmount\",\n      \"op\": \"Sub\",\n      \"second\": \"one\"\n    }\n  ]\n}\n```"
    },
    {
      "heading": "Using with KioskWallet",
      "level": 3,
      "content": "The above script was used to automatically generate [this transaction](https://explorer.ergoplatform.com/en/transactions/da441606b7933de8e87bbd439b4fbe1888c1403f58682c5bcddcbc488ee99773) using [KioskWallet](https://kioskweb.org/session/#kiosk.Wallet)."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/stack/assembler.md",
  "processed_at": "2025-05-11T19:33:27.011885",
  "ai_processed": true
}