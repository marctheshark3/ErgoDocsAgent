{
  "id": "docs_uses_ergo-ico_md",
  "title": "Initial Coin Offerings",
  "summary": "The document describes an implementation of an Initial Coin Offering (ICO) using the Ergo blockchain platform. It covers the key stages of the ICO process, including the funding stage, token issuance stage, and withdrawal stage. The article discusses how Ergo's UTXO-based model differs from account-based models like Ethereum, and how Ergo's scripting capabilities can be used to implement complex ICO contracts. The document provides detailed explanations and ErgoScript code for the different stages of the ICO contract.",
  "qa_pairs": [
    {
      "question": "What are the two main approaches to specifying what a spending transaction spends in a cryptocurrency protocol?",
      "answer": "The two main approaches are: the UTXO-based model, as in Bitcoin, where a transaction spends one-time asset containers (called 'coins' or UTXOs); and the account-based model, as in Nxt, Ethereum or Waves, where a transaction transfers some amount of asset from an existing long-living account to another, possibly new, long-living account."
    },
    {
      "question": "How does Ergo's UTXO-based approach differ from Bitcoin's in terms of creating an ICO?",
      "answer": "In contrast to Bitcoin's UTXO-based model, Ergo brings a spending transaction into the execution context of a script, making it possible to express dependencies between transaction outputs and inputs, and enabling the execution of arbitrarily complex Turing-complete programs on top of the blockchain."
    },
    {
      "question": "What are the main stages of the ICO contract described in the article?",
      "answer": "The main stages are: 1) the funding epoch, where investors can put Ergs into the project's box, and their withdrawal scripts and input values are added to a dictionary; 2) the funding period ends, and the dictionary becomes read-only; 3) the withdraw phase, where investors can withdraw ICO tokens based on the amount they had invested during the funding period."
    },
    {
      "question": "How does the funding stage of the ICO contract work?",
      "answer": "In the funding stage, the project creates a box committing to an empty dictionary, and the spending transaction must add the investor's withdrawal script hash and monetary value to the dictionary. The spending transaction must also pay a fee, and the contract checks that the fee is within a certain limit."
    },
    {
      "question": "What is the purpose of the investor's withdrawal script hash stored in the dictionary during the funding stage?",
      "answer": "The investor's withdrawal script hash stored in the dictionary during the funding stage will be used later in the withdraw phase, where investors can withdraw ICO tokens based on the amount they had invested during the funding period."
    }
  ],
  "sections": [
    {
      "heading": "Initial Coin Offerings",
      "level": 1,
      "content": "This article describes a fully-featured ICO (Initial Coin Offering) implemented in ErgoScript. The example covers several important and novel features of Ergo and shows how it can support complex contracts with a tiny amount of code."
    },
    {
      "heading": "Part 1. Preliminaries",
      "level": 2,
      "content": "An important design decision in a cryptocurrency protocol is specifying what a spending transaction actually spends. There are two possibilities here. The first a UTXO-based model, as in Bitcoin, where a transaction spends one-time asset containers (called as 'coins' or UTXOs in Bitcoin) and creates new ones. The other is an account-based model, as in Nxt, Ethereum or Waves, where a transaction transfers some amount of asset from an existing long-living account to another, possibly new, long-living account, with possible side-effects on the way, such as contract execution in Waves or Ethereum. In this regard, Ergo is similar to Bitcoin, because it uses the UTXO-based approach, where one-time containers called boxes are being spent. Interestingly, an Ergo transaction can also have data-inputs which are not being spent, but rather used to provide some information from the current set of unspent boxes.\n\nIt is not trivial to create an ICO on top of an UTXO based model, because, in contrast to account-based models, there is no explicit persistent storage here. However, Ergo brings a spending transaction into the execution context of a script. \nWith this small change it becomes possible to express dependencies between transaction outputs and inputs. In turn, by setting dependencies we can execute even arbitrarily complex Turing-complete programs on top of blockchain (see the [\"Self-reproducing Coins as Universal Turing Machine\" paper](https://link.springer.com/chapter/10.1007/978-3-030-00305-0_4)). In this article we will define a concrete scenario of a multi-stage contract using an ICO, where we have three stages (funding, token issuance, withdrawal).\n\nNow imagine an ICO for thousands of participants. Unlike Ethereum, Ergo does not provide possibility to store large sets of data and carry them over throughout contract execution. Rather, it allows to store only about 40-bytes header of a data \nstructure, represented as key -> value dictionary, authenticated similarly to Merkle tree. To access some elements \nin the dictionary, or to modify it, a spending transaction which is triggering protecting script execution should \nprovide lookup or modification proofs. This gives possibility for a contract to authenticate potentially huge datasets without requiring much memory to store contract state. However, storing space in the state (of active contracts) would mean bigger transactions, but this problem is easier from scalability point of view, and scalability is a top priority for Ergo."
    },
    {
      "heading": "Part 2. The ICO Contract",
      "level": 2,
      "content": "There could be many possible scenarios associated with an Initial Coin Offering (ICO). In this article we consider an ICO that wants to collect at least a certain amount of funds (in Ergs) to start the project. Once the funding threshold is crossed and funding period ends, the project is kickstarted and ICO tokens are issued by the project based on the total funding collected. In the withdraw phase, which extends forever, the investors withdraw ICO tokens based on the amount they had invested during the funding period. The contract steps are briefly described below with details provided further:\n\n* First, *funding epoch* takes place. It starts with a project's box authenticating an empty dictionary. The dictionary is intended for holding (investor, balance) pairs, where investor is a script protecting the box containing withdrawn tokens. For the balance, we assume that 1 token is equal to 1 Ergo during the ICO. During the funding epoch, it is only possible to put Ergs into the project's box.\nA funding transaction spends the project's box and creates a new project box with updated information. For that, a spending transaction for the project's box also has other inputs which hold investor withdrawing scripts. Investor scripts and input values should be added to the tree of the new box. There could be many chained funding transactions.  \n* Second, the funding period finishes, after which the tree holding the investors data becomes read-only. An authenticated tree could have different modification operations allowed individually: inserts, deletes, updates, or all the operations could be disallowed (so the tree could be in the read-only mode). Also, this transaction creates tokens of the ICO project which will be withdrawn in the next stage. The project can withdraw Ergs at this stage.  \n* Third, investors withdraw their ICO tokens. For that, a spending transaction creates outputs with guarding conditions and token values taken from the tree. The withdrawn pairs are also cleared from the tree. There could be many chained spending transactions.\n\nThese three stages should be linked together in the logical order. A seqience of boxes are used to achieve these goals,"
    },
    {
      "heading": "Part 3. The ICO Contract Details",
      "level": 2,
      "content": "Now it is the time to provide details and ErgoScript code of the ICO contract stages."
    },
    {
      "heading": "The Funding Stage",
      "level": 3,
      "content": "In the funding stage, which comes first, we assume that initially a project creates a box committing to an empty dictionary (stored in the register R5) with some guarding script described below. This stage lasts at least till height 2,000. More concretely, the first transaction with height of 2,000 or more should change the output box's script as described in the next section (transactions at lower heights must output a box with the same script).\n\nThe project's box checks that it is always first input and output of a transaction. The other inputs are considered investors' inputs. An investor's input contains the hash of a script in register R4. This hash represents the _withdraw script_ that will be used later on in the withdraw phase. The hashes as well as the monetary values of all investing inputs should be added to the dictionary. The \nspending transaction provides a proof that investor data are indeed added to the dictionary, and the proof is checked in the contract. \n\nIt is not checked in the funding sub-contract that the dictionary allows only insertions, and not updating existing values or removals (it is not hard to add an explicit check though). \n\nThe spending transaction should pay a fee, otherwise, it is unlikely that it would be included in a block. Thus, the funding contract checks that the spending transaction has two outputs (one for itself, another to pay fee), the fee is to be no more than a certain limit (just one nanoErg in our example), and the guarding proposition should e such that only a miner can spend the output (we use just a variable \"feeProp\" from compilation environment in our example without providing any details). This \"feeProp\" corresponds to a standard, though not required by protocol. \n\nThe code below enforces the conditions described above. Please note that the \n`nextStageScriptHash` environment variable contains hash of the issuance stage serialized script. \n\n```\n    val selfIndexIsZero = INPUTS(0).id == SELF.id\n\n    val proof = getVar[Coll[Byte]](1).get\n\n    val inputsCount = INPUTS.size\n\n    val toAdd: Coll[(Coll[Byte], Coll[Byte])] = INPUTS.slice(1, inputsCount).map({ (b: Box) =>\n        val pk = b.R4[Coll[Byte]].get\n        val value = longToByteArray(b.value)\n        (pk, value)\n    })\n\n    val modifiedTree = SELF.R5[AvlTree].get.insert(toAdd, proof).get\n\n    val expectedTree = OUTPUTS(0).R5[AvlTree].get\n\n    val properTreeModification = modifiedTree == expectedTree\n\n    val outputsCount = OUTPUTS.size == 2\n\n    val selfOutputCorrect = if(HEIGHT < 2000) {\n        OUTPUTS(0).propositionBytes == SELF.propositionBytes\n    } else {\n        blake2b256(OUTPUTS(0).propositionBytes) == nextStageScriptHash\n    }\n\n    val feeOutputCorrect = (OUTPUTS(1).value <= 1) && (OUTPUTS(1).propositionBytes == feeBytes)\n\n    val outputsCorrect = outputsCount && feeOutputCorrect && selfOutputCorrect\n\n    selfIndexIsZero && outputsCorrect && properTreeModification\n```"
    },
    {
      "heading": "The Issuance Stage",
      "level": 3,
      "content": "This stage has only one spending transaction to get to the next stage (the withdrawal stage). The spending transactions makes the following modifications. Firstly, the it changes the list of allowed operations on the dictionary from \"inserts only\" to \"removals only\", as the next stage (withdrawal) is only dealing with removing entries from the dictionary.\n\nSecondly, the contract checks that the proper amount of ICO tokens are issued. In Ergo, it is allowed to issue one new kind of token per transaction, and the identifier of the token should be equal to the (unique) identifier of the first input box. The issuance sub-contract checks that a new token has been issued, and the amount of it is equal to the amount of nanoErgs collected by the ICO at till now.\n\nThirdly, the contract checks that a spending transaction is indeed re-creating the box with the guard script corresponding to the next stage, the withdrawal stage.\n\nFinally, the project should withdraw collected Ergs, and of course, each spending transaction should pay a fee. Thus, the sub-contract checks that the spending transaction has indeed 3 outputs (one each for the project tokens box, the Ergs wirhdrawal box, and the fee box), and that the first output and output is carrying the tokens issued. As we do not specify project money withdrawal details, we require a project signature on the spending transaction.\n\n```\n    val openTree = SELF.R5[AvlTree].get\n    \n    val closedTree = OUTPUTS(0).R5[AvlTree].get\n    \n    val digestPreserved = openTree.digest == closedTree.digest\n    val keyLengthPreserved = openTree.keyLength == closedTree.keyLength\n    val valueLengthPreserved = openTree.valueLengthOpt == closedTree.valueLengthOpt\n    val treeIsClosed = closedTree.enabledOperations == 4\n    \n    val tokenId: Coll[Byte] = INPUTS(0).id\n    \n    val tokensIssued = OUTPUTS(0).tokens(0)._2\n    \n    val outputsCountCorrect = OUTPUTS.size == 3\n    val secondOutputNoTokens = OUTPUTS(0).tokens.size == 1 && OUTPUTS(1).tokens.size == 0 && OUTPUTS(2).tokens.size == 0\n    \n    val correctTokensIssued = SELF.value == tokensIssued\n    \n    val correctTokenId = OUTPUTS(0).R4[Coll[Byte]].get == tokenId && OUTPUTS(0).tokens(0)._1 == tokenId\n    \n    val valuePreserved = outputsCountCorrect && secondOutputNoTokens && correctTokensIssued && correctTokenId\n    val stateChanged = blake2b256(OUTPUTS(0).propositionBytes) == nextStageScriptHash\n    \n    val treeIsCorrect = digestPreserved && valueLengthPreserved && keyLengthPreserved && treeIsClosed\n    \n    projectPubKey && treeIsCorrect && valuePreserved && stateChanged\n```"
    },
    {
      "heading": "The Withdrawal Stage",
      "level": 3,
      "content": "At this stage, investors are allowed to withdraw project tokens protected by a predefined guard script (whose hash is stored in the dictionary). Lets say withdraw is done in batches of size N. A withdrawing transaction, thus, has N + 2 outputs, where the first output carrys over the withdrawal sub-contract and balance tokens, the last output pays the fee and the remaining N outputs have guarding scripts and token values according to the dictionary. The contract requires two proofs for the dictionary elements: one proving that values to be withdrawn are indeed in the dictionary, and the second proving that the resulting dictionary does not have the withdrawn values. The sub-contract is below.  \n```\n    val removeProof = getVar[Coll[Byte]](2).get\n    val lookupProof = getVar[Coll[Byte]](3).get\n    val withdrawIndexes = getVar[Coll[Int]](4).get\n\n    val out0 = OUTPUTS(0)\n\n    val tokenId: Coll[Byte] = SELF.R4[Coll[Byte]].get\n\n    val withdrawals = withdrawIndexes.map({(idx: Int) =>\n        val b = OUTPUTS(idx)\n        if(b.tokens(0)._1 == tokenId) {\n            (blake2b256(b.propositionBytes), b.tokens(0)._2)\n        } else {\n            (blake2b256(b.propositionBytes), 0L)\n        }\n    })\n\n    val withdrawValues = withdrawals.map({(t: (Coll[Byte], Long)) => t._2})\n\n    val withdrawTotal = withdrawValues.fold(0L, { (l1: Long, l2: Long) => l1 + l2 })\n\n    val toRemove = withdrawals.map({(t: (Coll[Byte], Long)) => t._1})\n\n    val initialTree = SELF.R5[AvlTree].get\n\n    val removedValues = initialTree.getMany(toRemove, lookupProof).map({(o: Option[Coll[Byte]]) => byteArrayToLong(o.get)})\n    val valuesCorrect = removedValues == withdrawValues\n\n    val modifiedTree = initialTree.remove(toRemove, removeProof).get\n\n    val expectedTree = out0.R5[AvlTree].get\n\n    val selfTokensCorrect = SELF.tokens(0)._1 == tokenId\n    val selfOutTokensAmount = SELF.tokens(0)._2\n    val soutTokensCorrect = out0.tokens(0)._1 == tokenId\n    val soutTokensAmount = out0.tokens(0)._2\n\n    val tokensPreserved = selfTokensCorrect && soutTokensCorrect && (soutTokensAmount + withdrawTotal == selfOutTokensAmount)\n\n    val properTreeModification = modifiedTree == expectedTree\n\n    val selfOutputCorrect = out0.propositionBytes == SELF.propositionBytes\n\n    properTreeModification && valuesCorrect && selfOutputCorrect && tokensPreserved\n```"
    },
    {
      "heading": "Possible Enhancements",
      "level": 2,
      "content": "Please note that there are many nuances our example contract is ignoring. For example, anyone listening to the blockchain is allowed to execute the contract and construct proper spending transactions during funding and withdrawal stages. In the real-world, additional signature from the project or a trusted arbiter may be used. \n\nAlso, there is no self-destruction case considered in the withdrawal contract, so it will live until being destroyed by miners via storage rent mechanism, potentially for decades or even centuries. For the funding stage, it would be reasonable to have an additional input from the project with the value equal to the value of the fee output. And so on."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/uses/ergo-ico.md",
  "processed_at": "2025-05-11T20:02:11.468094",
  "ai_processed": true
}