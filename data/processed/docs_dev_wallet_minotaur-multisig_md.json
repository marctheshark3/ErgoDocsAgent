{
  "id": "docs_dev_wallet_minotaur-multisig_md",
  "title": "Multi-Signature Wallet",
  "summary": "The document describes the implementation of a multi-signature wallet in the Minotaur wallet, a multi-platform wallet developed using TypeScript. The key points are:\n\nThe wallet allows multiple private keys to authorize transactions, enabling management by a single user with multiple keys or multiple users with one key each. The wallet supports configuring the number of required signatures (N) out of the total number of signers (M).\n\nThe wallet creation process involves each signer configuring a copy of the wallet with the same M and N values, entering their private key and the public keys of other signers, and deriving a unique address for the multi-sig wallet.\n\nThe wallet provides standard wallet functionalities like displaying balances and transaction history. The address derivation and transaction signing processes are implemented to handle the multi-sig requirements, involving the generation and sharing of commitments between signers.\n\nThe \"sign transaction\" modal facilitates the multi-sig signing process, allowing signers to generate and share commitments until the required number of signatures is reached, at which point the final signed transaction is created.",
  "qa_pairs": [
    {
      "question": "What is this document about?",
      "answer": "# Multi-Signature Wallet\n\n## Introduction\n\nMinotaur wallet is a multi-platform wallet developed by *minotaur-ergo* using TypeScript.\n\nIn this project, the wallet is extended to support multiple signat..."
    },
    {
      "question": "What is the title of this document?",
      "answer": "Multi-Signature Wallet"
    },
    {
      "question": "What is the 'Introduction' section about?",
      "answer": "Minotaur wallet is a multi-platform wallet developed by *minotaur-ergo* using TypeScript.\n\nIn this p..."
    },
    {
      "question": "What is the 'Explanation' section about?",
      "answer": "In Ergo blockchain, a transaction is prepared in two steps before being submitted to the\ntransaction..."
    }
  ],
  "sections": [
    {
      "heading": "Multi-Signature Wallet",
      "level": 1,
      "content": ""
    },
    {
      "heading": "Introduction",
      "level": 2,
      "content": "Minotaur wallet is a multi-platform wallet developed by *minotaur-ergo* using TypeScript.\n\nIn this project, the wallet is extended to support multiple signatures.\n\nA multi-signature (*multi-sig*) wallet uses more than one private key to authorize transactions.\n\nSuch a wallet can be managed by a single user holding multiple private keys, multiple users holding a single key each, or any combination of the two scenarios.\n\nIn a multi-sig wallet with *M* private keys, depending on its configurations, any transaction may require *N* signatures, where *1<=N<=M*.\n\nThe project accomplishments are as follows:\n\nThe end user(s):\n\n  - can easily create a multi-signature wallet,\n  - can see their wallet balance,\n  - can sign their transactions in the wallet.\n\nThe software provides an automatic transfer method that safely processes all signatures and communications between private-key holders."
    },
    {
      "heading": "Explanation",
      "level": 2,
      "content": "In Ergo blockchain, a transaction is prepared in two steps before being submitted to the\ntransaction pool:\n\n* required commitments are generated\n* The transaction is signed using the commitments\n\nThese steps are performed automatically and transparently (hidden from the user) in any wallet. However, signing a multi-sig transaction involves more sophisticated steps, as explained in [EIP 11](https://github.com/ergoplatform/eips/pull/8).\nIn other words, the steps mentioned above cannot be performed transparently since the commitments and signatures must be shared between all signers.\n\nThe procedure can be explained more clearly using the following example:\n\nConsider a 3-out-of-4 wallet, and let us name the 4 private-key holders Alice, Bob, Carol, and Dani.\n\nThe wallet has been configured so that at least 3 signers must sign a transaction.\n\nSuppose that Alice, Bob, and Carol agree to sign a transaction.\n\nIn order to do so, \n\n1. Alice creates an unsigned transaction and generates her commitment.\n2. Then, she sends the transaction and the public part of her commitment to Bob.\n3. Bob generates his commitment and appends its public parts to Alice's commitment.\n4. Then, He forwards the transaction and the two-part commitment to Carol.\n5. Carol generates her commitment. At this step, all 3 required commitments are available.\n6. Therefore, Carol adds her signature to the transaction and sends it back to Bob.\n7. Similarly, Bob adds his signature to the transaction and forwards it to Alice.\n8. Finally, Alice completes the transaction signing by adding her signature to it.\n9. Now she can submit the signed transaction to the transaction pool.\n\nThe minotaur multi-sig wallet facilitates the whole process in a user-friendly manner."
    },
    {
      "heading": "Wallet Creation",
      "level": 3,
      "content": "Implementation of this project introduces a new type of wallet, the so-called multi-sig wallet, to the Minotaur wallet.\nIn order to create a new functional multi-sig wallet,\neach signer must configure a copy of it on his/her device by applying the following four steps:\n\n* A proper name is entered for the personal copy of the multi-sig wallet.\n    * Names entered by different signers can be different.\n* The total number of signers, *M*, and also the number of required signs, *N*, are entered.\n    * *M* can be maximally 20. All signers must enter the same values for these two numbers.\n* Each signer must enter his/her private key and the public key of all other signers in the multi-sig wallet.\n    * For convenience, it is supposed that each signer already has a normal wallet in Minotaur so that his/her public/private key can be retrieved.\n    * For all other signers, either of the following solutions may be applied:\n      * Their extended public keys are entered. In this case, signers can derive the address of the multi-sig wallet.\n      * Their addresses are entered.\n      * In this case, it is **not** possible for signers to derive the address of the multi-sig wallet.\n* The address of the multi-sig wallet is displayed to each signer.\n  The signer's copy of the multi-sig wallet is created as soon as he/she approves the address."
    },
    {
      "heading": "Wallet Display Parts.",
      "level": 3,
      "content": "Since the implementation is based on a standard wallet, the following functionalities of the underlying standard wallet already work in the multi-sig wallet too:\n\n* Extracting fund information from the Ergo blockchain\n* Displaying transaction history\n* Creating unsigned transaction\n* Displaying addresses\n* Displaying assets\n* Connecting to dApps\n\nHowever, two principal parts must be implemented: the address derivation and the \"sign transaction\" modal."
    },
    {
      "heading": "Address Derivation",
      "level": 4,
      "content": "When deriving new addresses, two important facts must be taken into account.\nFirst, to guarantee a unique address for the multi-sig wallet to be derived on all signer copies, a unique address-derivation algorithm must be applied everywhere.\nThe applied algorithm is as follows:\n\nFor a specified path, using each signer's extended public key, an address is derived for that signer.\n\nThe list of derived addresses for all signers is used to compile a multi-sig contract like:\n\n```scala\natLeast(\n  N,\n  Coll(\n    PK(Address1),\n    PK(Address2),\n    .\n    .\n    .\n    PK(AddressM)\n  )\n)\n```\n\nThe contract mentioned above results in distinguishable (different) addresses when two signer addresses swap. In order to prevent this, the list of signers' addresses are always sorted before being used in the contract.\n\nSecond, the Sigma-rust library cannot compile any contract. One might think of Node as a solution, but it does not fulfil the project criteria since it disables cold signing. Our solution to this problem is to manually create the required ergiTree array as follows:\n\n* The first byte in the array has a value of 10.\n* The number of constant values in the contract.\n    * This number equals *M+1* and is encoded as a variable-length quantity (VLQ).\n* The number of required signs, *N*.\n    * This number starts with a byte with value 04 that denotes the integer type, followed by the value of *N* encoded as a VLQ.\n* For each public key (*M* times), 35 bytes are used: 2 bytes with value 08cd, followed by 33 bytes representing the public key\n* A byte with value 98, indicating \"atLeast\"\n* Two bytes, with values 73 and 00, respectively.\n    * The value 00 indicates the VLQ representation of the index of value *N* in the list of constants.\n* A constant byte with value 83, followed by the VLQ representation of *M*, and a constant byte with value 08\n* For each public key (*M* times), a byte with value 73, followed by the VLQ representation of the index of the public key in the list of constants"
    },
    {
      "heading": "\"Sign transaction\" modal",
      "level": 4,
      "content": "After an unsigned transaction is created, the Minotaur wallet displays a modal so the user can confirm his/her password and sign the transaction.\nSimilarly, the same modal is displayed for a multi-sig wallet too.\n\nWhen a user enters his/her password into the modal, a commitment is generated, whose private part is stored locally, and then the following information is displayed in the form of a JSON string:\n\n```JSON\nMCR-{\n  \"tx\": <reduced transaction bytes>,\n  \"boxes\": [<encoded boxes>],\n  \"commitments\": <commitments encoded>\n} \n```\nA user must share this string with other wallets through any communication.\n\nFor convenience, a *copy to clipboard* button has been provided in the modal.\n\nAs soon as any other signer enters the JSON string into his/her wallet, the wallet displays information regarding the transaction.\n\nThe signer generates personal commitment by entering his/her password and approving the transaction.\n\nThe newly created commitment is merged with the received one, and a new JSON string is presented.\n\nThis new string must be passed to the next signer.\n\nThe process repeats until the last required signer generates his/her commitment.\n\nAt this moment, the last signer signs the transaction and creates a JSON string containing the following information:\n\n```JSON\n{\n  \"tx\": <reduced transaction bytes>,\n  \"boxes\": [<encoded boxes>],\n  \"commitments\": <commitments encoded>,\n  \"simulated\": [<list of simulated public keys for all inputs>]\n  \"signed\": [<list of all signed public keys for all inputs + my own public keys for all inputs>]\n  \"partialTx\": <partially signed tx proposition bytes>\n}\n```\nSimilar to the process of commitment generation,\nevery other signer must enter the received JSON string in his/her wallet, sign the transaction, generate a new JSON string, and pass it to the next signer.\nAfter signing the transaction, the last signer can submit it to the blockchain."
    },
    {
      "heading": "CoSigning Server",
      "level": 2,
      "content": "A [cosigning server](https://github.com/lazypinkpatrick/cosigning-server) was designed and implemented in order to simplify communications between wallets.\n\nThe server can store data for any specific address.\n\nMoreover, for any address, associated data stored on the server can be requested.\n\nThe server keeps data for 10 minutes only.\n\nThis server has two APIs:"
    },
    {
      "heading": "**/put**",
      "level": 3,
      "content": "> Stores data on the server for any specific address:\n\n- We assume that each wallet uses the address derived from the path `m/44'/429'/0'/0/0`.\n- The JSON string passed to this API is something like the example below, where the `\"type\": <value>` pair is used to specify the data category:\n\n```JSON\n{\n    \"sender\": \"me\",\n    \"message\": \"\",\n    \"type\": \"create\",\n    \"receiver\": [\"user1\", \"user2\"]\n}\n```"
    },
    {
      "heading": "**/get**",
      "level": 3,
      "content": "> Gets a list of requested data for a specified address:\n\n- For a given triplet of (*ID*, *address*, *value*), this API gets, from the server, all messages with an ID greater than the given one and returns data associated with the given *address* that would have a type of *value*.\n\nIn this implementation, we assume that a new transaction is highlighted with the `\"type\": \"create\"` pair,\nwhile all sub-messages are linked to their parent transaction using the transaction ID as their type value, i.e., `\"type\": <txId>`\n\nOur implemented scenario for signing a transaction using this server is as follows:\n\n* The first signer creates an unsigned transaction.\n* If the user selects the \"sign via cosigning server\" option, he/she sends the following JSON string to all other signers in the multi-sig wallet:\n\n\n```JSON\n{\n  \"type\": \"create\",\n  \"tx\": <reduced tx>\n  \"boxes\": [<encoded boxes>]\n}\n```\nOther signers receive this JSON string and generate a party for it.\n\n\nThe first signer also creates his/her commitment and sends the following JSON to all other party members:\n\n\n```JSON\n{\n  \"type\": \"commitment\",\n  \"commitments\": [<my encoded commitment for all inputs>]\n}\n```\n\n* Every other signer generates a commitment by entering his/her password.\n  At the same time, entering the password by the signer indicates to the wallet that he/she accepts the transaction and is willing to sign it.\n* When the number of commitments reaches the required count,\n  every wallet signs the transaction and sends it to all other signers in the following format:\n```json\n{\n  \"type\": \"sign\"\n  \"simulated\": [<list of simulated public keys; the first signer generated this list, and no one has changed it yet.>]\n  \"signed\": [<list of signatures in this transaction; everyone must append his/her public key to this list.>]\n  \"partial\": <partially signed tx in the base64 format>.\n}\n```\n* Every wallet, when it receives a new partially-signed transaction, checks the number of signatures on it:\n  - If the wallet has not already signed the transaction, it is signed and published\n  - If the number of signatures on the received transaction is greater than that on the local copy, the local copy is replaced with the received one\n  - If all commitment generators have already signed the transaction, the wallet submits it to the blockchain, and the process is completed."
    },
    {
      "heading": "Signing Server for Multi-Sig Communication (ErgoHack IX)",
      "level": 2,
      "content": ""
    },
    {
      "heading": "Introduction",
      "level": 3,
      "content": "Minotaur is the first multi-signature wallet developed for Ergo. A multi-signature wallet, or multi-sig wallet, uses more than one private key to authorize transactions. Such a wallet can be managed by a single user holding multiple private keys, multiple users holding a single key each, or any combination of the two scenarios. In a multi-sig wallet with *M* private keys, depending on its configurations, any transaction may require *N* signatures, where *1 <= N <= M*.\n\nSigning any multi-sig transaction on the Ergo chain consists of two major steps that must be completed by any *N* signer(s) among the *M* key-holders:\n\n1. Generating required commitment(s) and sharing them with all other signers (*N* times).\n2. Signing the transaction using gathered commitments (*N* times).\n\nIn Minotaur, an *N*-sig transaction is performed as follows:\n\n- The first signer, i.e., a key-holder who creates the transaction, generates his/her own commitment(s) and, including all other required data, sends it to a second signer.\n- A second signer receives the transaction data, appends his/her own commitment(s) to it, and sends it to a third signer.\n- The process is repeated by all other signers, except the last one.\n- The last signer receives commitments of all other signers. He/She generates his/her own commitment(s) and appends it to the transaction data, and finally signs the transaction. Then, the partially signed transaction is sent to another signer.\n- Any middle signer signs the transaction and passes it to another one.\n- The last one who adds the last signature to the transaction publishes the fully-signed transaction.\n\nThe process is error-prone. In fact, any human error in sending commitment(s) and using invalid commitment sets results in an invalid, and thus incomplete, transaction. Such failures have been reported frequently.\n\nIn order to solve this problem, we introduce the Minotaur Signing Server, which manages the signing process and ensures a valid and completed transaction.\n\nFor more details and to access the code, please visit the following repositories:\n\n- [Minotaur Wallet Code](https://github.com/minotaur-ergo/minotaur-wallet/tree/ergo-hack-multi-sig-signing-server)\n- [Minotaur Signing Server (MSS) Code](https://github.com/minotaur-ergo/Minotaur-Signing-Server/tree/fix-some-incompatibilities)"
    },
    {
      "heading": "The Minotaur Signing Server",
      "level": 3,
      "content": "The Minotaur Signing Server (MSS) manages the steps of transaction signing. The MSS provides a safe, reliable, secure, and error-free channel for data transition among signers. Therefore, it can guarantee that every signer receives and uses correct transaction data.\n\nThe workflow of the MSS is as follows:\n\n1. First, each of the wallet key-holders must generate an asymmetric key-pair for communication with the server. We refer to these keys as the communication private and public keys. The MSS expects every signer to sign his/her communication public key with his/her transaction-signing key in order to confirm the signer's identity.\n2. The MSS needs the multi-sig wallet details, including the extended public key of each signer and also the number of required signatures. Any of the key-holders can provide the MSS with this data. It is only after receiving this data that the MSS allows for the processing of any transaction.\n3. At this stage, the multi-sig wallet setup is completed, and any number of transactions can be started. A new transaction is started as follows:\n   - The person who creates the transaction sends it to the MSS. From now on, each of the wallet holders will see the transaction on their multi-sig communication page of their connected Minotaur. The representation of data on the page has not been altered by the introduction of MSS, and the user may not sense any UI change.\n   - Any of the signers can select the desired transaction and generate their commitment(s) for it. By doing so, the private part of the commitment(s) is stored in Minotaur, and its public part is sent to the MSS.\n   - Anyone who receives the transaction also receives all previous public commitments. He/She can add his/her own commitment(s) as described above.\n4. As soon as the server receives all *N* commitments, the transaction is automatically sent for signing. In case any simulated signatures are required, they are created by the MSS. Moreover, any commitments that arrive after this point are rejected.\n5. At this stage, anyone who committed the transaction can sign it and send his/her signature to the MSS.\n6. As soon as all *N* signatures arrive at the MSS, it automatically completes the transaction and sends it on the blockchain."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/wallet/minotaur-multisig.md",
  "processed_at": "2025-05-11T19:39:52.565736",
  "ai_processed": true
}