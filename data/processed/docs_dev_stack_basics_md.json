{
  "id": "docs_dev_stack_basics_md",
  "title": "Ergo Platform Basic Starter Tutorial",
  "summary": "This tutorial provides an introduction to the Ergo blockchain and how to interact with it using various programming languages. It covers the basics of creating keys and addresses, sending payments, and receiving payments. The tutorial includes code examples in Java, Kotlin, Scala, JavaScript, and Python for common tasks like creating an address from a mnemonic phrase and sending transactions. It also mentions using the Ergo Explorer API to monitor incoming payments.",
  "qa_pairs": [
    {
      "question": "What programming languages are covered in the Ergo Platform Basic Starter Tutorial?",
      "answer": "Java, Scala, Kotlin, JavaScript, Python."
    },
    {
      "question": "How are keys and addresses created in the Ergo Platform?",
      "answer": "Ergo Platform uses public key cryptography, with a mnemonic seed phrase to derive the master key, from which an infinite number of private and public keys can be derived with an index."
    },
    {
      "question": "What are the main steps to send payments on the Ergo Platform?",
      "answer": "1. Search for unspent boxes covering the amount to be sent, 2. Create an unsigned transaction with the input boxes and output boxes for the payment recipient, 3. Sign the transaction, 4. Submit the transaction to the network."
    },
    {
      "question": "What is the role of the ErgoClient in sending payments on the Ergo Platform?",
      "answer": "The ErgoClient provides high-level methods to perform the common tasks of sending payments, such as finding unspent boxes, creating the transaction, and signing it."
    },
    {
      "question": "How is the recipient address and amount to send specified when sending a payment on the Ergo Platform?",
      "answer": "The recipient address is specified using the Address.create() method, and the amount to send is specified as a long value representing the amount in nanoERGs."
    }
  ],
  "sections": [
    {
      "heading": "Introduction",
      "level": 0,
      "content": "---\ntags:\n  - Java\n  - Scala\n  - Kotlin\n  - JavaScript\n  - Python\n  - Tutorial\n---"
    },
    {
      "heading": "Ergo Platform Basic Starter Tutorial",
      "level": 1,
      "content": "This tutorial will teach you the very basics of interacting with the ergo blockchain to receive\nand send funds for multiple programming languages. For more in-depth information on the different\nSDKs available, please refer to their specific pages."
    },
    {
      "heading": "Import the SDK",
      "level": 2,
      "content": "Import the SDK for the build system you are using in your project.\n\n=== \"Gradle\"\n\n     ```bash\n      implementation (\"org.ergoplatform:ergo-appkit_2.12:5.0.0\")\n     ```\n\n=== \"Maven\"\n\n     \n\t\t<dependency>\n\t\t\t<groupId>org.ergoplatform</groupId>\n\t\t\t<artifactId>ergo-appkit_2.12</artifactId>\n\t\t\t<version>5.0.0</version>\n\t\t</dependency>\n    \n\n=== \"SBT\"\n\n     \n\t\ttbd\n    \n\n=== \"npm\"\n\n    ```bash \n      npm install @fleet-sdk/core    \n    ```\n\n=== \"yarn\"\n\n    ```bash \n      yarn install @fleet-sdk/core    \n    ```\n\n=== \"pip\"\n\n    ```bash\n      pip install ergpy    \n    ```"
    },
    {
      "heading": "Create keys and an address",
      "level": 2,
      "content": "Ergo Platform uses public key cryptography to ensure that every transaction is secure: every personal wallet has a keypair consisting of a public key and a secret key. The public key is always safe to share \u2014 other people need it to verify that you authorized a transaction. It's like an email address. \nThe secret key, however, is private information that proves you own \u2014 and gives you access to \u2014 your private wallet. It's like a password, and you should never share it with anyone.\n\nOn Ergo, the secret key is usually a 15 words mnemonic seed phrase that is used to derive the internally used binary master key. From this master key, an infinite number of private and public keys can be derived with an index. So for every mnemonic seed phrase, there are existing multiple key pairs and addresses defined by an index. The main address is always at index 0. \n\nYou can create this address from a mnemonic phrase the following way:\n\n=== \"Java\"\n\n    ```Java \n\t\tString ergoAddress = Address.createEip3Address(\n          index,\n          NetworkType.MAINNET,\n          SecretString.create(mnemonic),\n          SecretString.empty(),\n          false\n        ).toString()\n    ```\n    \n\n=== \"Kotlin\"\n\n    ```java \n\t\tval ergoAddress = Address.createEip3Address(\n          index,\n          NetworkType.MAINNET,\n          SecretString.create(mnemonic),\n          SecretString.empty(),\n          false\n        ).toString()\n    ```\n    \n\n=== \"Scala\"\n\n    ```scala\n    val ergoAddress = Address.createEip3Address(\n      index, \n      NetworkType.MAINNET, \n      SecretString.create(mnemonic),\n      SecretString.empty(),\n      false\n    ).toString\n    ```\n\n=== \"JavaScript\"\n\n     \n      tbd\n    \n\n=== \"Python\"\n\n    ```python\n    from jpype import java\n    from ergpy import helper_functions, appkit\n\n    ergo = appkit.ErgoAppKit(node_url=node_url)\n    ergo_address = helper_functions.get_wallet_address(ergo=ergo, amount=1, wallet_mnemonic=mnemonic)[0]\n\n    # Proper exit()\n    helper_functions.exit()\n    ```\n\nHaving the string representation of the address for your mnemonic, you can already receive payments."
    },
    {
      "heading": "Sending payments",
      "level": 2,
      "content": "If you created an address like described above and sent some ERG to it, you can send payments from this address.\n\nSending payments on Ergo is always done within a transaction. Ergo follows Bitcoin's model: A transaction is a set of input boxes and output boxes. The input boxes are spent within a transaction, and output boxes are created. For a transaction to be valid, it must be signed with \nthe private key of the address of the input boxes.\n\nSo sending payments needs the following steps to be done:\n\n- Search for unspent boxes covering the amount to be send\n- Create an unsigned transaction with the input boxes found and output boxes for the payment recipient\n- Sign the transaction\n- Submit the transaction to the network\n\nLuckily, our SDKs help you by providing high-level methods for this common task.\n\n=== \"Java\"\n\n    ```Java\n    ErgoClient ergoClient = RestApiErgoClient.create(nodeUrl, NetworkType.MAINNET, \"\", RestApiErgoClient.getDefaultExplorerUrl(NetworkType.MAINNET));\n\n    //address receiving the tx\n    Address recipient = Address.create(recipientAddress);\n    //amount to send\n    long amountToSend = 1000L * 1000L * 1000L // 1 ERG in nanoERGs\n    ergoClient.execute((BlockchainContext ctx) -> {\n        ErgoProver prover = ctx.newProverBuilder().withMnemonic(\n          SecretString.create(mnemonic),\n          SecretString.empty(),\n          false\n        ).withEip3Secret(0).build()\n\n        String txId = BoxOperations.createForProver(prover, ctx)\n                .withAmountToSpend(amountToSend)\n                .withInputBoxesLoader(new ExplorerAndPoolUnspentBoxesLoader().withAllowChainedTx(true))\n                .send(recipient);\n    });\n    ```\n    \n\n=== \"JavaScript\"\n\n    ```JavaScript\n    import { TransactionBuilder, OutputBuilder } from \"@fleet-sdk/core\";\n\n    new TransactionBuilder(creationHeight);\n\n    type Box = {\n      boxId: string;\n      value: string | bigint;\n      assets: { tokenId: string; amount: string | bigint }[];\n      ergoTree: string;\n      creationHeight: number;\n      additionalRegisters: NonMandatoryRegisters;\n      index: number;\n      transactionId: TransactionId;\n    };\n\n    new TransactionBuilder(creationHeight)\n      .from(inputs)\n      .withDataFrom(dataInputs);\n\n    new TransactionBuilder(creationHeight)\n      .from(inputs)\n      .to(\n        new OutputBuilder(\n          \"1000000\", // amount of nanoergs\n          \"9gNvAv97W71Wm33GoXgSQBFJxinFubKvE6wh2dEhFTSgYEe783j\" // recipient address\n        )\n    );\n    ```\n\n\n    \n\n=== \"Python\"\n\n\n    ```py\n    from jpype import java\n    from ergpy import helper_functions, appkit\n\n    ergo = appkit.ErgoAppKit(node_url=node_url)\n    amount_send = 1 # 1 ERG\n\n    helper_functions.simple_send(ergo=ergo, amount=amount_send, wallet_mnemonic=mnemonic,\n      receiver_addresses=recipient)\n\n    # Proper exit()\n    helper_functions.exit()\n    ```"
    },
    {
      "heading": "Receiving payments",
      "level": 2,
      "content": "You don\u2019t actually need to do anything to receive payments: if a payer makes a successful \ntransaction to send assets to you, those assets will automatically be added to your wallet.\n\nHowever, you may want to keep an eye out for incoming payments. For this, you can make use of\nour [Ergo Explorer API](https://api.ergoplatform.com/api/v1/docs/). The API's interfaces are \nshipping with some of our SDKs.\n\n=== \"Java\"\n\n    ```java \n        // appkit ships with a Retrofit interface\n        DefaultApi ergoApiService = Retrofit.Builder()\n            .baseUrl(RestApiErgoClient.defaultMainnetExplorerUrl)\n            .addConverterFactory(GsonConverterFactory.create())\n            .build().create(DefaultApi.class)\n\n        // call methods on ergoApiService here\n    ```\n    \n\n=== \"JavaScript\"\n\n     \n      tbd    \n    \n\n=== \"Python\"\n\n     \n      tbd"
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/stack/basics.md",
  "processed_at": "2025-05-11T19:33:31.777638",
  "ai_processed": true
}