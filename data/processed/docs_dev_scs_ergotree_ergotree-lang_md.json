{
  "id": "docs_dev_scs_ergotree_ergotree-lang_md",
  "title": "ErgoTree as a Language",
  "summary": "The document provides an improved and clearer documentation for the ErgoTree language, a typed, call-by-value, higher-order functional language without recursion. It supports features like single-assignment blocks, tuples, optional values, indexed collections with higher-order operations, short-circuiting logical operations, and ternary if-else expressions with lazy branches. The semantics of ErgoTree are specified by translating it to a lower-level language called Core-\u03bb and providing its denotational evaluation semantics. The abstract syntax of ErgoTree is defined, and the typing rules are specified. The document also describes the lowering of ErgoTree terms to Core-\u03bb, including the translation of lambda expressions, function application, method calls, tuples, logical operations, and block expressions.",
  "qa_pairs": [
    {
      "question": "What is the primary purpose of the ErgoTree language?",
      "answer": "ErgoTree is a typed, call-by-value, higher-order functional language without recursion that is used to specify the semantics of the Ergo blockchain platform."
    },
    {
      "question": "What are the key features of the ErgoTree language?",
      "answer": "ErgoTree supports single-assignment blocks, tuples, optional values, indexed collections with higher-order operations, short-circuiting logical operations, and ternary if-else expressions with lazy branches."
    },
    {
      "question": "How is the semantics of ErgoTree specified?",
      "answer": "The semantics of ErgoTree are specified by first translating it to a lower-level language called Core-\u03bb and then providing its denotational evaluation semantics."
    },
    {
      "question": "What is the purpose of the lowering process from ErgoTree to Core-\u03bb?",
      "answer": "The lowering process from ErgoTree to Core-\u03bb is used to provide a more formal and lower-level specification of the semantics of the ErgoTree language."
    },
    {
      "question": "How are n-ary lambdas transformed in the lowering process?",
      "answer": "All n-ary lambdas where n > 1 are transformed into single-argument lambdas using tupled arguments during the lowering process from ErgoTree to Core-\u03bb."
    }
  ],
  "sections": [
    {
      "heading": "Introduction",
      "level": 0,
      "content": "$$\n\\newcommand{\\lst}[1]{#1}\n\\newcommand{\\Tup}[1]{(#1)}\n\\newcommand{\\Apply}[2]{#1\\langle#2\\rangle}\n\\newcommand{\\MSig}[3]{\\text{def}~#1(#2): #3}\n\\newcommand{\\Ov}[1]{\\overline{#1}}\n\\newcommand{\\TyLam}[3]{\\lambda(\\Ov{#1:#2}).#3}\n\\newcommand{\\Trait}[2]{\\text{trait}~#1~\\{ #2 \\}}\n\\newcommand{\\To}{\\mapsto}\n\\newcommand{\\Low}[1]{\\mathcal{L}{[\\![#1]\\!]}}\n\\newcommand{\\Lam}[2]{\\lambda#1.#2}\n\\newcommand{\\IfThenElse}[3]{\\text{if}~(#1)~#2~\\text{else}~#3}\n\\newcommand{\\False}{\\text{false}}\n\\newcommand{\\True}{\\text{true}}\n\\newcommand{\\langname}{ErgoTree}\n\\newcommand{\\corelang}{Core-\\lambda}\n$$"
    },
    {
      "heading": "ErgoTree as a Language",
      "level": 1,
      "content": "This section provides improved and clearer documentation for the ErgoTree language. ErgoTree is a typed, call-by-value, higher-order functional language without recursion. It supports various features such as single-assignment blocks, tuples, optional values, indexed collections with higher-order operations, short-circuiting logical operations, and ternary if-else expressions with lazy branches. It is important to note that all operations in ErgoTree are deterministic, without side effects, and all values are immutable.\n\nThe semantics of ErgoTree are specified by first translating it to a lower-level language called Core-\u03bb and then providing its denotational evaluation semantics. The abstract syntax of ErgoTree is defined in Table 1, which represents the `Value` class hierarchy in the reference implementation. The values in the \"Mnemonic\" column correspond to specific classes in the reference implementation."
    },
    {
      "heading": "Table 1: Abstract syntax of ErgoTree language",
      "level": 3,
      "content": "| Set Name | Syntax | Mnemonic | Description |\n|----------|--------|----------|-------------|\n| $\\mathcal{T} \\ni T$ | **P** | **SPredefType** | See [Types](types.md) |\n| | $\\tau$ | **STypeVar** | Type variable |\n| | $(T_1, \\ldots, T_n)$ | **STuple** | Tuple of $n$ elements (see [Tuple] type) |\n| | $(T_1, \\ldots, T_n) \\to T$ | **SFunc** | Function of $n$ arguments (see [Func] type) |\n| | ${{Coll}}[T]$ | **SCollection** | Collection of elements of type $T$ |\n| | ${{Option}}[T]$ | **SOption** | Optional value of type $T$ |\n| $Term \\ni e$ | $C(v, T)$ | **Constant** | Typed constant |\n| | $x$ | **ValUse** | Variable |\n| | $\\TyLam{x_i}{T_i}{e}$ | **FuncExpr** | Lambda expression |\n| | $\\Apply{e_f}{\\Ov{e_i}}$ | **Apply** | Application of a functional expression |\n| | $\\Apply{e.m}{\\Ov{e_i}}$ | **MethodCall** | Method invocation |\n| | $\\Apply{e_f}{\\Ov{e_i}}$ | **Tuple** | Constructor of a tuple with $n$ items |\n| | $\\Apply{\\delta}{\\Ov{e_i}}$ | | Primitive application |\n| | $\\text{if}~(e_{\\text{cond}})~e_1~\\text{else}~e_2$ | **If** | If-then-else expression |\n| | $\\{{ \\overline{{\\text{val}}}~x_i = e_i;}~e\\}$ | **BlockExpr** | Block expression |\n| $cd$ | $\\Trait{I}{\\overline{ms_i}}$ | **STypeCompanion** | Interface declaration |\n| $ms$ | $\\MSig{m[\\overline{\\tau_i}]}{\\overline{x_i : T_i}}{T}$ | **SMethod** | Method signature declaration |\n\nThe terms in ErgoTree are assigned types according to the typing rules specified in [Typing](typing.md).\n\n- **Constants** contain both the type and the data value of that type. The type of a constant must correspond to its value for it to be well-formed.\n- **Variables** are always typed and identified by a unique ID, which refers to either a lambda-bound variable or a val-bound variable.\n- **Lambda expressions** can take a list of lambda-bound variables, which can be used in the body expression. The body expression itself can also be a **block expression**.\n- **Function application** takes an expression of functional type (e.g., $(T_1, \\ldots, T_n) \\to T$) and a list of arguments. The notation $e_f(\\Ov{e})$ is not used to represent function application because it suggests that $(\\Ov{e})$ is a subterm, which it is not.\n- **Method invocation** allows the application of functions defined as methods of types. If an expression $e$ has type $T$, and a method $m$ is declared in type $T$, the method invocation $e.m(args)$ is valid. For more information on types and their methods, refer to [Types](types.md).\n- **Conditional expressions** in ErgoTree evaluate the condition strictly and the branches lazily. Each branch is an expression executed based on the result of the condition. This laziness is specified by lowering the expressions to Core-\u03bb (see Figure 2).\n- **Block expressions** contain a list of **val** definitions (bindings) of variables. Each subsequent definition in the block can only refer to previously defined variables. The result of the block's execution is the result of the final expression $e$, which can refer to any variable defined within the block.\n\nEach **type** in ErgoTree can be associated with a list of method declarations, indicating that the type has methods. The semantics of these methods follow similar principles to those in object-oriented languages like Java or Scala. When an instance of a type with methods exists, it is possible to call methods on the instance with additional arguments.\n\nEach **method** in ErgoTree can be parameterized by type variables, which are used in the method signature. Since ErgoTree only supports monomorphic values, each method call is monomorphic, and all type variables are assigned concrete types (see the MethodCall typing rule in [typing](typing.md)).\n\nTo specify the semantics of ErgoTree, its terms are translated to a lower-level language called Core-\u03bb, which is a simplified language without lazy operations. The lowering rules are defined in Figure 2."
    },
    {
      "heading": "Figure 2: Lowering to Core-\u03bb",
      "level": 2,
      "content": "| $Term_{ErgoTree}$ | | $Term_{Core}$  | \n|---||---|\n$\\Low{ \\TyLam{x_i}{T_i}{e}      }$ | $\\To$ | $\\Lam{   x:(T_0,\\dots,T_n)}{ \\Low{ \\{ \\Ov{\\lst{val}~x_i: T_i = x.\\_i;}~e\\} } }$    \n$\\Low{ \\Apply{e_f}{\\Ov{e_i}}    }$ | $\\To$ | $\\Apply{ \\Low{e_f} }{ \\Low{(\\Ov{e_i})} }$  \n$\\Low{ \\Apply{e.m}{\\Ov{e_i}}    }$ | $\\To$ | $\\Apply{ \\Low{e}.m}{\\Ov{ \\Low{e_i} }}$ \n$\\Low{ \\Tup{e_1, \\dots ,e_n}    }$ | $\\To$ | $\\Tup{   \\Low{e_1}, \\dots ,\\Low{e_n}}$ \n$\\Low{ e_1~\\text{\\|\\|}~e_2        }$ | $\\To$ | $\\Low{   \\IfThenElse{ e_1 }{ \\True }{ e_2 }}$    \n$\\Low{ e_1~\\text{&&}~e_2      }$ | $\\To$ | $\\Low{   \\IfThenElse{ e_1 }{ e_2 }{ \\False } }$  \n$\\Low{ \\IfThenElse{e_{cond}}{e_1}{e_2} }$ | $\\To$ | $\\Apply{(if(\\Low{e_{cond}} ,~\\Lam{(\\_:Unit)}{\\Low{e_1}} ,~\\Lam{(\\_:Unit)}{\\Low{e_2}} ))}{}$ \n$\\Low{ \\{ \\Ov{\\text{val}~x_i: T_i = e_i;}~e\\} }$ | $\\To$ | $\\Apply{ (\\Lam{(x_1:T_1)}{( \\dots \\Apply{(\\Lam{(x_n:T_n)}{\\Low{e}})}{\\Low{e_n}} \\dots )}) }{\\Low{e_1}}$\\\\\n$\\Low{ \\Apply{\\delta}{\\Ov{e_i}} }$ | $\\To$ | $\\Apply{\\delta}{\\Ov{ \\Low{e_i} }}$ \n$\\Low{ e }$     | $\\To$ |  $e$  \n\nAll $n$-ary lambdas where $n > 1$ are transformed into single-argument lambdas using tupled arguments.\n\nIt should be noted that the $\\IfThenElse{e_{\\text{cond}}}{e_1}{e_2}$ term in ErgoTree has lazy evaluation of its branches, while the right-hand-side $\\lst{if}$ is a primitive operation with strict evaluation of the arguments. Laziness is achieved using lambda expressions of type $\\lst{Unit} \\to \\lst{Boolean}$.\n\nLogical operations ($\\lst{||}$, `&&`) in ErgoTree, which are lazy (short-circuiting) on the second argument, are translated to $\\lst{if}$ terms in ErgoTree, which are then recursively translated to the corresponding Core-\u03bb terms.\n\nSyntactic blocks in ErgoTree are eliminated and translated into nested lambda expressions, which unambiguously specify the evaluation semantics of blocks. The evaluation semantics of Core-\u03bb are specified in [evaluation](evaluation.md).\n\nNote that the lowering transformation is used solely to specify semantics. Implementations may optimize the evaluation of ErgoTree directly as long as the semantics are preserved."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/scs/ergotree/ergotree-lang.md",
  "processed_at": "2025-05-11T19:29:26.857919",
  "ai_processed": true
}