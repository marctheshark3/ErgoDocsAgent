{
  "id": "docs_dev_scs_tx_ico_md",
  "title": "ico.md",
  "summary": "The document provides a detailed overview of an Initial Coin Offering (ICO) contract on the Ergo blockchain. It covers the three main stages of an ICO: Funding, Issuance, and Withdrawal. The Funding stage involves creating a box guarded by a script that manages an authenticated data structure (AVL tree) to store investor data. The Issuance stage transitions the contract to the Withdrawal stage, updating the AVL tree flags and verifying the token issuance. The Withdrawal stage allows investors to withdraw their allocated ICO tokens, using AVL tree proofs to authenticate and remove their entries from the dictionary. The document also includes a summary of a Refundable ICO contract used by the Comet project.",
  "qa_pairs": [
    {
      "question": "What is the purpose of an ICO contract on Ethereum?",
      "answer": "An ICO contract provides a mechanism for a project to collect funding (often in stablecoins or the platform's native token) and then issue project \"shares\" (in the form of new tokens) to investors."
    },
    {
      "question": "What are the three main stages of an ICO contract on Ergo?",
      "answer": "The three stages are: Funding, Issuance, and Withdrawal."
    },
    {
      "question": "How does Ergo handle large datasets in its contracts, unlike Ethereum?",
      "answer": "Ergo utilizes authenticated data structures like AVL trees to store a compact digest (e.g., ~33 bytes for an AvlTree) representing the root hash and state of a potentially vast (key, value) dictionary."
    },
    {
      "question": "What are the key actions performed by the Issuance stage of the ICO contract?",
      "answer": "The Issuance stage updates the AVL Tree flags, verifies the token issuance, transitions to the Withdrawal script, and checks the outputs."
    },
    {
      "question": "What are the two types of AVL tree proofs required by the Withdrawal script?",
      "answer": "The Withdrawal script requires a lookup proof to prove the existence and amounts associated with the investor keys being withdrawn, and a remove proof to prove that these investor entries have been correctly removed from the dictionary."
    }
  ],
  "sections": [
    {
      "heading": "Introduction",
      "level": 0,
      "content": "Another popular use case on Ethereum is an Initial Coin Offering (ICO) contract. An ICO mirrors an Initial Public Offering (IPO), providing a mechanism for a project to collect funding (often in stablecoins or the platform's native token) and then issue project \"shares\" (in the form of new tokens) to investors.\n\nGenerally, an ICO comprises 3 stages:\n\n- [**Funding**](#funding): During this period, investors are allowed to fund the project.\n- [**Issuance**](#issuance): A new asset token is created and issued to investors.\n- [**Withdrawal**](#withdrawal): Investors can withdraw their newly issued tokens.\n\nThis example ICO contract is quite complex compared to previous examples as it involves multiple stages and parties. The number of investors might run into the thousands. A naive solution, similar to some approaches on account-based models like the [ERC-20 standard](https://theethereum.wiki/w/index.php/ERC20_Token_Standard) on Ethereum, might attempt to store all investor data directly within the contract state.\n\nUnlike Ethereum, Ergo contracts cannot store arbitrarily large datasets directly. Instead, Ergo utilizes authenticated data structures like AVL trees. We store only a compact digest (e.g., ~33 bytes for an AvlTree) representing the root hash and state of a potentially vast (key, value) dictionary. To access or modify elements in the dictionary, a spending transaction must provide cryptographic proofs (lookup or modification proofs). This allows a contract to authenticate large datasets using very little on-chain storage."
    },
    {
      "heading": "Funding",
      "level": 2,
      "content": "The project initiates the ICO by creating a box guarded by the script shown below. This initial box also contains, in its R5 register, the authenticated digest of an empty dictionary intended to store (investor PK hash, invested amount) pairs. Here, an \"investor PK hash\" refers to the hash of the script (typically a standard P2PK script) that will guard the box containing the investor's withdrawn ICO tokens after the funding period ends.\n\n```scala\n// check if the index of the current input is 0\nval selfIndexIsZero = INPUTS(0).id == SELF.id\n\n// get the AVL tree proof from a register\nval proof = getVar[Coll[Byte]](1).get\n\n// collect pk and value of all inputs, except for the first one\nval toAdd = INPUTS.slice(1, INPUTS.size).map({(b: Box) =>\n    val pk = b.R4[Coll[Byte]].get\n    val value = longToByteArray(b.value)\n    (pk, value)\n})\n\n// insert the collected inputs into the AVL tree, using the proof\nval modifiedTree = SELF.R5[AvlTree].get.insert(toAdd, proof).get\n\n// get the expected AVL tree from the first output\nval expectedTree = OUTPUTS(0).R5[AvlTree].get\n\n// check if the self output is correct by comparing the script\n// if the current height is less than 2000, compare the script to the current box\n// otherwise, compare the script to the issuance script\nval selfOutputCorrect =\n    if (HEIGHT < 2000) OUTPUTS(0).propositionBytes == SELF.propositionBytes\n    else OUTPUTS(0).propositionBytes == issuanceScript\n\n// check if there is only one output and if the self output is correct\nval outputsCorrect = OUTPUTS.size == 1 && selfOutputCorrect\n\n// check if the index is 0, outputs are correct, and the expected tree matches the modified tree\nselfIndexIsZero && outputsCorrect && modifiedTree == expectedTree\n\n```\n\nThe first funding transaction spends this initial box and creates a new box containing the same script but with an updated dictionary digest in R5 reflecting the first investment. Subsequent funding transactions spend the box created by the *previous* funding transaction. The script ensures that the ICO contract box is always the first input (`INPUTS(0)`). Additional inputs in the transaction represent contributions from investors. Each investor input must contain the hash of their withdrawal script (their public key hash) in register R4. The ICO script verifies (using the provided AVL tree proof) that the investor PK hashes and their corresponding investment amounts (box values) are correctly inserted into the dictionary. The script also ensures that only one output box is created, carrying forward the updated dictionary digest and the accumulated Ergs (fees are ignored in this simplified example).\n\nDuring this funding stage, which lasts until block height 2,000, withdrawals are not permitted; Ergs can only be added to the ICO box. The first transaction occurring at or after height 2,000 must transition the contract to the next stage by changing the output box's script to `issuanceScript` (described next), while keeping the dictionary data (digest) the same."
    },
    {
      "heading": "Issuance",
      "level": 2,
      "content": "This stage involves a single transaction to transition to the withdrawal stage. The spending transaction performs the following actions, verified by the `issuanceScript`:\n1.  **Updates AVL Tree Flags**: It changes the allowed operations on the dictionary from \"inserts only\" to \"removals only\" by updating the `enabledOperations` flag in the `AvlTreeData`.\n2.  **Verifies Token Issuance**: It checks that the correct amount of ICO tokens are issued. In Ergo, a transaction can issue a new token, whose ID is determined by the ID of the first input box. The `issuanceScript` verifies that a new token (with this ID) is created in the first output box (`OUTPUTS(0)`) with a total supply equal to the total nanoErgs collected during the funding stage (`SELF.value`).\n3.  **Transitions to Withdrawal Script**: It ensures the output box (`OUTPUTS(0)`) containing the tokens and the dictionary digest is protected by the `withdrawScript` for the next stage.\n4.  **Checks Outputs**: It verifies that the transaction has exactly two outputs: `OUTPUTS(0)` (the main contract box for the withdrawal stage) and `OUTPUTS(1)` (a box sending the collected Ergs to the project's designated address, identified by `projectPubKeyHash`).\n\nThe complete `issuanceScript` is shown below.\n\n```scala\n// Get the open and closed trees\nval openTree = SELF.R5[AvlTree].get\nval closedTree = OUTPUTS(0).R5[AvlTree].get\n\n// Check that the digests, key lengths and values are the same\nval correctDigest = openTree.digest == closedTree.digest\nval correctKeyLength = openTree.keyLength == closedTree.keyLength\nval correctValue = openTree.valueLengthOpt == closedTree.valueLengthOpt\n\n// Check that the closed tree is a remove-only tree\nval removeOnlyTree = closedTree.enabledOperations == 4\n\n// Check that the token IDs and amounts are correct\nval tokenId: Coll[Byte] = INPUTS(0).id\nval tokenIssued = OUTPUTS(0).tokens(0)._2\nval correctTokenNumber = OUTPUTS(0).tokens.size == 1 && OUTPUTS(1).tokens.size == 0\nval correctTokenIssued = SELF.value == tokenIssued\nval correctTokenId = OUTPUTS(0).R4[Coll[Byte]].get == tokenId && OUTPUTS(0).tokens(0)._1 == tokenId\n\n// Check that the values have been preserved, the state has changed and the project public key is correct\nval valuePreserved = OUTPUTS.size == 2 && correctTokenNumber && correctTokenIssued && correctTokenId\nval stateChanged = OUTPUTS(0).propositionBytes == withdrawScript\nval projectPubKey = SELF.R5[Coll[Byte]].get == projectPubKeyHash\nval treeIsCorrect = correctDigest && correctValue && correctKeyLength && removeOnlyTree\n\n// Check if the tree is correct, the values have been preserved and the state has changed\nval stateIsCorrect = projectPubKey && treeIsCorrect && valuePreserved && stateChanged\n\n```"
    },
    {
      "heading": "Withdrawal",
      "level": 2,
      "content": "Investors can now withdraw their allocated ICO tokens. The withdrawal process typically happens in batches. A withdrawal transaction spends the current ICO box (`SELF`) and creates `N + 1` outputs:\n*   `OUTPUTS(0)`: The new ICO box, containing the remaining tokens and the updated dictionary digest (with withdrawn entries removed). It is protected by the same `withdrawScript`.\n*   `OUTPUTS(1)` to `OUTPUTS(N)`: Boxes sent to the withdrawing investors. Each box is protected by the investor's script (whose hash was stored as the key in the dictionary) and contains the corresponding amount of ICO tokens.\n\nThe `withdrawScript` requires two AVL tree proofs provided in context variables:\n1.  `lookupProof`: Proves the existence and amounts associated with the investor keys being withdrawn.\n2.  `removeProof`: Proves that these investor entries have been correctly removed from the dictionary, resulting in the updated dictionary digest found in `OUTPUTS(0)`.\n\nThe complete `withdrawScript` is shown below:\n\n```scala\n// Get removeProof and lookupProof\nval removeProof = getVar[Coll[Byte]](2).get\nval lookupProof = getVar[Coll[Byte]](3).get\n\n// Get withdraw indexes and tokenId\nval withdrawIndexes = getVar[Coll[Int]](4).get\nval tokenId: Coll[Byte] = SELF.R4[Coll[Byte]].get\n\n// Map over withdrawIndexes and find tokenIds\nval withdrawals = withdrawIndexes.map({(idx: Int) =>\n    val b = OUTPUTS(idx)\n    if (b.tokens(0)._1 == tokenId)\n        (blake2b256(b.propositionBytes), b.tokens(0)._2)\n    else\n        (blake2b256(b.propositionBytes), 0L)\n    })\n\n// Get withdrawValues and calculate the total amount withdrawn\nval withdrawValues = withdrawals.map({(t: (Coll[Byte], Long)) => t._2})\nval total = withdrawValues.fold(0L, {(l1: Long, l2: Long) => l1 + l2 })\n\n// Get list of nodes to remove and removed values\nval toRemove = withdrawals.map({(t: (Coll[Byte], Long)) => t._1})\nval initialTree = SELF.R5[AvlTree].get\nval removedValues = initialTree.getMany(toRemove, lookupProof).map(\n    {(o: Option[Coll[Byte]]) => byteArrayToLong(o.get)}\n    )\n\n// Check if removedValues equals withdrawValues\nval valuesCorrect = removedValues == withdrawValues\n\n// Remove nodes and check if the outTree is correct\nval modifiedTree = initialTree.remove(toRemove, removeProof).get\nval outTreeCorrect = OUTPUTS(0).R5[AvlTree].get == modifiedTree\n\n// Check if the tokenIds and amounts are correct\nval selfTokenCorrect = SELF.tokens(0)._1 == tokenId\nval outTokenCorrect = OUTPUTS(0).tokens(0)._1 == tokenId\nval outTokenCorrectAmt = OUTPUTS(0).tokens(0)._2 + total == SELF.tokens(0)._2\nval tokenPreserved = selfTokenCorrect && outTokenCorrect && outTokenCorrectAmt\n\n// Check if the SELF and OUTPUTS are correct\nval selfOutputCorrect = OUTPUTS(0).propositionBytes == SELF.propositionBytes\nval outTreeCorrect = OUTPUTS(0).R5[AvlTree].get == modifiedTree\n\n// Check if everything is correct\nvaluesCorrect && outTreeCorrect && selfOutputCorrect && tokenPreserved\n```\n\nNote that the ICO example presented here includes several simplifications. For instance, transaction fees are not explicitly handled in the scripts (though they would be required in a real transaction).\n\nAdditionally, the contract does not include logic for self-destruction or final cleanup after the withdrawal stage is complete."
    },
    {
      "heading": "Comet Refundable ICO",
      "level": 2,
      "content": "Comet has a refundable ICO live at [thecomettoken.com/ICO](https://thecomettoken.com/ICO)\n\nThe contract used is [provided](https://github.com/CometCommunity/CometCommunity/blob/main/RefundableIcoContract):\n\n```scala\n{\n  // Receipt Tokens held in Contract\n  val receiptTokens = SELF.tokens(0)._2\n  // Comet Held in Contract\n  val cometTokens = SELF.tokens(1)._2\n  // Receipt Token Id\n  val receiptId = fromBase58(\"5HWxQHyjjVFNEWtswcc71922Bq84LsmtMbgEG5eNxAKZ\")\n  // Comet Token Id\n  val cometId = fromBase58(\"s9d3vUc6AhNAPZhxnGXCitQFqdAXN6X7gXT3h9GupWE\")\n  // Swap Price\n  val amountToSwap = 15 * (OUTPUTS(0).value - SELF.value) / 100000\n  // Refund Price\n  val amountToRefund = 15 * (SELF.value - OUTPUTS(0).value) / 100000\n\n  // Conditions that are always true\n  val alwaysTrue = allOf(Coll(\n    OUTPUTS(0).propositionBytes == SELF.propositionBytes, // OUTPUT(0) is contract box\n    OUTPUTS(0).R4[Coll[Byte]].get == SELF.id, // Protect against spending two contract boxes of same value in 1 tx.\n    OUTPUTS(0).tokens(0)._1 == receiptId // Contract always holds receipt tokens\n  ))\n\n  // Conditions that depend on spending action\n  val conditionals = if (OUTPUTS(0).value > SELF.value) { // Purchase comet condition\n    allOf(Coll(\n      OUTPUTS(0).tokens(0)._2 >= receiptTokens - amountToSwap, // Unlock value amount of receipt for spending\n      OUTPUTS(0).tokens(1)._1 == cometId,\n      OUTPUTS(0).tokens(1)._2 >= cometTokens - amountToSwap // Unlock value amount of comet for spending\n    ))\n  } else { // Refund comet condition\n    allOf(Coll(\n      OUTPUTS(0).tokens(0)._2 >= receiptTokens + amountToRefund, // Unlock receipt amount of Erg for spending\n      OUTPUTS(0).tokens(1)._1 == cometId,\n      OUTPUTS(0).tokens(1)._2 >= cometTokens + amountToRefund // Unlock comet amount of Erg for spending\n    ))\n  }\n\n  val drainAddressConditions = allOf(Coll(\n    OUTPUTS(0).value == SELF.value,\n    OUTPUTS(0).tokens(0)._2 == receiptTokens, // Cannot withdraw receipt tokens\n    OUTPUTS(0).tokens(1)._1 == cometId,\n    OUTPUTS(0).tokens(1)._2 >= 1 // Free up all comet\n  ))\n\n  val addFunds = alwaysTrue && allOf(Coll(\n    OUTPUTS(0).value >= SELF.value,\n    OUTPUTS(0).tokens(0)._2 == receiptTokens, // Cannot withdraw receipt tokens\n    OUTPUTS(0).tokens(1)._1 == cometId,\n    OUTPUTS(0).tokens(1)._2 >= SELF.tokens(1)._2,\n    OUTPUTS.size == 2 // Requires setup such that no change Box is made\n  ))\n\n  // Define the spending conditions for draining the address\n  val drainAddress = sigmaProp(alwaysTrue && drainAddressConditions && PK(\"9h6Ao31CVSsYisf4pWTM43jv6k3BaXV3jovGfaRj9PrqfYms6Rf\"))\n  // Define the spending conditions before the deadline\n  val beforeDeadline = sigmaProp(alwaysTrue && conditionals)\n  // Define the spending conditions after the deadline\n  val afterDeadline = sigmaProp(PK(\"9h6Ao31CVSsYisf4pWTM43jv6k3BaXV3jovGfaRj9PrqfYms6Rf\") && HEIGHT > 1550468)\n\n  // Combine all spending conditions using logical OR\n  sigmaProp(beforeDeadline || afterDeadline || drainAddress || addFunds)\n}\n```"
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/scs/tx/ico.md",
  "processed_at": "2025-05-11T19:31:53.808882",
  "ai_processed": true
}