{
  "id": "docs_dev_scs_debugging_scala-debugging_md",
  "title": "Scala-Based ErgoScript Debugging",
  "summary": "The document discusses a Scala-based approach to debugging ErgoScript contracts. The key points are:\n\n- ErgoScript is a subset of Scala, so standard Scala debugging tools and techniques can be used to test and debug contract logic off-chain.\n- The process involves representing the contract logic as Scala code, setting up a testing environment, simulating the blockchain context, setting breakpoints, and running the code in debug mode to inspect and step through the logic.\n- The document provides an example reference using the AssetsAtomicExchange.scala tests within the sigmastate-interpreter repository, demonstrating how to set breakpoints and debug the contract logic.\n- This technique allows for thorough verification of contract logic before deployment, catching potential errors in a controlled off-chain environment.",
  "qa_pairs": [
    {
      "question": "What is this document about?",
      "answer": "---\ntags:\n  - Debugging\n  - ErgoScript\n  - Scala\n  - Testing\n  - sigmastate-interpreter\n  - Appkit\n---\n\n# Scala-Based ErgoScript Debugging\n\nSince ErgoScript is a subset of Scala and rigorously tested ..."
    },
    {
      "question": "What is the title of this document?",
      "answer": "Scala-Based ErgoScript Debugging"
    },
    {
      "question": "What is the 'Introduction' section about?",
      "answer": "---\ntags:\n  - Debugging\n  - ErgoScript\n  - Scala\n  - Testing\n  - sigmastate-interpreter\n  - Appkit\n-..."
    },
    {
      "question": "What is the 'Scala-Based ErgoScript Debugging' section about?",
      "answer": "Since ErgoScript is a subset of Scala and rigorously tested for equivalence within the [`sigmastate-..."
    },
    {
      "question": "What is the 'Concept' section about?",
      "answer": "The core idea is to represent your ErgoScript contract logic as Scala code, typically within a testi..."
    }
  ],
  "sections": [
    {
      "heading": "Introduction",
      "level": 0,
      "content": "---\ntags:\n  - Debugging\n  - ErgoScript\n  - Scala\n  - Testing\n  - sigmastate-interpreter\n  - Appkit\n---"
    },
    {
      "heading": "Scala-Based ErgoScript Debugging",
      "level": 1,
      "content": "Since ErgoScript is a subset of Scala and rigorously tested for equivalence within the [`sigmastate-interpreter`](https://github.com/ScorexFoundation/sigmastate-interpreter) repository, you can leverage standard Scala debugging tools and techniques to test and debug your contract logic off-chain."
    },
    {
      "heading": "Concept",
      "level": 2,
      "content": "The core idea is to represent your ErgoScript contract logic as Scala code, typically within a testing environment like ScalaTest or JUnit, often using frameworks like [Appkit](scala.md) or the testing utilities within `sigmastate-interpreter` itself. This allows you to simulate the blockchain context (`Context`, `Box`, `Transaction`, etc.) and execute your contract logic within a standard JVM debugging environment."
    },
    {
      "heading": "Process",
      "level": 2,
      "content": "1.  **Set up a Testing Environment:**\n    *   Use a project based on Appkit, which provides high-level abstractions for context and transaction building.\n    *   Alternatively, work within a fork or local copy of the `sigmastate-interpreter` project, utilizing its internal testing structures and examples.\n2.  **Represent Contract Logic:**\n    *   Write your contract logic as Scala functions or within test case setups that mirror the ErgoScript structure. Appkit's `ErgoContract` compilation or direct use of `SigmaBuilder` can be employed.\n3.  **Simulate Context:**\n    *   Create mock `Context`, `Box`, and `Transaction` objects representing the specific scenario you want to test. Populate input/output boxes, registers, context variables, and blockchain parameters (like `HEIGHT`) as needed.\n4.  **Set Breakpoints:**\n    *   Use your Scala IDE (e.g., IntelliJ IDEA) to set breakpoints within the Scala code representing your contract logic or the test setup code that invokes it.\n5.  **Run in Debug Mode:**\n    *   Execute the specific test case using the IDE's debugger.\n6.  **Inspect and Step Through:**\n    *   When the debugger halts at a breakpoint, you can:\n        *   Inspect the values of variables (including simulated context data).\n        *   Step through the code line by line.\n        *   Evaluate expressions.\n        *   Validate the logic flow and intermediate results."
    },
    {
      "heading": "Example Reference",
      "level": 2,
      "content": "The [AssetsAtomicExchange.scala](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/sigmastate/src/test/scala/sigmastate/utxo/examples/AssetsAtomicExchange.scala) tests within the `sigmastate-interpreter` repository provide practical examples of this pattern. Breakpoints can be set within the `proposition` definitions (which contain Scala code mirroring ErgoScript), and the corresponding tests run in debug mode to step through the logic.\n\n```scala\n// Snippet from AssetsAtomicExchange - Breakpoint can be set inside this block\nlazy val buyerProp = proposition(\"buyer\", { ctx: Context =>\n  import ctx._\n  (HEIGHT > deadline && pkA) || { // Breakpoint here\n    val tokenData = OUTPUTS(0).R2[Coll[(Coll[Byte], Long)]].get(0)\n    // ... inspect tokenData, OUTPUTS(0), SELF, etc. ...\n    val knownId = OUTPUTS(0).R4[Coll[Byte]].get == SELF.id\n    allOf(Coll(\n      tokenData._1 == tokenId,\n      tokenData._2 >= 60L,\n      OUTPUTS(0).propositionBytes == pkA.propBytes,\n      knownId\n    ))\n  }\n},\n// ...\n```"
    },
    {
      "heading": "Debugging Process Example",
      "level": 3,
      "content": "Using the `AssetsAtomicExchange.scala` example:\n\n1.  **Set Breakpoint:** Place a breakpoint within the `buyerProp` or `sellerProp` definition in `AssetsAtomicExchange.scala` (e.g., inside the `||` block as shown in the snippet above).\n2.  **Locate Test:** Find the corresponding test method in [`AssetsAtomicExchangeTests.scala`](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/sigmastate/src/test/scala/sigmastate/utxo/examples/AssetsAtomicExchangeTests.scala), such as `property(\"atomic exchange spec\")`.\n    ```scala\n    // Test method for atomic exchange in AssetsAtomicExchangeTests.scala\n    property(\"atomic exchange spec\") {\n      // Test implementation details...\n      // This code sets up the context and attempts the transaction\n    }\n    ```\n3.  **Run Test in Debug Mode:** Right-click the specific test method (or the whole test class) in your IDE and select \"Debug\".\n4.  **Inspect:** The execution will pause at your breakpoint, allowing you to inspect the state of simulated context variables (`ctx`, `HEIGHT`, `INPUTS`, `OUTPUTS`, `SELF`), local variables (`tokenData`, `knownId`), and step through the contract logic evaluation.\n\nThis technique provides a powerful way to thoroughly verify contract logic before deployment, catching potential errors in a controlled off-chain environment."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/scs/debugging/scala-debugging.md",
  "processed_at": "2025-05-11T19:27:45.356918",
  "ai_processed": true
}