{
  "id": "docs_dev_data-model_structures_merkle_merkle-light-proof_md",
  "title": "Example: Lite Client Checking Merkle Proof",
  "summary": "The document provides an example of how a lite client, such as a decentralized pool, can verify that a specific transaction is included in a block using a Merkle proof. It outlines the steps involved, including transaction creation, the mining process, the components of the share submitted by the miner, and the verification process by the pool. The example code demonstrates how to verify the transaction inclusion using the Merkle proof, and the document explains the key elements of the code. The approach allows lightweight clients to efficiently validate transactions without downloading the entire blockchain, reducing the computational burden and ensuring the integrity and security of the blockchain.",
  "qa_pairs": [
    {
      "question": "What is the purpose of using Merkle Trees in the Ergo blockchain?",
      "answer": "Merkle Trees are utilized for efficient and secure verification of transactions within a block, especially useful for lightweight clients to verify that a specific transaction is included in a block without having to download the entire blockchain."
    },
    {
      "question": "What are the key components of a share submitted by a miner to a decentralized pool?",
      "answer": "The share submitted to the pool consists of: the block header without the PoW solution (msgPreimage), the partial PoW solution, and the Merkle proof that the transaction is included in the block."
    },
    {
      "question": "What are the steps a decentralized pool would use to verify the validity of a share submitted by a miner?",
      "answer": "The pool verifies the validity of the share by: 1) Checking that the combination of msgPreimage and the partial PoW solution forms a valid block header with sufficient difficulty, and 2) Using the Merkle proof to verify that the transaction is indeed included in the block."
    },
    {
      "question": "How can the decentralized pool use the Merkle proof to verify that a transaction is included in the block?",
      "answer": "The pool can use the Merkle proof, which consists of the hash of the transaction (txId) and the Merkle root extracted from the msgPreimage, to verify that the transaction is included in the block."
    },
    {
      "question": "What is the practical application of the Merkle proof verification process for a decentralized pool?",
      "answer": "The Merkle proof verification process can be particularly valuable for decentralized mining pools with collateral, where the pool checks shares from miners to ensure that a corresponding block contains a specific transaction, such as one that pays out to the pool."
    }
  ],
  "sections": [
    {
      "heading": "Introduction",
      "level": 0,
      "content": "---\ntags:\n    - Merkle\n---"
    },
    {
      "heading": "Example: Lite Client Checking Merkle Proof",
      "level": 1,
      "content": "In the Ergo blockchain, Merkle Trees are utilized for efficient and secure verification of transactions within a block. This capability is especially useful in scenarios where a lightweight client, such as a decentralized pool, needs to verify that a specific transaction is included in a block without having to download the entire blockchain.\n\nThis page provides a comprehensive example of how a lite client can check a Merkle-tree-based membership proof against an incomplete header, which lacks a full proof-of-work (PoW) solution. This method can be particularly valuable for decentralized mining pools with collateral, where the pool checks shares from miners to ensure that a corresponding block contains a specific transaction, such as one that pays out to the pool."
    },
    {
      "heading": "Use Case",
      "level": 3,
      "content": "Consider a scenario where a miner submits a share to a decentralized pool. The share includes:\n\n- A block header without a PoW solution\n- A partial PoW solution\n- A Merkle proof demonstrating that a transaction is included in the block\n\nThe pool needs to verify the following:\n\n1. The header, when combined with the partial PoW solution, meets the required difficulty level.\n2. The Merkle proof accurately proves that the transaction is included in the block."
    },
    {
      "heading": "Steps to Verify a Merkle Proof",
      "level": 3,
      "content": "The following steps outline the process a lite client (such as a decentralized pool) would use to verify a share submitted by a miner:\n\n1. **Transaction Creation**:\n     - The miner creates a transaction that pays out to the pool and includes it in a block candidate.\n\n2. **Mining Process**:\n     - The miner attempts to mine the block. If successful, the miner posts the transaction to the network. If the miner's partial PoW solution does not meet the full difficulty for a block but is sufficient for a share, the miner can submit the share to the pool.\n\n3. **Share Components**:\n     - The share submitted to the pool consists of:\n         - The block header without the PoW solution (`msgPreimage`).\n         - The partial PoW solution.\n         - The Merkle proof that the transaction is included in the block.\n\n4. **Verification by the Pool**:\n     - The pool verifies the validity of the share by:\n         1. Checking that the combination of `msgPreimage` and the partial PoW solution forms a valid block header with sufficient difficulty.\n         2. Using the Merkle proof to verify that the transaction is indeed included in the block."
    },
    {
      "heading": "Example Code",
      "level": 3,
      "content": "The following code demonstrates how to perform step 4b: verifying that a transaction is included in the block header using a Merkle proof.\n\n```scala\npackage org.ergoplatform.examples\n\nimport org.ergoplatform.utils.ErgoPropertyTest\nimport scorex.crypto.authds.merkle.MerkleProof\nimport scorex.crypto.authds.{LeafData, Side}\nimport scorex.crypto.hash.{Blake2b256, Digest32}\nimport scorex.util.encode.Base16\n\nclass LiteClientExamples extends ErgoPropertyTest {\n\n    property(\"Example client code for tx proof\") {\n        implicit val hashFn: Blake2b256.type = Blake2b256\n\n        // The msgPreimage is the block header without the PoW solution\n        val msgPreimageBase16 = \"01fb9e35f8a73c128b73e8fde5c108228060d68f11a69359ee0fb9bfd84e7ecde6d19957ccbbe75b075b3baf1cac6126b6e80b5770258f4cec29fbde92337faeec74c851610658a40f5ae74aa3a4babd5751bd827a6ccc1fe069468ef487cb90a8c452f6f90ab0b6c818f19b5d17befd85de199d533893a359eb25e7804c8b5d7514d784c8e0e52dabae6e89a9d6ed9c84388b228e7cdee09462488c636a87931d656eb8b40f82a507008ccacbee05000000\"\n        val msgPreimage = Base16.decode(msgPreimageBase16).get\n\n        // The hash of msgPreimage should be equal to the msg value\n        val msg = \"6cb37d0a202bc2984f43de003cbc5558804db45798d0fc8faae7390b96d42d15\"\n        assert(Base16.encode(hashFn(msgPreimage)) == msg)\n\n        // Extract the transactions Merkle root from the msgPreimage\n        val txsRoot = msgPreimage.slice(65, 97)\n\n        // The txId represents the leaf node in the Merkle tree\n        val txId = \"642c15c62553edd8fd9af9a6f754f3c7a6c03faacd0c9b9d5b7d11052c6c6fe8\"\n\n        // Merkle proof encoded as a sequence of bytes\n        val levelsEncoded = Seq(\"0139b79af823a92aa72ced2c6d9e7f7f4687de5b5af7fab0ad205d3e54bda3f3ae\")\n        val levels = levelsEncoded.map { le =>\n            val leBytes = Base16.decode(le).get\n            val side: Byte = leBytes.head\n            val digest = leBytes.tail\n            (Digest32 @@ digest, Side @@ side)\n        }\n\n        // Construct the Merkle proof using the leaf data and levels\n        val merkleProof = MerkleProof[Digest32](LeafData @@ Base16.decode(txId).get, levels)\n\n        // Validate the Merkle proof against the transactions root\n        assert(merkleProof.valid(Digest32 @@ txsRoot))\n    }\n}\n```"
    },
    {
      "heading": "Explanation of the Code",
      "level": 3,
      "content": "- **msgPreimage**: The block header without the PoW solution is called `msgPreimage`. The header hash (`msg`) is computed from `msgPreimage`.\n- **txsRoot**: The Merkle root of the transactions included in the block is extracted from `msgPreimage`.\n- **txId**: This represents the transaction ID that needs to be verified.\n- **Merkle Proof Levels**: The proof consists of the `txId` and the hashes of the intermediate nodes in the Merkle Tree (`levels`). Each level indicates whether the computed value is on the left or right of the sibling node.\n- **Verification**: The proof is validated by recalculating the Merkle root from the `txId` and comparing it with `txsRoot`."
    },
    {
      "heading": "Conclusion",
      "level": 3,
      "content": "This example demonstrates how to verify that a specific transaction is included in a block using a Merkle proof in the context of a lite client. By following the steps outlined above, decentralized mining pools or other lightweight clients can efficiently validate transactions without downloading the entire blockchain. This approach not only reduces the computational burden but also ensures the integrity and security of the blockchain.\n\nFor further details, explore the [LiteClientExamples.scala](https://github.com/ergoplatform/ergo/blob/85dfd1a39700ef4ff6a45766fc103e624873f652/src/test/scala/org/ergoplatform/examples/LiteClientExamples.scala#L11) in the Ergo GitHub repository."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/data-model/structures/merkle/merkle-light-proof.md",
  "processed_at": "2025-05-11T19:20:39.230900",
  "ai_processed": true
}