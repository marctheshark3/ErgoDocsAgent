{
  "id": "docs_dev_scs_ergotree_evaluation_md",
  "title": "ErgoTree Evaluation",
  "summary": "The document presents the evaluation semantics of the ErgoTree language, which is specified by its translation to the Core-\u03bb language. The Core-\u03bb language is a subset of the ErgoTree language and its typing rules form a subset of the typing rules of ErgoTree. The evaluation semantics of Core-\u03bb is based on call-by-value lambda calculus and is specified using denotational semantics. The document defines the values of the Core-\u03bb language and explains the denotational semantics, where each type denotes a set whose elements are the denotations of values of that type.",
  "qa_pairs": [
    {
      "question": "What is the purpose of specifying the evaluation semantics of ErgoTree by translating it to Core-\u03bb?",
      "answer": "The evaluation of ErgoTree is specified by translating it to Core-\u03bb, whose terms form a subset of ErgoTree terms. The typing rules of Core-\u03bb form a subset of the typing rules of ErgoTree."
    },
    {
      "question": "What is the basis for the evaluation semantics of Core-\u03bb?",
      "answer": "The evaluation semantics of Core-\u03bb is based on call-by-value (CBV) lambda calculus."
    },
    {
      "question": "How is the denotational semantics of Core-\u03bb specified?",
      "answer": "The denotational semantics of Core-\u03bb is specified by first defining the denotations of types, then the denotations of typed terms, and finally the equations of denotational semantics."
    },
    {
      "question": "What is the purpose of the definitions and notations introduced in the document?",
      "answer": "The definitions and notations introduced (such as TEnv, Der, DerV, DerC, DerEnv, DerEnvV, DerEnvC, lst, Tup, Apply, MSig, Ov, TyLam, Trait, To, Low, Lam, IfThenElse, False, True, langname, corelang, Denot) are used to specify the evaluation semantics of ErgoTree by translating it to Core-\u03bb."
    },
    {
      "question": "What is the relationship between the typing rules of ErgoTree and Core-\u03bb?",
      "answer": "The typing rules of Core-\u03bb form a subset of the typing rules of ErgoTree, as Core-\u03bb terms form a subset of ErgoTree terms."
    }
  ],
  "sections": [
    {
      "heading": "ErgoTree Evaluation",
      "level": 1,
      "content": "$$\n\\newcommand{\\TEnv}{\\Gamma}\n\\newcommand{\\Der}[2]{#1~\\vdash~#2}\n\\newcommand{\\DerV}[2]{#1~\\vdash^{\\text{\\lst{v}}}~#2}\n\\newcommand{\\DerC}[2]{#1~\\vdash^{\\text{\\lst{c}}}~#2}\n\\newcommand{\\DerEnv}[1]{\\Der{\\TEnv}{#1}}\n\\newcommand{\\DerEnvV}[1]{\\DerV{\\TEnv}{#1}}\n\\newcommand{\\DerEnvC}[1]{\\DerC{\\TEnv}{#1}}\n\\newcommand{\\lst}[1]{#1}\n\\newcommand{\\Tup}[1]{(#1)}\n\\newcommand{\\Apply}[2]{#1\\langle#2\\rangle}\n\\newcommand{\\MSig}[3]{\\text{def}~#1(#2): #3}\n\\newcommand{\\Ov}[1]{\\overline{#1}}\n\\newcommand{\\TyLam}[3]{\\lambda(\\Ov{#1:#2}).#3}\n\\newcommand{\\Trait}[2]{\\text{trait}~#1~\\{ #2 \\}}\n\\newcommand{\\To}{\\mapsto}\n\\newcommand{\\Low}[1]{\\mathcal{L}{[\\![#1]\\!]}}\n\\newcommand{\\Lam}[2]{\\lambda#1.#2}\n\\newcommand{\\IfThenElse}[3]{\\text{if}~(#1)~#2~\\text{else}~#3}\n\\newcommand{\\False}{\\text{false}}\n\\newcommand{\\True}{\\text{true}}\n\\newcommand{\\langname}{ErgoTree}\n\\newcommand{\\corelang}{Core-\\lambda}\n\\newcommand{\\Denot}[1]{[\\![#1]\\!]}  \n$$\n\n\nEvaluation of $\\langname$ is specified by its translation to $\\corelang$, whose terms form a subset of $\\langname$ terms. Thus, typing rules of $\\corelang$ form a subset of typing rules of $\\langname$.\n\nHere we specify evaluation semantics of $\\corelang$, which is based on call-by-value (CBV) lambda calculus. Evaluation of $\\corelang$ is specified using denotational semantics. To do that, we first specify denotations of types, then typed terms and then equations of denotational semantics.\n\n\n/// details | Definition 1\n    {type: note, open: true}\n\n**The following $\\corelang$ terms are called values:**\n\n$$V :== x \\mid C(d, T) \\mid \\Lam{x}{M}$$\n\nAll $\\corelang$ terms are called ***producers***. (This is because, when evaluated, they produce a value.)\n\n///\n\n\nWe now describe and explain a denotational semantics for the $\\corelang$ language. The key principle is that each type $A$ denotes a set $\\Denot{A}$ whose elements are the denotations of values of the type $A$.\n\nThus the type [$\\lst{Boolean}$](types.md#boolean) denotes the 2-element set $\\{\\lst{true},\\lst{false}\\}$, because there are two values of type $\\lst{Boolean}$. Likewise the type $(T_1,\\dots,T_n)$ denotes $(\\Denot{T_1},\\dots,\\Denot{T_n})$ because a value of type $(T_1,\\dots,T_n)$ must be of the form $(V_1,\\dots,V_n)$, where each $V_i$ is value of type $T_i$.\n\nGiven a value $V$ of type $A$, we write $\\Denot{V}$ for the element of $A$ that it denotes. Given a close term $M$ of type $A$, we recall that it produces a value $V$ of type $A$. So $M$ will denote an element $\\Denot{M}$ of $\\Denot{A}$.\n\nA value of type $A \\to B$ is of the form $\\Lam{x}{M}$. This, when applied to a value of type $A$ gives a value of type $B$. So $A \\to B$ denotes $\\Denot{A} \\to \\Denot{B}$. It is true that the syntax appears to allow us to apply $\\Lam{x}{M}$ to any term $N$ of type $A$. But $N$ will be evaluated before it interracts with $\\Lam{x}{M}$, so $\\Lam{x}{M}$ is really only applied to the value that $N$ produces.\n\n/// details | Definition 2\n    {type: note, open: true}\nA **context** $\\Gamma$ is a finite sequence of identifiers with valuetypes $x_1:A_1, \\dots ,x_n:A_n$. Sometimes we omit the identifiers and write $\\Gamma$ as a list of value types.\n///\n\n\n\n- Given a context $\\Gamma = x_1:A_1,\\dots,x_n:A_n$, an environment (list of bindings for identifiers) associates to each $x_i$ as value of type $A_i$. So the environment denotes an element of $(\\Denot{A_1},\\dots,\\Denot{A_n})$, and we write $\\Denot{\\Gamma}$ for this set.\n- Given a $\\corelang$ term $\\DerEnv{M: B}$, we see that $M$, together with environment, gives a closed term of type $B$. So $M$ denotes a function $\\Denot{M}$ from $\\Denot{\\Gamma}$ to $\\Denot{B}$.\n\nIn summary, the denotational semantics is organized as follows.\n\n- A type $A$ denotes a set $\\Denot{A}$\n- A context $x_1:A_1,\\dots,x_n:A_n$ denotes the set $(\\Denot{A_1},\\dots,\\Denot{A_n})$\n- A term $\\DerEnv{M: B}$ denotes a function $\\Denot{M}$: $\\Denot{\\Gamma} \\to \\Denot{B}$\n\n\nThe denotations of $\\corelang$ **types**\n\n\n$$\\Denot{\\lst{Boolean}}  =  \\{ \\lst{true}, \\lst{false} \\}$$  \n\n$$\\Denot{\\lst{P}}  = \\text{see set of values in Appendix A}$$\n\n$$\\Denot{(T_1,\\dots,T_n)} =  (\\Denot{T_1},\\dots,\\Denot{T_n}) $$\n\n$$\\Denot{A \\to B}  =  \\Denot{A} \\to \\Denot{B}$$\n\nThe denotations of $\\corelang$ **terms** which together specify the function $\\Denot{\\_}: \\Denot{\\Gamma} \\to \\Denot{T}$\n\n\n$$\\Apply{ \\Denot{\\lst{x}}\t\t\t}{(\\rho,\\lst{x}\\mapsto x, \\rho')} = x$$\n\n$$\\Apply{ \\Denot{C(d, T)} \t\t\t}{\\rho}  =  d$$\n\n$$\\Apply{ \\Denot{(\\Ov{M_i})} \t\t}{\\rho}  =  (\\Ov{ \\Apply{\\Denot{M_i}}{\\rho} })$$\n\t\n\n$$\\Apply{ \\Denot{\\Apply{\\delta}{N}} }{\\rho}  = \\Apply{ (\\Apply{\\Denot{\\delta}}{\\rho}) }{ v }~where~v = \\Apply{\\Denot{N}}{\\rho}$$\n\n$$\\Apply{ \\Denot{\\Lam{\\lst{x}}{M}}\t}{\\rho}  =  \\Lam{x}{ \\Apply{\\Denot{M}}{(\\rho, \\lst{x}\\mapsto x)} }$$\t\n\n$$\\Apply{ \\Denot{\\Apply{M_f}{N}}\t}{\\rho}  =  \\Apply{ (\\Apply{\\Denot{M_f}}{\\rho}) }{ v }~where~v = \\Apply{\\Denot{N}}{\\rho}$$\n\n$$\\Apply{ \\Denot{\\Apply{M_I.\\lst{m}}{\\Ov{N_i}} }\t}{\\rho}  =  \\Apply{ (\\Apply{\\Denot{M_I}}{\\rho}).m }{ \\Ov{v_i} }~where~\\Ov{v_i = \\Apply{\\Denot{N_i}}{\\rho}}$$"
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/scs/ergotree/evaluation.md",
  "processed_at": "2025-05-11T19:29:40.045038",
  "ai_processed": true
}