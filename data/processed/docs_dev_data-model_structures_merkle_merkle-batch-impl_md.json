{
  "id": "docs_dev_data-model_structures_merkle_merkle-batch-impl_md",
  "title": "Using Merkle Batch Proofs on Ergo",
  "summary": "The document discusses the use of Merkle Batch Proofs on the Ergo blockchain. It provides an overview of the current state of Merkle Tree and Batch Proof support in the Ergo ecosystem, highlighting that while the `sigma-rust` library fully supports these features, integration into the core `sigmastate-interpreter` is still in progress. The document then presents step-by-step guides for using Merkle Batch Proofs in both Rust-based and JVM-based Ergo applications, covering the creation of Merkle Trees, generation of Batch Proofs, proof verification, and serialization/deserialization.",
  "qa_pairs": [
    {
      "question": "What is the purpose of Merkle Batch Proofs in Ergo?",
      "answer": "Merkle Batch Proofs can enhance efficiency in various blockchain operations, such as proof-of-transaction and securing extension block data."
    },
    {
      "question": "What library provides support for Merkle Trees and Batch Proofs in Ergo?",
      "answer": "The `sigma-rust` library provides comprehensive tools to create, manage, and verify Merkle Batch Proofs in Rust-based Ergo applications."
    },
    {
      "question": "What are the steps to set up the environment for working with Merkle Batch Proofs in `sigma-rust`?",
      "answer": "The steps are: 1. Clone the `sigma-rust` repository, 2. Install Rust, and 3. Build the project."
    },
    {
      "question": "How do you create a Merkle Tree using the `sigma-rust` library?",
      "answer": "You create a Merkle Tree using the `MerkleTree` structure provided by the `sigma-rust` library, and pass in a vector of `MerkleNode` instances."
    },
    {
      "question": "Where can you find the implementation of the `MerkleTree` structure in the `sigma-rust` library?",
      "answer": "The `MerkleTree` structure is implemented in the `merkletree.rs` file of the `sigma-rust` library."
    }
  ],
  "sections": [
    {
      "heading": "Using Merkle Batch Proofs on Ergo",
      "level": 1,
      "content": ""
    },
    {
      "heading": "Overview",
      "level": 2,
      "content": "While full support for Merkle Trees and Batch Proofs is available in the `sigma-rust` library, which is extensively used in Rust-based Ergo applications, integration into the core JVM-based `sigmastate-interpreter` for direct use within ErgoScript remains in progress. There is an open issue in the `sigmastate-interpreter` repository to support Merkle Trees natively, which would allow for direct handling of static data within ErgoScript, enhancing efficiency in various blockchain operations, such as proof-of-transaction and securing extension block data.\n\nUntil this feature is fully integrated into `sigmastate-interpreter`, developers working in JVM-based environments can leverage `scrypto`, which provides essential cryptographic functionalities, including Merkle Tree management and Batch Proof generation and verification.\n\nFor more details on the ongoing integration efforts, you can refer to the [GitHub issue #296](https://github.com/ergoplatform/ergo/issues/296) in the Ergo repository.\n\nNow, let's delve into the practical steps of using Merkle Batch Proofs in Ergo."
    },
    {
      "heading": "Using Sigma-Rust for Rust-based Applications",
      "level": 2,
      "content": "The `sigma-rust` library provides comprehensive tools to create, manage, and verify Merkle Batch Proofs in Rust-based Ergo applications. Below is a step-by-step guide with code examples."
    },
    {
      "heading": "Step 1: Setting Up the Environment",
      "level": 4,
      "content": "Before you begin working with Merkle Batch Proofs in `sigma-rust`, ensure your environment is properly set up:\n\n1. **Clone the Sigma-Rust Repository**:\n   ```bash\n   git clone https://github.com/ergoplatform/sigma-rust.git\n   cd sigma-rust\n   ```\n\n2. **Install Rust**: \n   Follow the instructions on [rust-lang.org](https://www.rust-lang.org/tools/install) to install Rust if you haven't done so.\n\n3. **Build the Project**:\n   ```bash\n   cargo build\n   ```"
    },
    {
      "heading": "Step 2: Creating a Merkle Tree",
      "level": 4,
      "content": "First, create a Merkle tree using the `MerkleTree` structure provided by the `sigma-rust` library.\n\n```rust\nuse sigma_merkle_tree::merkletree::MerkleTree;\nuse sigma_merkle_tree::MerkleNode;\n\nfn create_merkle_tree() {\n    let data_1 = [1u8; 32];\n    let data_2 = [2u8; 32];\n    let data_3 = [3u8; 32];\n\n    let node_1 = MerkleNode::from_bytes(data_1);\n    let node_2 = MerkleNode::from_bytes(data_2);\n    let node_3 = MerkleNode::from_bytes(data_3);\n\n    let tree = MerkleTree::new(vec![node_1, node_2, node_3]);\n    println!(\"Merkle Root: {:?}\", tree.root_hash());\n}\n```\n\n**Code Reference**: The `MerkleTree` structure is implemented in the [`merkletree.rs`](https://github.com/ergoplatform/sigma-rust/blob/develop/ergo-merkle-tree/src/merkletree.rs) file."
    },
    {
      "heading": "Step 3: Generating a Batch Merkle Proof",
      "level": 4,
      "content": "Once the Merkle tree is created, you can generate a batch Merkle proof for specific leaves. This proof can be used to verify the inclusion of multiple elements.\n\n```rust\nuse sigma_merkle_tree::batchmerkleproof::BatchMerkleProof;\n\nfn generate_batch_merkle_proof(tree: &MerkleTree) {\n    let proof = tree.proof_by_indices(&[0, 2]).unwrap();\n    println!(\"Batch Merkle Proof: {:?}\", proof);\n}\n```\n\n**Code Reference**: The `BatchMerkleProof` structure and its methods are implemented in the [`batchmerkleproof.rs`](https://github.com/ergoplatform/sigma-rust/blob/develop/ergo-merkle-tree/src/batchmerkleproof.rs) file."
    },
    {
      "heading": "Step 4: Verifying the Batch Merkle Proof",
      "level": 4,
      "content": "The generated proof can be verified against the Merkle root to ensure that the specified leaves are indeed part of the tree.\n\n```rust\nfn verify_batch_merkle_proof(tree: &MerkleTree, proof: &BatchMerkleProof) {\n    assert!(proof.valid(tree.root_hash().as_ref()));\n    println!(\"Proof is valid.\");\n}\n```"
    },
    {
      "heading": "Step 5: Serialization and Deserialization",
      "level": 4,
      "content": "Merkle batch proofs can be serialized and deserialized for storage or transmission, which is crucial for many blockchain applications where proofs are shared between nodes or stored for future verification.\n\n```rust\nuse sigma_ser::ScorexSerializable;\n\nfn serialize_and_deserialize_proof(proof: &BatchMerkleProof) {\n    let serialized_proof = proof.scorex_serialize_bytes().unwrap();\n    let deserialized_proof = BatchMerkleProof::scorex_parse_bytes(&serialized_proof).unwrap();\n    \n    assert_eq!(proof, &deserialized_proof);\n    println!(\"Serialization and deserialization successful.\");\n}\n```"
    },
    {
      "heading": "Using Scrypto for JVM-based Applications",
      "level": 2,
      "content": "For JVM-based applications, `scrypto` provides similar functionalities to `sigma-rust`. It works closely with the `sigmastate-interpreter` to handle cryptographic operations, including Merkle Trees and Batch Proofs."
    },
    {
      "heading": "Step 1: Setting Up the Environment",
      "level": 4,
      "content": "To work with `scrypto`, follow these steps:\n\n1. **Clone the Scrypto Repository**:\n   ```bash\n   git clone https://github.com/input-output-hk/scrypto.git\n   cd scrypto\n   ```\n\n2. **Ensure Scala and SBT Are Installed**: \n   You can install Scala and SBT by following the instructions on [scala-lang.org](https://www.scala-lang.org/download/).\n\n3. **Build the Project**:\n   ```bash\n   sbt compile\n   ```"
    },
    {
      "heading": "Step 2: Creating a Merkle Tree",
      "level": 4,
      "content": "The Merkle Tree can be constructed using the `MerkleTree` class in Scrypto, similarly to how it's done in Rust.\n\n```scala\nimport scorex.crypto.authds.merkle.MerkleTree\nimport scorex.crypto.authds.LeafData\nimport scorex.crypto.hash.Blake2b256\n\nimplicit val hf = Blake2b256\n\nval leafData = Seq.fill(5)(LeafData @@ scorex.utils.Random.randomBytes(32))\nval tree = MerkleTree(leafData)\nprintln(s\"Merkle Root: ${hf.encode(tree.rootHash)}\")\n```\n\n**Code Reference**: The `MerkleTree` class is implemented in the [`MerkleTree.scala`](https://github.com/input-output-hk/scrypto/blob/master/shared/src/main/scala/scorex/crypto/authds/merkle/MerkleTree.scala) file."
    },
    {
      "heading": "Step 3: Generating a Batch Merkle Proof",
      "level": 4,
      "content": "In Scrypto, you can generate a batch Merkle proof by specifying the indices of the leaves you want to prove.\n\n```scala\nimport scorex.crypto.authds.merkle.{BatchMerkleProof, Leaf}\n\nval batchProof = tree.proofByIndices(Seq(0, 2)).get\nprintln(s\"Batch Merkle Proof: $batchProof\")\n```\n\n**Code Reference**: The `BatchMerkleProof` class and its methods are implemented in the [`BatchMerkleProof.scala`](https://github.com/input-output-hk/scrypto/blob/master/shared/src/main/scala/scorex/crypto/authds/merkle/BatchMerkleProof.scala) file."
    },
    {
      "heading": "Step 4: Verifying the Batch Merkle Proof",
      "level": 4,
      "content": "You can then verify the generated proof to ensure that the elements are part of the Merkle tree.\n\n```scala\nval isValid = batchProof.valid(tree.rootHash)\nprintln(s\"Batch Merkle Proof is valid: $isValid\")\n```"
    },
    {
      "heading": "Step 5: Serialization and Deserialization",
      "level": 4,
      "content": "To serialize and deserialize the proof, Scrypto provides dedicated classes and methods, ensuring the proof can be efficiently stored or transmitted.\n\n```scala\nimport scorex.crypto.authds.merkle.serialization.BatchMerkleProofSerializer\n\nval serializer = new BatchMerkleProofSerializer[Digest32, Blake2b256.type]\nval serializedProof = serializer.serialize(batchProof)\nval deserializedProof = serializer.deserialize(serializedProof).get\n\nassert(batchProof == deserializedProof)\nprintln(\"Serialization and deserialization successful.\")\n```\n\n**Code Reference**: The `BatchMerkleProofSerializer` class is implemented in the [`BatchMerkleProofSerializer.scala`](https://github.com/input-output-hk/scrypto/blob/master/shared/src/main/scala/scorex/crypto/authds/merkle/serialization/BatchMerkleProofSerializer.scala) file."
    },
    {
      "heading": "Example: End-to-End Workflow in Scrypto",
      "level": 3,
      "content": "Here\u2019s an example tying together all the steps in Scrypto:\n\n```scala\nimport scorex.crypto.authds.merkle.{MerkleTree, Leaf, BatchMerkleProof}\nimport scorex.crypto.authds.merkle.serialization.BatchMerkleProofSerializer\nimport scorex.crypto.hash.Blake2b256\nimport scorex.crypto.hash.Digest32\n\nimplicit val hf = Blake2b256\n\n// Create the Merkle tree\nval leafData = Seq.fill(5)(LeafData @@ scorex.utils.Random.randomBytes(32))\nval tree = MerkleTree(leafData)\n\n// Generate the batch Merkle proof\nval batchProof = tree.proofByIndices(Seq(0, 2)).get\n\n// Verify the proof\nval isValid = batchProof.valid(tree.rootHash)\nprintln(s\"Batch Merkle Proof is valid: $isValid\")\n\n// Serialize and deserialize the proof\nval serializer = new BatchMerkleProofSerializer[Digest32, Blake2b256.type]\nval serializedProof = serializer.serialize(batchProof)\nval deserializedProof = serializer.deserialize(serializedProof).get\n\nassert(batchProof == deserializedProof)\nprintln(\"Serialization and deserialization successful.\")\n```"
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/data-model/structures/merkle/merkle-batch-impl.md",
  "processed_at": "2025-05-11T19:20:12.590777",
  "ai_processed": true
}