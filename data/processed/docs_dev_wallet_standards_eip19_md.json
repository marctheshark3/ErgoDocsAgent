{
  "id": "docs_dev_wallet_standards_eip19_md",
  "title": "EIP-0019 Cold Wallet: an interaction protocol between Hot and Cold mobile wallets",
  "summary": "This EIP defines a standard for interaction between \"Hot\" (online) and \"Cold\" (offline) mobile wallets for signing Ergo transactions. It addresses the \"cold signing problem\" where the full transaction context required for signing cannot be transferred to the cold wallet due to size limitations. The solution is to use a \"ReducedTransaction\" data structure that contains only the minimum information required for the cold wallet to generate the signature. The EIP also defines a transaction interchange format using ColdSigningRequest and ColdSigningResponse to securely transfer data between the hot and cold wallets. The benefits include improved security by isolating private keys on a cold device, and a universal protocol for cross-device interaction.",
  "qa_pairs": [
    {
      "question": "What is the purpose of EIP-0019 Cold Wallet?",
      "answer": "EIP-0019 Cold Wallet defines a standard for cross-device interaction between \"Hot\" (online) and \"Cold\" (offline) wallets for signing Ergo transactions."
    },
    {
      "question": "What is the motivation behind the Cold Wallet protocol?",
      "answer": "The motivation is to provide a more secure way to store private keys by using a specialized \"Cold\" wallet device that is not connected to the internet, in order to prevent hacking and data theft."
    },
    {
      "question": "How can a Cold Wallet device interact with a Hot Wallet?",
      "answer": "The interaction between the Cold Wallet and Hot Wallet can be done via QR codes (in case of mobile devices) or by transferring files (in case of Raspberry Pi)."
    },
    {
      "question": "What is the \"Cold Signing Problem\" that the protocol addresses?",
      "answer": "The Cold Signing Problem refers to the challenge of securely signing transactions on a Cold Wallet device that is not connected to the internet."
    },
    {
      "question": "What are the key benefits of the EIP-0019 Cold Wallet protocol?",
      "answer": "The key benefits include improved security by storing private keys on a dedicated Cold Wallet device, and a standardized protocol for interaction between Hot and Cold wallets."
    }
  ],
  "sections": [
    {
      "heading": "Introduction",
      "level": 0,
      "content": "---\ntags:\n  - EIP\n---"
    },
    {
      "heading": "EIP-0019 Cold Wallet: an interaction protocol between Hot and Cold mobile wallets",
      "level": 1,
      "content": "> \ud83d\udd17 From [EIP-0019](https://github.com/ergoplatform/eips/blob/master/eip-0019.md)\n\n* Author: @MrStahlfelge,@aslesarenko\n* Status: Proposed\n* Created: 18-August-2021\n* License: CC0\n* Forking: not needed"
    },
    {
      "heading": "Contents",
      "level": 2,
      "content": "- [EIP-0019 Cold Wallet: an interaction protocol between Hot and Cold mobile wallets](#eip-0019-cold-wallet-an-interaction-protocol-between-hot-and-cold-mobile-wallets)\n  - [Contents](#contents)\n  - [Description](#description)\n  - [Background And Motivation](#background-and-motivation)\n  - [Cold Signing Problem](#cold-signing-problem)\n  - [Simplified Signing using ReducedTransaction](#simplified-signing-using-reducedtransaction)\n  - [Transaction Interchange](#transaction-interchange)\n    - [ColdSigningRequest](#coldsigningrequest)\n    - [ColdSigningResponse:](#coldsigningresponse)\n    - [Interchange format](#interchange-format)\n  - [Reference Implementation of Hot Wallet](#reference-implementation-of-hot-wallet)\n  - [Reference Implementation of Cold Wallet](#reference-implementation-of-cold-wallet)\n  - [Benefits](#benefits)"
    },
    {
      "heading": "Description",
      "level": 2,
      "content": "This EIP defines a standard for cross-device interaction between \"Hot\" (online)\nand \"Cold\" (offline) wallets for signing Ergo transactions."
    },
    {
      "heading": "Background And Motivation",
      "level": 2,
      "content": "Mobile wallets (like [Ergo Android\nWallet](https://github.com/MrStahlfelge/ergo-wallet-android)) typically store\nprivate keys (aka mnemonics) on the device.\n\nHowever, modern mobile OSes (Android, iOS) as well as desktop PCs are always connected to the internet\nand can be\n[hacked](https://latesthackingnews.com/2021/07/30/apple-patched-zero-day-bug-under-attack-for-mac-and-ios-devices/)\nand secrets [stolen](https://latesthackingnews.com/2021/07/06/numerous-trojanized-android-apps-caught-stealing-users-facebook-credentials/).\nScreenreading and keystroke logging are system-independant ways to steal user data.\n\nThat is why specialized [hardware wallets](https://www.ledger.com/) are\nconsidered much more secure to store private keys.\n\nAnother option for more security is to use \"Cold\" wallet - a device which is not connected\nto the internet or better, with all connectivity turned-off and internet access blocked.\nCandidates could be outdated (but still functioning) mobile devices with clean\nfactory setup or a Raspberry Pi with a fresh Raspbian setup and only Cold Wallet application installed.\nAs long as the device never connects to the internet, it is guaranteed that no secrets left the device.\n\nInteraction with the Cold Wallet device can be done via QR codes (in case of mobile devices)\nor by transferring files (in case of Raspberry Pi). For simplicity, only QR code is mentioned in the \nfollowing text. This does not mean any restriction of the transportation method.\n\n- A user creates a transaction in the Hot Wallet application and then presses a \"Sign With Cold Wallet\" button\n- The Hot Wallet application shows a QR code with serialized transaction bytes on the screen\n- User scans the QR code using the Cold Wallet device, signs the transaction after which QR code of the signed transaction is displayed.\n- Then user scans the QR code of the signed transaction and sends it to blockchain.\n\nThe design of Ergo contracts allows for a simple and universal implementation\nwhich we describe in [Reference Implementation](#reference-implementation-of-hot-wallet)\nsection.\n\nIn the following sections we:\n\n- describe the main problem we need to solve; \n- describe a solution;  \n- specify a protocol with two roles: HotWallet and ColdWallet which must be implemented by complying Wallet applications and \n- describe a reference implementation of both Hot and Cold roles in [Ergo Wallet for Android](https://github.com/MrStahlfelge/ergo-wallet-android)."
    },
    {
      "heading": "Cold Signing Problem",
      "level": 2,
      "content": "In the Ergo's eUTXO model a box can be protected by an arbitrary complex\ncontract (aka spending condition) and the spending transaction should satisfy\nthat condition by adding required context variables, creating expected number of\noutputs with specific [registers](registers.md) etc. i.e. a special data structure called\n`Context`. The Context should be created for each input of the transaction\nand then passed to the Prover which will generate a signature for that input.\nSee [general overview of signing and\nverification](https://github.com/ScorexFoundation/sigmastate-interpreter#sigma-language-background)\nprocess in Ergo for details.\n\nIn general, the Context represents the current state of the blockchain and\nincludes current header, previous 10 headers, current height etc. This data can\nbe retrieved from blockchain nodes. This is possible on Hot Wallet device, but\nis not possible on Cold Wallet device (there is no network connection).\n\nAt the same time the prover need to know both the Context data and the private\nkeys, which are stored on the Cold Wallet device, and so the Prover must run on\nthe Cold Wallet device.\n\nAnd finally, which is the problem, we cannot transfer unsigned transaction along\nwith all the contexts for each input to the Cold Wallet via QR code. \n\nQR codes have limit of 4K bytes on the maximum size of serialized data. Most of\nthe transactions with required Contexts will exceed this limit."
    },
    {
      "heading": "Simplified Signing using ReducedTransaction",
      "level": 2,
      "content": "To solve the problem of _cold signing_ we need a new data structure and\nserialization format called `ReducedTransaction`.\n\n```\nReducedTransaction:\n  - unsignedTx: UnsignedTransaction\n  - reducedInputs: Seq[ReducedInputData]\n  - txCost: Int\n\nUnsignedTransaction:\n  - inputs: Seq[UnsignedInput],\n  - dataInputs: Seq[DataInput],\n  - outputCandidates: Seq[ErgoBoxCandidate]\n\nUnsignedInput:\n  - boxId: BoxId\n  - extension: ContextExtension\n```\n\nReducedInputData:\n  - reductionResult: ReductionResult \nThus, the `ReducedTransaction` instance contains unsigned transaction augmented with\none `ReductionResult` for each `UnsignedInput`. \n\n```\nReductionResult:\n  - value: SigmaBoolean\n  - cost: Long\n```\n\nNote that `UnsignedInput` object doesn't contain `ergoTree`, `additionalTokens`,\n`additionalRegisters` and other properties of\n[ErgoBox](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/4533b6a7ae86ada20f3136c70a67a920ae7c43e1/sigmastate/src/main/scala/org/ergoplatform/ErgoBox.scala#L51)\nwhich are necessary to perform\n[ErgoTree](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/1a1b003bc30e490d8b5af30e7670227e54e682c2/sigmastate/src/main/scala/sigmastate/Values.scala#L1014)\nreduction and which are part of the\n[Context](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/e5127f6743db824f7280881cd5c4ecd336075e2f/sigmastate/src/main/scala/org/ergoplatform/ErgoLikeContext.scala#L51)\ndata structure required by the\n[prove](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/f24833d8d4572d77e4a93e5b69360335cb2d7dc1/sigmastate/src/main/scala/sigmastate/interpreter/ProverInterpreter.scala#L104)\nmethod.\n\nThis is because those context data is not required to generate proof (aka signature)\nonce ErgoTree is reduced to ReductionResult containing sigma proposition.\n\nHaving the `ReducedTransaction` data structure the full transaction signing\nconsists of three steps\n\n1) Create unsigned transaction and then reduce it in the current\nblockchain context, which has connection to one of the network nodes. This step\nis performed on Hot Wallet and produces ReducedTransaction without requiring\nsecret keys.\n\n```\nval ctx: BlockchainContext = ...\nval unsignedIx = createTransaction(ctx, from, to, amountToSend, assets)\nval prover = ctx.newProverBuilder.build // prover without secrets\nval reducedTx: ReducedTransaction = prover.reduce(unsigned, 0)\n```\n\n2) Serialize ReducedTransaction data structure to bytes and then pass it to\nthe Cold Wallet via QR code.\n\n3) Once scanned in the Cold Wallet, the ReducedTransaction object can be\ndeserialized back from bytes and then signed using prover configured with local\nsecrets.\n\n```\nval reducedTx = ReducedTransactionSerializer.fromBytes(reducedTxBytes)\nval ctx: ColdBlockchainContext = ...\n// create prover in the cold context using secrets stored on this device\nval prover = ctx.newProverBuilder.withSecretStorage(\"storage.json\").build\nval signedTx = prover.signReduced(reducedTx)\n```\n\nIt is important to note, that signatures for all inputs of the ReducedTransaction\ncan be generated directly, without script evaluation (aka script reduction) and\nand thus, Cold Wallet don't need complex spending contexts."
    },
    {
      "heading": "Transaction Interchange",
      "level": 2,
      "content": "For better security and usability additional data can be transfered between Hot\nand Cold wallets via QR codes. Hot Wallet passes data to the Cold Wallet using\nColdSigningRequest data format and Cold Wallet replies back with ColdSigningResponse."
    },
    {
      "heading": "ColdSigningRequest",
      "level": 3,
      "content": "Json format, holding\n* reducedTx (mandatory): Base64-encoded `ReducedTransaction` as defined above\n* sender (optional): P2PK address sending the transaction, can be used by cold wallets to determine which secret to use for signing the transaction\n* inputs (mandatory): List of base64-encoded serialized input boxes, can be used by cold wallets to show the user which boxes are burnt"
    },
    {
      "heading": "ColdSigningResponse:",
      "level": 3,
      "content": "Json format, holding\n* signedTx (mandatory): Base64-encoded `SignedTransaction`"
    },
    {
      "heading": "Interchange format",
      "level": 3,
      "content": "As QR codes are length-limited and it could be needed to transfer the data in chunks, it is needed to wrap the actual data sent by a small layer containing information about number of chunk pages and page index of a chunk. This is done by wrapping it in another JSON container with three properties:\n\n* The actual chunk data, named CSR for ColdSigningRequest or CSTX for ColdSigningResponse\n* property \"p\", 1-based page index of current chunk (optional if there is only one page)\n* property \"n\", number of pages (optional if there is only one page)\n\nExamples:\nThe QR code for a complete ColdSigningRequest contains the following data:\n\n     {\"CSR\":\"{\\\"reducedTx\\\":\\\"....\\\",\\\"sender\\\":\\\"9...\\\",\\\"inputs\\\":[\\\"...\\\"]}\"}\n\nThe QR code for the first chunk of a ColdSigningResponse with 3 pages total looks like the following:\n\n     {\"CSTX\":\"{\\\"signedTx\\\":\\\"... (actual data, no valid JSON on its own)\",\"n\":3,\"p\":1}\n\n\nIn addition to using the above formats the following requirements are imposed on\nHot Wallet and Cold Wallets:\n\n1) There should be a way for a given unsigned transaction on the HotWallet to\nshow QR code of ColdSigningRequest on the screen, and then scan the QR code of\nthe corresponding ColdSigningResponse.\n\n2) There should be a way on ColdWallet to scan QR code of ColdSigningRequest,\nshow transaction details on the screen and allow user to either sign or reject.\nIf signed, the QR code of ColdSigningResponse should be shown."
    },
    {
      "heading": "Reference Implementation of Hot Wallet",
      "level": 2,
      "content": "* https://github.com/ergoplatform/ergo-wallet-android"
    },
    {
      "heading": "Reference Implementation of Cold Wallet",
      "level": 2,
      "content": "* https://github.com/ergoplatform/ergo-wallet-android\n\nA special `ColdErgoClient` instance can be created to perform signing\noperations. `ColdErgoClient` don't have connections to Ergo nodes and explorer,\nmoreover for better security, cold client can forbig operations if any\ndevice connectivity is turned-on, such as WiFi, Bluetooth, NFC, Cellular etc.\nNote, using ColdErgoClient is not strictly required and ordinary client can be\nused instead, however ColdErgoClient allows this EIP to be easily supported in an\nimplementation of Cold Wallet application based on Appkit."
    },
    {
      "heading": "Benefits",
      "level": 2,
      "content": "Any wallet can become compatible with this EIP by implementing HotWallet\nrole in addition to basic wallet features. \nAny Hot wallet implementation can interact with any Cold wallet implementation.\nUsers have an alternative to specialized hardware wallets and can gain more security \nfor their funds stored on the Ergo Blockchain."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/wallet/standards/eip19.md",
  "processed_at": "2025-05-11T19:41:44.540718",
  "ai_processed": true
}