{
  "id": "docs_dev_stack_mosaik_tutorial2_md",
  "title": "Ergo Mosaik: A UI system for Ergo dApps",
  "summary": "The document provides a tutorial on building a simple UI for Ergo dApps using the Ergo Mosaik UI system. It covers the following key points:\n\n1. Ergo Mosaik is a UI layer for Ergo dApps that aims to streamline the development process by allowing developers to implement both off-chain code and UI code on the same tech stack.\n\n2. The tutorial demonstrates how to set up a Spring Boot project and add the Ergo Mosaik library to the project.\n\n3. It shows how to create a simple Mosaik app with a card containing a label and a button that displays a dialog when clicked.\n\n4. The tutorial emphasizes the use of the Mosaik Kotlin DSL to define the UI elements and layout.\n\n5. It highlights the integration of Mosaik with Spring Boot to serve the Mosaik app to its executors.",
  "qa_pairs": [
    {
      "question": "What is Ergo Mosaik?",
      "answer": "Ergo Mosaik is a UI system for Ergo dApps that provides a way to implement both off-chain code and UI code on the same tech stack."
    },
    {
      "question": "What tech stack is used for Ergo Mosaik?",
      "answer": "Ergo Mosaik uses Kotlin/JVM, which can utilize the full functionality of ergo-appkit, Ergo's first-hand SDK, and all libraries in the Java ecosystem."
    },
    {
      "question": "How is the Mosaik UI described?",
      "answer": "The Mosaik UI is described using a Mosaik DSL, a JSON-based markup language, which allows the UI to be described naturally."
    },
    {
      "question": "What framework is used to serve the Mosaik app?",
      "answer": "Spring Boot, a Java framework for building web services, is used to serve the Mosaik app to its executors."
    },
    {
      "question": "How is the first screen of the Mosaik app defined?",
      "answer": "The first screen of the Mosaik app is defined using the mosaikApp() method from the Mosaik Kotlin DSL, which takes parameters describing the app and the initial view screen."
    }
  ],
  "sections": [
    {
      "heading": "Ergo Mosaik: A UI system for Ergo dApps",
      "level": 1,
      "content": ""
    },
    {
      "heading": "2: Building a simple UI with Mosaik Kotlin DSL and Spring Boot",
      "level": 2,
      "content": "In Part 1 of this tutorial series for Ergo Mosaik, we have seen that Ergo Mosaik is a UI layer for dApps using Ergo. It is not the exclusive UI layer but aims to streamline the development process for dApp developers by providing a way to implement both off-chain code and UI code on the same tech stack. Additionally, some wallet applications ship with a built-in Mosaik executor so that your dApp UI can be used within these wallet applications.\n\nMosaik apps are a JSON-based markup language and can be generated by the tech stack of your choice. A reference implementation is provided by the Ergo core team to be used from Kotlin/JVM.\n\nThis choice was made because Kotlin/JVM can utilize the full functionality of ergo-appkit, Ergo\u2019s first-hand SDK, and all libraries in the Java ecosystem, as well as providing a well-balanced mix of imperative and functional programming. Kotlin can process domain-specific languages and self-defined DSLs. This feature was used to give a _Mosaik DSL_ with which the Mosaik user interface can be described naturally.\n\nBecause Kotlin/JVM seamlessly interoperates with the Java ecosystem, we can use Spring Boot to serve our Mosaik app to its executors. Spring Boot is a Java framework for building web services - REST APIs and dynamic websites - battle-tested, feature-rich and well-documented. You don\u2019t need to use it when creating a Mosaik app, but we use it here in our examples because it helps implement REST APIs with very clean code.\n\nSo, let\u2019s hop onto coding. You\u2019ll need Java 11 installed on your system (open-source version preferred), and we recommend IntelliJ as the development environment, but you are free to use something else."
    },
    {
      "heading": "Setting up a Spring Boot project",
      "level": 3,
      "content": "To set up a Spring Boot project, visit the Spring Initializr on start.spring.io. Change project to \u201cGradle project\u201d, language to \u201cKotlin\u201d, \u201cJava\u201d to \u201c11\u201d, and set the names as you want.\n\nAs dependencies, choose \u201cSpring Web\u201d.\n\nYou should end up with something like this:\n\n![Mosaik 2](../../../assets/img/mosaik/tutorial2-1.png)\n\nGenerate the project, extract the zip file and open the directory with the IDE of your choice. Using IntelliJ or another Gradle-compatible IDE will sync some time to download and index all dependencies.\n\nTo start the Spring Boot application, you can use the Terminal command\n\n./gradlew bootRun (or gradlw bootRun on Windows)\n\nto start your application server.\n\nThe command line will tell you that this worked and that the server is listening on port 8080:\n\n![Mosaik 2](../../../assets/img/mosaik/tutorial2-2.png)\n\nA quick check on [http://localhost:8080](http://localhost:8080) will give you a \u201cWhitelabel error page\u201d. What sounds like an error means success; it is Spring\u2019s way to tell you that there\u2019s nothing defined it can serve and no error handling defined. Hence the \u201cwhitelabel error page\u201d.\n\nLet\u2019s change this by adding a class \u201cMosaikAppController.kt\u201d in the same directory (or better: \u201cpackage\u201d) as our main \u201cMosaikappApplication\u201d. Annotate this class and add a method as shown:\n\n\n```java\n@RestController\nclass MosaikAppController {\n   @GetMapping(\"/\")\n   fun getMainPage(): String {\n       return \"Hello\"\n   }\n}\n```\n\n\nIf you start the server again and visit localhost:8080 in your web browser, you will see that \u201cHello\u201d is printed. That\u2019s even more success.\n\nWhat did we do to achieve this?\n\nThe @RestController annotation on the new class tells Spring that this class should be instantiated as a singleton, and its methods are designed for Rest APIs. Adding a method alone won\u2019t do the trick, though: the API endpoint must be defined. That\u2019s why the method itself has another annotation, which defines this method should be called when a GET request to path \u201c/\u201d comes in.\n\nReturned objects of the REST API methods are automatically serialized to JSON by Spring. In this case, we return a String for which the serialization is profane. Data classes work as well, and we will use this soon."
    },
    {
      "heading": "Adding Mosaik to the project",
      "level": 3,
      "content": "After making sure that Spring Boot is working, we now have to add Mosaik to the app. In the JVM ecosystem, libraries are served by Nexus servers, and the build tool fetches these libraries and adds them to the project during the build. We use Gradle as our build tool, and the dependencies for our project are declared in the **build.gradle.kts** file. Open it. You will find the following section:\n\n\n```scala\ndependencies {\n  implementation(\"org.springframework.boot:spring-boot-starter-web\")\n  implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin\")\n  implementation(\"org.jetbrains.kotlin:kotlin-reflect\")\n  implementation(\"org.jetbrains.kotlin:kotlin-stdlib-jdk8\")\n  testImplementation(\"org.springframework.boot:spring-boot-starter-test\")\n}\n```\n\n\nSo at the moment, spring boot web and some Kotlin extensions are declared. We add mosaik below the existing entries:\n\n\n```scala\n// Mosaik\nval mosaikVersion = \"0.5.0\"\nimplementation(\"com.github.MrStahlfelge.mosaik:common-model:$mosaikVersion\")\nimplementation(\"com.github.MrStahlfelge.mosaik:common-model-ktx:$mosaikVersion\")\nimplementation(\"com.github.MrStahlfelge.mosaik:serialization-jackson:$mosaikVersion\")\n```\n\n\nWe also need to declare another Nexus server that hosts these files. Change the repositories section (it is in the same **build.gradle.kts** file) like this:\n\n\n```sbt\nrepositories {\n   mavenCentral()\n   maven(\"https://jitpack.io\")\n}\n```\n\n\nIf you use IntelliJ, it will automatically offer to resync the project. Do it, and it will download everything needed to use Mosaik.\n\nWell done! We need one little tweak now. As said before, Spring will automatically serialize objects to JSON. This automated serialization works well in most cases - but for some cases in Mosaik, the default serialization of Jackson, the library used by Spring here, is not what the standard describes and the executing application expects. So we need to tell Spring that some of our Mosaik objects need a different serialization than the default. Configurations like that are done on the Application class, so we change the application class in **<code>MosaikappApplication.kt</code></strong> like the following:\n\n\n```scala\n@SpringBootApplication\nclass MosaikappApplication {\n  @Bean\n  @Primary\n  fun objectMapper(): ObjectMapper {\n     // enables controller methods annotated with @ResponseBody to directly return\n     // Mosaik Actions and elements that will get serialized by Spring automatically\n     return org.ergoplatform.mosaik.jackson.MosaikSerializer.getMosaikMapper()\n  }\n}\n```\n\n\nThis overrides the default \u201cobject mapper\u201d (a class to map objects to JSON) with the one defined by Mosaik.\n\nOur project setup is complete, and we can start implementing a Mosaik app! Do you remember the Mosaik desktop debugging application we compiled and started in Part 1 of the tutorial series? Keep it ready to be used!"
    },
    {
      "heading": "A first simple screen",
      "level": 3,
      "content": "Now we want to define the first screen users get presented when they open up our Mosaik app. This phrase already said implicit what has to come before the first screen: we must define the Mosaik app itself.\n\nLet's change our getMainPage method to return a Mosaik app:\n\n\n```scala\n@GetMapping(\"/\")\nfun getMainPage(): MosaikApp {\n   return mosaikApp(\n       \"First Mosaik App\", // app name shown in executors\n       1 // the app version\n   ) {\n       // define the view here\n   }\n}\n```\n\n\nmosaikApp() is a method defined in our Mosaik Kotlin DSL. It takes some parameters describing the app and, most importantly, the initial view screen.\n\nA view screen consists of multiple view elements, and some layout elements can contain other view elements. Check out the layout elements demo that you\u2019ve started in part 1: You see that the three main group elements are Row, Column, and Box. There\u2019s also Card which is nothing else than a decorated box.\n\nYou should use one of these group elements as your root view element on a screen. We will use a card here. Inside the card, we define a label with a standard text for a first project.\n\n\n```scala\nreturn mosaikApp(\n   \"First Mosaik App\", // app name shown in executors\n   1 // the app version\n) {\n   // define the view here\n   card {\n       label(\"Hello Ergo world!\")\n   }\n}\n```\n\n\nStart the Spring Boot server and use the desktop demo application to run your MosaikApp. It will look like this:\n\n![Mosaik 3](../../../assets/img/mosaik/tutorial2-3.png)\n\nWe see the app name, a somehow expected screen content, and we can also see how our viewtree looks like in JSON. Let\u2019s spice this up a lot.\n\n\n```scala\n// define the view here\ncard {\n   column(Padding.DEFAULT) {\n       label(\"Hello Ergo world!\", LabelStyle.HEADLINE2)\n\n       box(Padding.HALF_DEFAULT)\n\n       button(\"Click me\") {\n           onClickAction(showDialog(\"You clicked the button.\"))\n       }\n   }\n}\n```\n\n\nRunning it results in this view, and the button works and presents a message.\n\n![Mosaik 4](../../../assets/img/mosaik/tutorial2-4.png)\n\nFor the first part, we improved the layout by adding padding between the card outline and the card contents. The padding is declared on the new column element, not the card element. This might be surprising for people used to web design as they probably would expect that declaring padding on the card would be the better way to do this. But this would not work here: Paddings in Mosaik are always added on the outer side of the element. If you now think that a better name would be margin because, in web design, spacing on the outer side of an element is called margin, you are not quite right. Unlike web element\u2019s margins and like web element\u2019s paddings, paddings in Mosaik will always add spacing for neighboring elements.\n\nThe column element lays out its child elements vertically and linearly so that the button is added below the label, which now has a better suiting style.\n\nThe box element between the label and the button has no content and simply adds spacing between the label and button.\n\nOn the button, an onClickAction is set and given an action that shows a dialog with a message. This line looks very innocent, but a lot is going on thanks to the Kotlin DSL. If you Ctrl-Click on \u201cshowDialog\u201d and follow the code that is revealed, you will see that this expression actually defines the action and gives it a random id (because we did not set an id on our own, but the action needs an id), adds this action to the set of actions defined in our ViewContent (= the whole visible screen) and returns the action. \u201conClickAction\u201d assigns the id of the action to the view element\u2019s onClickAction property.\n\nAlthough the code looks like regular programming, it is crucial to keep in mind what is going on behind the scenes to make the JSON serialization work. The behavior implies that defining two different actions with the same id will result in the first action being overwritten:\n\n\n```scala\ncolumn(Padding.DEFAULT) {\n   label(\"Hello Ergo world!\", LabelStyle.HEADLINE2)\n\n   box(Padding.HALF_DEFAULT)\n\n   button(\"Click me\") {\n       onClickAction(showDialog(\"You clicked the button.\", \"myaction\"))\n   }\n\n   val clashingAction = reloadApp(\"myaction\")\n}\n```\n\n\nAlthough the clashingAction does not seem to be used anywhere in the code, it overwrites the dialog action. Since its ID is assigned to the button, the button will now reload the app.\n\nYou can now play around, adding some other view elements and actions. Take a look at the view elements and actions demo to see what is available and how to add it. In the next part of the tutorial series, we take a closer look at how the screen content can be altered.\n\nIf you had any problems in creating the code, you will find it [here](https://github.com/MrStahlfelge/mosaik-tutorial-series/tree/20ed591936a959fd6ab640e6520dc01e6d6c2d66)"
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/stack/mosaik/tutorial2.md",
  "processed_at": "2025-05-11T19:36:02.655575",
  "ai_processed": true
}