{
  "id": "docs_dev_scs_tx_mast-example_md",
  "title": "Tutorial: Merkleized Abstract Syntax Trees (MAST) in Ergo",
  "summary": "The document provides a tutorial on Merkleized Abstract Syntax Trees (MAST) in Ergo, a technique used to improve privacy and efficiency for complex smart contracts with multiple spending conditions. It explains how MAST works, the benefits it provides, and how it compares to traditional script execution. The tutorial includes an example of implementing MAST in ErgoScript, demonstrating the on-chain logic for verifying the Merkle proof and executing the appropriate spending condition. The document also outlines the practical implementation steps for setting up MAST off-chain, including defining the spending conditions, compiling them to ErgoTree bytes, and building the Merkle tree.",
  "qa_pairs": [
    {
      "question": "What is a Merkleized Abstract Syntax Tree (MAST) in the context of blockchain protocols?",
      "answer": "A Merkleized Abstract Syntax Tree (MAST) is a technique used in blockchain protocols to improve privacy and efficiency for complex smart contracts with multiple spending conditions. It allows revealing only the specific condition (script branch) that was actually met and proving its inclusion in the original set of conditions."
    },
    {
      "question": "How does MAST work in Ergo?",
      "answer": "In Ergo, each spending condition is treated as a separate script fragment, serialized to its ErgoTree byte representation, hashed, and arranged as leaves in a Merkle Tree. The Merkle root of this tree is stored in the main locking script of the box, and when spending, the specific script fragment and a Merkle proof demonstrating its inclusion in the tree are provided."
    },
    {
      "question": "What are the key benefits of using MAST in Ergo?",
      "answer": "The key benefits of using MAST in Ergo are: 1) Privacy, as only the executed spending condition is revealed on-chain, 2) Efficiency, as the main locking script has a smaller on-chain footprint, and 3) Scalability, as it allows for contracts with a very large number of potential conditions without making the base script excessively large or complex."
    },
    {
      "question": "How does the Merkle proof work in the MAST implementation in Ergo?",
      "answer": "When spending using a specific condition, the user provides the script bytes for that condition and a Merkle proof demonstrating that the hash of those script bytes is a valid leaf within the Merkle tree whose root is stored in the main locking script. This allows verifying the inclusion of the executed condition without revealing the entire contract script."
    },
    {
      "question": "What is the visual representation of a Merkleized Abstract Syntax Tree (MAST) in Ergo?",
      "answer": "The visual representation of a MAST in Ergo shows a Merkle Tree structure, where the root hash commits to all possible spending conditions (leaves), and when spending using a specific condition, only the necessary path in the tree needs to be revealed, along with the script bytes for that condition."
    }
  ],
  "sections": [
    {
      "heading": "Introduction",
      "level": 0,
      "content": "---\ntags:\n  - ErgoScript\n  - Smart Contracts\n  - MAST\n  - Merkleized Abstract Syntax Trees\n  - Tutorial\n  - Advanced\n  - Multi-Stage Contracts\n  - executeFromVar\n  - Merkle Proof\n---"
    },
    {
      "heading": "Tutorial: Merkleized Abstract Syntax Trees (MAST) in Ergo",
      "level": 1,
      "content": "Merkleized Abstract Syntax Trees (MAST) are a technique used in blockchain protocols to improve privacy and efficiency for complex smart contracts with multiple spending conditions. Instead of revealing the entire contract script when spending, MAST allows revealing only the specific condition (script branch) that was actually met and proving its inclusion in the original set of conditions."
    },
    {
      "heading": "Concept",
      "level": 2,
      "content": "Imagine a contract with several possible ways it can be spent:\n\n*   Condition A: Alice can spend after time T1.\n*   Condition B: Bob can spend if he provides a secret value X.\n*   Condition C: Alice and Bob can spend together anytime.\n\nTraditionally, the entire script containing all these conditions would be stored in the box's `propositionBytes`. When spending, the whole script is evaluated, revealing all possible spending paths.\n\nWith MAST:\n1.  Each condition (A, B, C) is treated as a separate script fragment.\n2.  These fragments are serialized to their [ErgoTree](../ergotree.md) byte representation (`Coll[Byte]`).\n3.  Each byte representation is hashed (e.g., using `blake2b256`).\n4.  These hashes are arranged as leaves in a [Merkle Tree](merkle-tree.md).\n5.  The **Merkle root** of this tree is calculated and stored in the main locking script of the box (often as a constant).\n\nThe locking script essentially says: \"This box can be spent if you provide:\n1.  A specific script fragment (`scriptBytes`).\n2.  A Merkle proof (`merkleProof`) demonstrating that `blake2b256(scriptBytes)` is a valid leaf within the Merkle tree whose root is `expectedMerkleRoot`.\n3.  Data (context variables, signatures, etc.) that satisfies the execution of the provided `scriptBytes`.\""
    },
    {
      "heading": "Visual Representation",
      "level": 2,
      "content": "```mermaid\ngraph TD\n    A[Root Hash] --> B[Hash of (Hash A + Hash B)]\n    A --> C[Hash of (Hash C + Hash D)]\n    B --> D1[Hash A (Alice Spend)]\n    B --> E1[Hash B (Bob Spend)]\n    C --> F1[Hash C (Timelock)]\n    C --> G1[Hash D (Multisig)]\n    \n    style D1 fill:#f9f,stroke:#333,stroke-width:2px\n    style E1 fill:#bbf,stroke:#333,stroke-width:2px\n    style F1 fill:#bfb,stroke:#333,stroke-width:2px\n    style G1 fill:#fbf,stroke:#333,stroke-width:2px\n```\n*The Merkle Root (A) commits to all possible spending conditions (leaves).*\n\nWhen spending using Alice's condition (Hash A), only the necessary path needs to be revealed:\n\n```mermaid\ngraph TD\n    A[Root Hash] --> B[Hash of (Hash A + Hash B)]\n    A --> C[Hash C - Provided in Proof]\n    B --> D1[Hash A (Alice Spend)]\n    B --> E1[Hash B - Provided in Proof]\n    \n    style A fill:#afa,stroke:#333,stroke-width:2px\n    style B fill:#afa,stroke:#333,stroke-width:2px\n    style D1 fill:#afa,stroke:#333,stroke-width:2px\n    style C fill:#bbf,stroke:#333,stroke-width:2px\n    style E1 fill:#bbf,stroke:#333,stroke-width:2px\n\n    subgraph Revealed On-Chain\n        A\n        B\n        D1\n        AliceScriptBytes[\"Alice's Script Bytes (getVar[0])\"]\n    end\n    subgraph Provided in Proof \"(getVar[1])\"\n        C\n        E1\n        ProofPositions[\"Proof Positions (getVar[2])\"]\n    end\n\n    AliceScriptBytes -->|blake2b256| D1\n```\n*Only Alice's script bytes and the sibling hashes (E1, C) needed to reconstruct the root are revealed.*"
    },
    {
      "heading": "Benefits",
      "level": 2,
      "content": "*   **Privacy:** Only the executed spending condition is revealed on-chain. Unused conditions remain hidden.\n*   **Efficiency:** Smaller on-chain footprint for the main locking script (just the root hash). Validation cost can be lower if the executed branch is simple, though Merkle proof verification adds overhead.\n*   **Scalability:** Allows for contracts with a very large number of potential conditions without making the base script excessively large or complex."
    },
    {
      "heading": "Comparison: Traditional vs. MAST Execution",
      "level": 2,
      "content": "| Aspect           | Traditional Script                     | MAST-based Execution                     |\n| :--------------- | :------------------------------------- | :--------------------------------------- |\n| Privacy          | All conditions visible on-chain        | Only used condition revealed             |\n| Script Size      | Full script stored on-chain            | Only Merkle root stored on-chain         |\n| Execution Cost   | Evaluates potentially complex script   | Verifies proof + Evaluates simple branch |\n| Complexity Limit | Limited by practical script size/cost  | Can support many conditions              |\n| Implementation   | Straightforward ErgoScript             | Requires off-chain prep + proof logic    |\n| Security         | Direct script validation               | Requires proper Merkle proof verification|"
    },
    {
      "heading": "ErgoScript MAST Example (with Proof Verification)",
      "level": 2,
      "content": "This example demonstrates the core on-chain logic using context variables to receive the script branch and its Merkle proof.\n\n```scala\n{\n  // Merkle root of all possible spending conditions (calculated off-chain)\n  // This would typically be embedded as a constant in the script\n  val merkleRoot = SELF.R4[Coll[Byte]].get // Example: Get root from R4\n\n  // Context variable 0: The specific spending script bytes being executed\n  val providedScriptBytes = getVar[Coll[Byte]](0).getOrElse(Coll[Byte]()) \n  \n  // Context variable 1: The Merkle proof (sibling hashes)\n  val merkleProof = getVar[Coll[Coll[Byte]]](1).getOrElse(Coll[Coll[Byte]]()) \n  \n  // Context variable 2: The positions of sibling hashes (0 for left, 1 for right)\n  val proofPositions = getVar[Coll[Byte]](2).getOrElse(Coll[Byte]())\n\n  // Hash the provided script to get the leaf hash\n  val leafHash = blake2b256(providedScriptBytes)\n  \n  // --- Merkle Proof Verification Logic ---\n  // (Simplified helper function - real implementation might be more complex/optimized)\n  // Assumes 'verifyMerkleProof' takes root, leaf, proof, positions and returns Boolean\n  val proofIsValid = verifyMerkleProof(merkleRoot, leafHash, merkleProof, proofPositions)\n  // --- End Merkle Proof Verification ---\n\n  // If the proof is valid, execute the provided script fragment\n  // The script fragment itself should return SigmaProp\n  val spendingCondition = if (proofIsValid) {\n    executeFromVar[SigmaProp](0) // Execute script from context variable 0\n  } else {\n    sigmaProp(false) // Proof invalid, reject\n  }\n  \n  spendingCondition\n}\n\n// --- Helper Function (Conceptual - Needs careful implementation/testing) ---\n// This function would need to be defined within the script scope or \n// potentially made available via context extension or future built-ins.\ndef verifyMerkleProof(root: Coll[Byte], leaf: Coll[Byte], proof: Coll[Coll[Byte]], positions: Coll[Byte]): Boolean = {\n  // Basic check for consistent proof/position lengths\n  if (proof.size != positions.size) {\n      false\n  } else {\n      // Start with the leaf hash\n      val currentHash = proof.fold(leaf, { (h: Coll[Byte], i: Int) => \n          val proofElement = proof(i)\n          val position = positions(i)\n          \n          // Combine current hash with proof element based on position\n          if (position == 0) { // proofElement is on the right\n              blake2b256(h ++ proofElement)\n          } else { // proofElement is on the left\n              blake2b256(proofElement ++ h)\n          }\n      })\n      // Check if the calculated root matches the expected root\n      currentHash == root\n  }\n}\n```\n*(Note: The `verifyMerkleProof` function shown is conceptual and simplified. Real-world implementations require careful handling of edge cases and potential optimizations. Currently, complex proof verification directly in ErgoScript can be costly.)*"
    },
    {
      "heading": "Practical Implementation Steps (Off-Chain)",
      "level": 2,
      "content": "The setup for MAST happens off-chain before creating the box locked by the MAST script.\n\n1.  **Define & Compile Conditions:**\n    ```scala\n    // Using Ergo's AppKit (Scala Example)\n    import org.ergoplatform.appkit._\n    import scorex.crypto.hash.Blake2b256\n    import scorex.utils.ByteArray\n\n    val alicePk = prover.getP2PKAddress.pubkey // Get Alice's public key\n    val bobPk = ... // Get Bob's public key\n\n    // Define spending conditions as ErgoScript strings\n    val aliceSpendScript = s\"{ proveDlog(alicePk) }\"\n    val bobSpendScript = s\"{ proveDlog(bobPk) }\"\n    val timelockScript = s\"{ HEIGHT > 100000 }\"\n\n    // Compile scripts to ErgoTree bytes using BlockchainContext (ctx)\n    val aliceBytes = ctx.compileContract(ConstantsBuilder.create().item(\"alicePk\", alicePk).build(), aliceSpendScript).getErgoTree.bytes\n    val bobBytes = ctx.compileContract(ConstantsBuilder.create().item(\"bobPk\", bobPk).build(), bobSpendScript).getErgoTree.bytes\n    val timelockBytes = ctx.compileContract(ConstantsBuilder.empty(), timelockScript).getErgoTree.bytes\n    ```\n\n2.  **Build Merkle Tree:**\n    ```scala\n    // Hash each condition's ErgoTree bytes\n    val hashAlice = Blake2b256.hash(aliceBytes)\n    val hashBob = Blake2b256.hash(bobBytes)\n    val hashTimelock = Blake2b256.hash(timelockBytes)\n\n    // Use a Merkle Tree library (conceptual - replace with actual library usage)\n    // Example: val tree = MerkleTree.build(Seq(hashAlice, hashBob, hashTimelock))\n    // val merkleRoot: Array[Byte] = tree.rootHash \n    val merkleRoot: Array[Byte] = ??? // Calculate the root hash\n    ```\n\n3.  **Create MAST Box:**\n    ```scala\n    // Embed the Merkle Root, e.g., in R4\n    val mastContract = ctx.compileContract(ConstantsBuilder.empty(), \"\"\"\n      {\n        val expectedRoot = SELF.R4[Coll[Byte]].get \n        // ... rest of MAST verification script from above ... \n        verifyMerkleProof(expectedRoot, blake2b256(getVar[Coll[Byte]](0).get), getVar[Coll[Coll[Byte]]](1).get, getVar[Coll[Byte]](2).get) &&\n        executeFromVar[SigmaProp](0)\n      }\n    \"\"\")\n\n    val boxValue = 1000000L // 0.001 ERG\n    val outBox = txBuilder.outBoxBuilder()\n      .value(boxValue)\n      .contract(mastContract)\n      .registers(ErgoValue.of(merkleRoot)) // Store root in R4\n      .build()\n    ```\n\n4.  **Spending Transaction (Off-Chain Prep):**\n    ```scala\n    // When spending using Alice's condition:\n    val chosenConditionBytes = aliceBytes\n    // val proof = tree.getProofForLeaf(hashAlice) // Generate Merkle proof (hashes and positions)\n    val proofHashes: Seq[Array[Byte]] = ??? \n    val proofPositions: Array[Byte] = ??? // 0 for right sibling, 1 for left\n\n    // Prepare context variables\n    val contextVars = Seq(\n        new ContextVar(0.toByte, ErgoValue.of(chosenConditionBytes)),\n        new ContextVar(1.toByte, ErgoValue.of(proofHashes.map(ErgoValue.of).toArray, ErgoType.collType(ErgoType.collType(ErgoType.byteType())))),\n        new ContextVar(2.toByte, ErgoValue.of(proofPositions))\n    )\n\n    // Build the transaction using the MAST box as input and providing contextVars\n    val unsignedTx = txBuilder\n        .boxesToSpend(Seq(mastInputBox))\n        .outputs(...)\n        .fee(...)\n        .withContextVars(contextVars:_*) // Pass context variables\n        .sendChangeTo(...)\n        .build()\n\n    // Sign the transaction (requires Alice's key for the executed script)\n    val signedTx = prover.sign(unsignedTx) \n    ```"
    },
    {
      "heading": "Security Considerations",
      "level": 2,
      "content": "1.  **Merkle Proof Verification:** The on-chain script **must** correctly and completely verify the provided Merkle proof against the expected root hash. The `verifyMerkleProof` example above is simplified; a robust implementation is crucial. Without proper verification, an attacker could provide arbitrary script bytes and bypass the intended logic.\n2.  **Script Execution:** Ensure `executeFromVar` is only called *after* the Merkle proof is successfully verified.\n3.  **Context Variable Indices:** Use distinct and well-defined indices for context variables (`getVar`, `executeFromVar`) to avoid collisions or unintended data access.\n4.  **Gas Costs:** Verifying Merkle proofs on-chain consumes computational resources and increases transaction fees. Optimize proof verification logic or consider patterns where verification is minimized.\n5.  **Off-Chain Security:** The process of generating the Merkle tree, calculating the root, and generating proofs for spending must be secure and correct off-chain."
    },
    {
      "heading": "Merkleized Finite State Machines (MFSMs)",
      "level": 2,
      "content": "The MAST concept can be combined with [Finite State Machines (FSMs)](fsm-example.md) for complex multi-stage contracts:\n\n1.  **State Transitions as Branches:** Each possible state transition logic in an FSM can be represented as a separate script branch in a Merkle tree.\n2.  **Implementation Pattern:** The main contract box stores the current FSM state identifier (e.g., in R4) and the Merkle root of all possible state *transition scripts*. To transition, the spender provides the specific transition script bytes and its Merkle proof via context variables. The main script verifies the proof and then uses `executeFromVar` to run the transition script, which validates the state change (e.g., checks `INPUTS(0).R4` vs `OUTPUTS(0).R4`).\n3.  **Benefits:** Allows complex FSMs without revealing all possible states and transitions on-chain, enhancing privacy and potentially reducing on-chain script size."
    },
    {
      "heading": "Resources & Examples",
      "level": 2,
      "content": "*   **Specifications in `sigmastate-interpreter`:**\n    *   [`MASTExampleSpecification.scala`](https://github.com/ergoplatform/sigmastate-interpreter/blob/develop/sigmastate/src/test/scala/sigmastate/utxo/examples/MASTExampleSpecification.scala): Provides Scala code demonstrating MAST concepts in a testing context.\n*   **Related Primitives:**\n    *   [Context Extension (`getVar`, `executeFromVar`)](lang-spec.md#PredefinedFunctions)\n    *   [Register Execution (`executeFromSelfReg`)](lang-spec.md#box-type)\n*   **Conceptual Docs:**\n    *   [Merkle Trees](../../data-model/structures/merkle/merkle-tree.md)\n\nImplementing MAST securely requires careful design of both the on-chain verification script and the off-chain preparation steps (tree generation, proof creation)."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/scs/tx/mast-example.md",
  "processed_at": "2025-05-11T19:31:59.592097",
  "ai_processed": true
}