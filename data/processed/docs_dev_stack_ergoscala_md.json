{
  "id": "docs_dev_stack_ergoscala_md",
  "title": "ErgoScala compiler",
  "summary": "The ErgoScala compiler is a compiler for Ergo smart contracts written in ErgoScala, a subset of Scala. It supports compilation of formally verified smart contracts from the ergo-contracts repository. The compiler produces an ErgoContract that provides an ErgoTree instance, Ergo's IR, and a Scala anonymous function that evaluates the contract code to a sigma property. The document provides examples of how to use the compiler to define a buyer contract and how to compile verified contract code.",
  "qa_pairs": [
    {
      "question": "What is the purpose of the ErgoScala compiler?",
      "answer": "The ErgoScala compiler is used to compile Ergo smart contracts written in ErgoScala (a subset of Scala)."
    },
    {
      "question": "What are the key outputs of the ErgoScala compiler?",
      "answer": "The ErgoScala compiler produces an ErgoContract that provides an ErgoTree instance and a Scala anonymous function to evaluate the contract code."
    },
    {
      "question": "How can Ergo contract code be compiled using the ErgoScalaCompiler?",
      "answer": "Ergo contract code can be compiled using the `ErgoScalaCompiler.contract` call."
    },
    {
      "question": "How are verified Ergo contracts compiled differently?",
      "answer": "Verified Ergo contracts are compiled by providing the method call where the contract code resides, using the `ErgoContractCompiler.compile` function."
    },
    {
      "question": "What is the purpose of the `buyer` method in the verified Ergo contracts?",
      "answer": "The `buyer` method holds the verified smart contract that returns a SigmaProp indicating whether a buyer can spend the funds locked in a box."
    }
  ],
  "sections": [
    {
      "heading": "ErgoScala compiler",
      "level": 1,
      "content": "Compiler for Ergo smart contracts written in ErgoScala (a subset of Scala). Compilation from formally verified smart contracts from [ergo-contracts](https://github.com/ergoplatform/ergo-contracts) is supported."
    },
    {
      "heading": "Usage",
      "level": 1,
      "content": "```scala\nlibraryDependencies += \"org.ergoplatform\" %% \"ergo-scala-compiler\" % \"0.0.0-32-aaadbee1-SNAPSHOT\",\n```\n\nCompilation results in producing `ErgoContract` that provides:\n\n- `ErgoTree` instance, Ergo's IR, which is used to define logical propositions protecting boxes (a generalization of coins) in the Ergo blockchain. Serialized ErgoTree expressions are written into UTXO boxes and then evaluated by the transaction verifier;\n- Scala anonymous function that when called with a `Context` parameter evaluates(reduces) the contract code to a sigma property. It allows us to \"call\" the contract code without loading up the interpreter."
    },
    {
      "heading": "Example",
      "level": 2,
      "content": ""
    },
    {
      "heading": "Contract code in  `contract` call",
      "level": 3,
      "content": "Ergo contract code can be compiled with `ErgoScalaCompiler.contract` call:\n\n```scala\nimport org.ergoplatform.compiler.ErgoScalaCompiler\n\n// Define a function that takes token id, amount, and buyer's public key as input parameters and returns an ErgoContract.\ndef buyerContract(\n  tokenId: Coll[Byte],\n  tokenAmount: Long,\n  buyerPk: SigmaProp\n): ErgoContract =\n  ErgoScalaCompiler.contract { // Compile the contract using the ErgoScalaCompiler library.\n    // If the buyer's public key is valid, the contract can be spent without any additional conditions.\n    buyerPk || {\n      // Otherwise, some additional conditions must be met.\n      // Check if there are any outputs and the first output has a non-empty R4 register.\n      (OUTPUTS.nonEmpty && OUTPUTS(0).R4[Coll[Byte]].isDefined) && {\n        // Get the tokens of the first output and verify that the specified token id and amount are correct.\n        val tokens = OUTPUTS(0).tokens\n        val tokenDataCorrect = tokens.nonEmpty &&\n          tokens(0)._1 == tokenId &&\n          tokens(0)._2 >= tokenAmount\n\n        // Check if the first output's R4 register matches the id of the current box (SELF) and its proposition bytes matches the buyer's public key.\n        val knownId = OUTPUTS(0).R4[Coll[Byte]].get == SELF.id\n        tokenDataCorrect && OUTPUTS(0).propositionBytes == buyerPk.propBytes && knownId\n      }\n    }\n  }\n\n```"
    },
    {
      "heading": "Verified contract code in a separate method call",
      "level": 3,
      "content": "For verified contracts, the compilation is done differently. Formal verification is done using Stainless in [ergo-contracts](https://github.com/ergoplatform/ergo-contracts). Verified contract code can be compiled by providing the method call where contract code resides.\n\n```scala\n/**\n * This function creates a new instance of the buyer contract, compiled with the provided parameters.\n * @param tokenId - the id of the token to be exchanged\n * @param tokenAmount - the amount of tokens to be exchanged\n * @param pkA - the public key of the buyer\n * @return a compiled instance of the buyer contract\n */\ndef buyerContractInstance(tokenId: Coll[Byte], tokenAmount: Long, pkA: SigmaProp): ErgoContract =\n  ErgoContractCompiler.compile { context: Context =>\n    buyer(context, tokenId, tokenAmount, pkA)\n  }\n\n```\n\nsee [sources](https://github.com/ergoplatform/ergo-contracts/blob/63e494c9d33af25e23efea88d27f31742ad31f64/verified-contracts/src/main/scala/org/ergoplatform/contracts/AssetsAtomicExchange.scala#L150-L157)\n\nwhere `buyer` method holds verified smart contract:\n```scala\n/**\n  * Function that returns a SigmaProp indicating whether a buyer can spend the funds locked in a box.\n  * A buyer can spend the funds if either the buyerPk is provided, or if the OUTPUTS have a valid tokenData\n  * for the given tokenId and the box id is known.\n  *\n  * @param ctx The context where the function is being evaluated.\n  * @param tokenId The Coll[Byte] representing the token id.\n  * @param tokenAmount The amount of tokens needed.\n  * @param buyerPk The SigmaProp of the buyer.\n  * @return A SigmaProp indicating whether a buyer can spend the funds locked in a box.\n  */\ndef buyer(ctx: Context, tokenId: Coll[Byte], tokenAmount: Long, buyerPk: SigmaProp): SigmaProp = {\n  import ctx._\n  buyerPk || {\n    (OUTPUTS.nonEmpty && OUTPUTS(0).R4[Coll[Byte]].isDefined) && {\n      val tokens = OUTPUTS(0).tokens\n      val tokenDataCorrect = tokens.nonEmpty &&\n        tokens(0)._1 == tokenId &&\n        tokens(0)._2 >= tokenAmount\n\n      val knownId = OUTPUTS(0).R4[Coll[Byte]].get == SELF.id\n      tokenDataCorrect &&\n      OUTPUTS(0).propositionBytes == buyerPk.propBytes &&\n      knownId\n    }\n  }\n}\n```\n\nsee [sources](https://github.com/ergoplatform/ergo-contracts/blob/63e494c9d33af25e23efea88d27f31742ad31f64/verified-contracts/src/main/scala/org/ergoplatform/contracts/AssetsAtomicExchange.scala#L24-L44)"
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/stack/ergoscala.md",
  "processed_at": "2025-05-11T19:34:07.708446",
  "ai_processed": true
}