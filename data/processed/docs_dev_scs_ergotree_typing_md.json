{
  "id": "docs_dev_scs_ergotree_typing_md",
  "title": "ErgoTree Typing",
  "summary": "ErgoTree is a strictly typed language where every term must have a type to be well-formed and evaluated. The typing judgement $\\Der{\\Gamma}{e : T}$ indicates that term $e$ has type $T$ in the typing context $\\Gamma$. The document presents the typing rules for ErgoTree, including rules for constants, variables, primitive operations, tuples, method calls, function expressions, function application, and block expressions. It also notes that each well-typed term has exactly one type, and defines helper functions $ptype$ and $mtype$ to handle type parameterization of primitive operations and methods. The document provides a comprehensive overview of the ErgoTree typing system.",
  "qa_pairs": [
    {
      "question": "What is the typing judgement form used in ErgoTree?",
      "answer": "The typing judgement form used in ErgoTree is $\\Der{\\Gamma}{e : T}$, which says that $e$ is a term of type $T$ in the typing context $\\Gamma$."
    },
    {
      "question": "What is the typing rule for constants in ErgoTree?",
      "answer": "The typing rule for constants in ErgoTree is $\\frac{}{\\Der{\\Gamma}{C(\\_, T)~:~T}}~(Const)$."
    },
    {
      "question": "What is the typing rule for primitive operations in ErgoTree?",
      "answer": "The typing rule for primitive operations in ErgoTree is $\\frac{\\Ov{\\DerEnv{e_i:~T_i}}~~ptype(\\delta, \\Ov{T_i}) :~(T_1,\\dots,T_n) \\to T}{\\Apply{\\delta}{\\Ov{e_i}}:~T}~(Prim)$."
    },
    {
      "question": "What is the typing rule for function expressions in ErgoTree?",
      "answer": "The typing rule for function expressions in ErgoTree is $\\frac{\\Der{\\TEnv,\\Ov{x_i:~T_i}}{e~:~T}}{\\Der{\\Gamma}{\\TyLam{x_i}{T_i}{e}~:~(T_0,\\dots,T_n) \\to T}}~(FuncExpr)$."
    },
    {
      "question": "What is the typing rule for the if-then-else expression in ErgoTree?",
      "answer": "The typing rule for the if-then-else expression in ErgoTree is $\\frac{\\DerEnv{e_{cond}:~\\lst{Boolean}}~~\\DerEnv{e_1:~T}~~\\DerEnv{e_2 :~T} }{\\DerEnv{\\IfThenElse{e_{cond}}{e_1}{e_2}~:~T} }~\\lst{(If)}$."
    }
  ],
  "sections": [
    {
      "heading": "Introduction",
      "level": 0,
      "content": "$$\n\\newcommand{\\TEnv}{\\Gamma}\n\\newcommand{\\Der}[2]{#1~\\vdash~#2}\n\\newcommand{\\DerV}[2]{#1~\\vdash^{\\text{\\lst{v}}}~#2}\n\\newcommand{\\DerC}[2]{#1~\\vdash^{\\text{\\lst{c}}}~#2}\n\\newcommand{\\DerEnv}[1]{\\Der{\\TEnv}{#1}}\n\\newcommand{\\DerEnvV}[1]{\\DerV{\\TEnv}{#1}}\n\\newcommand{\\DerEnvC}[1]{\\DerC{\\TEnv}{#1}}\n\\newcommand{\\lst}[1]{#1}\n\\newcommand{\\Tup}[1]{(#1)}\n\\newcommand{\\Apply}[2]{#1\\langle#2\\rangle}\n\\newcommand{\\MSig}[3]{\\text{def}~#1(#2): #3}\n\\newcommand{\\Ov}[1]{\\overline{#1}}\n\\newcommand{\\TyLam}[3]{\\lambda(\\Ov{#1:#2}).#3}\n\\newcommand{\\Trait}[2]{\\text{trait}~#1~\\{ #2 \\}}\n\\newcommand{\\To}{\\mapsto}\n\\newcommand{\\Low}[1]{\\mathcal{L}{[\\![#1]\\!]}}\n\\newcommand{\\Lam}[2]{\\lambda#1.#2}\n\\newcommand{\\IfThenElse}[3]{\\text{if}~(#1)~#2~\\text{else}~#3}\n\\newcommand{\\False}{\\text{false}}\n\\newcommand{\\True}{\\text{true}}\n\\newcommand{\\langname}{ErgoTree}\n\\newcommand{\\corelang}{Core-\\lambda}\n$$"
    },
    {
      "heading": "ErgoTree Typing",
      "level": 1,
      "content": "$\\langname$ is a strictly typed language, in which every term should have a type in order to be wellformed and evaluated. Typing judgement of the form $\\Der{\\Gamma}{e : T}$ say that $e$ is a term of type $T$ in the typing context $\\Gamma$."
    },
    {
      "heading": "**Figure 3: Typing rules of ErgoTree**",
      "level": 3,
      "content": "$$\\frac{}{\\Der{\\Gamma}{C(\\_, T)~:~T}}~(Const)$$\n\n$$\\frac{}{\\Der{\\Gamma,x~:~T}{x~:~T}}~(Var)$$\n\n$$\\frac{\\Ov{\\DerEnv{e_i:~T_i}}~~ptype(\\delta, \\Ov{T_i}) :~(T_1,\\dots,T_n) \\to T}{\\Apply{\\delta}{\\Ov{e_i}}:~T}~(Prim)$$\n\n$$\\frac{\\DerEnv{e_1 :~T_1}~~\\dots~~\\DerEnv{e_n :~T_n}}      {\\DerEnv{(e_1,\\dots,e_n)~:~(T_1,\\dots,T_n)}}~(Tuple)$$\n\n$$\\frac{\\DerEnv{e~:~I,~e_i:~T_i}~~mtype(m, I, \\Ov{T_i})~:~(I, T_1,\\dots,T_n) \\to T}{ \\Apply{e.m}{\\Ov{e_i}}:~T }~(MethodCall)$$ \n\n\n$$\\frac{\\Der{\\TEnv,\\Ov{x_i:~T_i}}{e~:~T}}{\\Der{\\Gamma}{\\TyLam{x_i}{T_i}{e}~:~(T_0,\\dots,T_n) \\to T}}~(FuncExpr)$$\n\n$$\\frac{\\Der{\\TEnv}{e_f:~(T_1,\\dots,T_n) \\to T}~~~\\Ov{\\Der{\\TEnv}{e_i:~T_i}} }{ \\Der{\\Gamma}{\\Apply{e_f}{\\Ov{e_i}}~:~T} }~(Apply)$$\n\n\n$$\\frac{\\DerEnv{e_{cond}:~\\lst{Boolean}}~~\\DerEnv{e_1:~T}~~\\DerEnv{e_2 :~T} }{\\DerEnv{\\IfThenElse{e_{cond}}{e_1}{e_2}~:~T} }~\\lst{(If)}$$\n\n$\\frac{\\DerEnv{e_1 :~T_1}~\\wedge~\\forall k\\in\\{2,\\dots,n\\}~\\Der{\\Gamma,x_1:~T_1,\\dots,x_{k-1}:~T_{k-1}}{e_k:~T_k}~\\wedge~\\Der{\\Gamma,x_1:~T_1,\\dots,x_n:~T_n}{e:~T}}{ \\DerEnv{\\{ \\Ov{\\text{val}}~x_i = e_i;}~e\\}~:~T} ~(BlockExpr)$\n\n\n\n\n\n\n> Note that each well-typed term has exactly one type; hence we assume there exists a function $termType: Term \\to \\mathcal{T}$ which relates each well-typed term with the corresponding type.\n\n**Primitive operations** can be parameterized with type variables; for example,[addition](https://raw.githubusercontent.com/ScorexFoundation/sigmastate-interpreter/4daec63275fd4e1364cf7a1132f3e7be6157bb5c/docs/spec/ergotree.pdf) has the signature $+~:~ (T,T) \\to T$ where $T$ is a [numeric type](types.md). Function $ptype$, defined in [primops](), returns a type of primitive operation specialized for concrete types of its arguments, for example, $ptype(+,Int, Int) = (Int, Int) \\to Int$.\n\nSimilarly, the function $mtype$ returns a type of method specialized for concrete types of the arguments of the MethodCall term.\n\n**BlockExpr** rule defines a type of well-formed block expression. It assumes a total ordering on **val** definitions. If a block expression is not well-formed, than is cannot be typed and evaluated.\n\nThe rest of the rules are standard for typed lambda calculus."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/scs/ergotree/typing.md",
  "processed_at": "2025-05-11T19:30:06.678789",
  "ai_processed": true
}