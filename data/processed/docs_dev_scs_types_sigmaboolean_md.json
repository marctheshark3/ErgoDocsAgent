{
  "id": "docs_dev_scs_types_sigmaboolean_md",
  "title": "SigmaBoolean",
  "summary": "SigmaBoolean is a crucial data type in ErgoScript that represents propositions proven using Sigma protocols. It is derived from the base type ProveDlog and is used by both the prover and the verifier to construct and verify proofs within ErgoScript. SigmaBoolean is an algebraic data type that allows developers to use boolean-like logic when working with Sigma Propositions. It is a recursive data structure, which adds complexity to the parsing process. The document explores the structure of SigmaBoolean, including its node classes and their corresponding OpCodes, and how to serialize SigmaBoolean from a P2PK address. The document also discusses the role of ErgoTree in Ergo transactions, where the serialized SigmaBoolean is prepended with a header byte to create the spending conditions for a box.",
  "qa_pairs": [
    {
      "question": "What is SigmaBoolean and how is it used in ErgoScript?",
      "answer": "SigmaBoolean is a crucial data type in ErgoScript that represents propositions proven using Sigma protocols. It is used by the prover to construct the proof and by the verifier to check the proof, making it a key player in creating and verifying proofs within ErgoScript."
    },
    {
      "question": "What is the structure of SigmaBoolean?",
      "answer": "SigmaBoolean is an algebraic data type in SigmaScript and SigmaDsl that has an opCode and a size property. The opCode is a unique identifier for the node class, and the size property returns the number of nodes in the proposition tree."
    },
    {
      "question": "How can you serialize a SigmaBoolean from a P2PK (Pay-to-Public-Key) address?",
      "answer": "To serialize a SigmaBoolean from a P2PK address, you need to decode the address using Base58 encoding, extract the public key bytes, and then incorporate the ProveDlog instruction code with the public key bytes."
    },
    {
      "question": "How can you use the bs58 library in TypeScript to serialize a SigmaBoolean from a P2PK address?",
      "answer": "You can use the bs58 library in TypeScript to serialize a SigmaBoolean from a P2PK address by decoding the address, extracting the raw bytes, slicing the bytes, combining them, and then converting the result to a base64 string."
    },
    {
      "question": "How can you use the Fleet library in TypeScript to serialize a SigmaBoolean from a P2PK address?",
      "answer": "You can use the Fleet library in TypeScript to serialize a SigmaBoolean from a P2PK address by extracting the public key from the encoded address and then creating an SSigmaProp object with the public key, which can be encoded to a base64 string or a hex string."
    }
  ],
  "sections": [
    {
      "heading": "SigmaBoolean",
      "level": 1,
      "content": "SigmaBoolean is a crucial data type in ErgoScript that represents propositions proven using Sigma protocols. It is derived from the base type [`ProveDlog`](global-functions.md#provedlog), which is used for discrete logarithm proofs. What sets SigmaBoolean apart is its dual functionality - it is used by the prover to construct the proof and by the verifier to check the proof. This dual role makes SigmaBoolean a key player in creating and verifying proofs within [ErgoScript](ergoscript.md).\n\nAs an algebraic data type in SigmaScript and SigmaDsl, SigmaBoolean allows developers to use boolean-like logic when working with [Sigma Propositions](sigma-prop.md). It's worth noting that SigmaBoolean is a recursive data structure, which adds complexity to the parsing process."
    },
    {
      "heading": "Exploring SigmaBoolean Structure",
      "level": 2,
      "content": "To gain a deeper understanding of SigmaBoolean, let's examine its structure:\n\n```scala\n/** SigmaBoolean represents the algebraic data type of sigma proposition expressions.\n * \n */\ntrait SigmaBoolean {\n  /** A unique identifier for the node class, used during serialization. */\n  val opCode: OpCode\n  /** Returns the number of nodes in the proposition tree, indicating its size. */\n  def size: Int\n}\n```\n\nIn Ergo, a node class represents a specific type or category of nodes within the proposition tree. Each node class has unique attributes and behaviors that dictate its interactions with other nodes and contribute to the overall tree structure. These node classes are identified by their [`opCodes`](lang-ops.md#opcodes), which correspond to various logical operations or conditions within the proposition tree. These operations can include AND (&&), OR (||), and THRESHOLD, as well as conditions like proveDlog and proveDHtuple.\n\nBy strategically combining and arranging these node classes, developers can construct intricate proposition trees that define the conditions and requirements for validating Ergo transactions. To determine the `size` of the proposition tree, developers can use the size method, which counts the number of nodes in the tree. This count provides an estimate of the tree's complexity or magnitude.\n\nFor the complete code, refer to [Values.scala](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/interpreter/shared/src/main/scala/sigmastate/Values.scala#L745)."
    },
    {
      "heading": "Serializing SigmaBoolean from a P2PK Address",
      "level": 2,
      "content": "You may want to serialize a SigmaBoolean from a [P2PK (Pay-to-Public-Key)](public-keys.md) address when you need to create a proof of knowledge for a specific public key. This process allows developers to create complex smart contracts. By encoding SigmaBoolean from a P2PK address, developers can define detailed contract conditions, improve privacy, ensure smooth interoperability, customize contract logic, enhance security audits, and support cross-platform compatibility.\n\nSerializing SigmaBoolean from a P2PK  address involves several steps:\n\n1. **Decode P2PK Address**: Begin by decoding the P2PK address using Base58 encoding.\n\n2. **Extract Public Key Bytes**: From the decoded data, remove the first byte, retain the last 4 bytes, and prepend it with `0xCD, 0x03`.\n\n3. **Incorporate Instruction Code**: Integrate the `ProveDlog` instruction code with the public key bytes by prepending \"08cd\" to the bytes. This produces a serialized SigmaBoolean value."
    },
    {
      "heading": "Serialization with bs58 (TypeScript)",
      "level": 3,
      "content": "Alternatively, you can use bs58 for serialization in TypeScript:\n\n```typescript\nconst decodedBuffer = bs58.decode(ergoAddress);\nconst rawBytes = Uint8Array.from(decodedBuffer);\nconst slicedBytes = rawBytes.subarray(2, rawBytes.length - 4);\nconst combinedBytes = new Uint8Array([0xCD, 0x03, ...slicedBytes]);\nconst sigmaBoolean = Buffer.from(combinedBytes).toString('base64');\n```"
    },
    {
      "heading": "Serialization using Fleet (TypeScript)",
      "level": 3,
      "content": "Here's how you can serialize SigmaBoolean using [Fleet](fleet.md) in TypeScript:\n\n```typescript\n// Extract the public key from the encoded address\nconst pk = ErgoAddress.fromBase58(\"address_here\").getPublicKeys()[0];\n\n// For base64 encoding (typically required for ergopay):\nconst encodedProp = base64.encode(SSigmaProp(SGroupElement(pk)).toBytes());\n\n// Without base64 encoding:\nconst encodedProp = SSigmaProp(SGroupElement(pk)).toHex();\n```"
    },
    {
      "heading": "ErgoTree and its Role in Transactions",
      "level": 3,
      "content": "The [ErgoTree](ergotree.md) plays a vital role in Ergo transactions as it encompasses the spending conditions required for a box to be spent. To create an ErgoTree, it is necessary to prepend `0x00` (header byte) to the serialized SigmaBoolean. This step is not just a formality, but a crucial operation that enables the creation of intricate spending conditions. By supporting complex logical constructs, ErgoTree enhances the flexibility of contract design and strengthens the security of Ergo transactions."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/scs/types/sigmaboolean.md",
  "processed_at": "2025-05-11T19:32:31.850470",
  "ai_processed": true
}