{
  "id": "docs_dev_scs_tx_reversible-address_md",
  "title": "Reversible Addresses",
  "summary": "Reversible Addresses are a type of multi-stage contract designed with anti-theft features. Funds sent to this address can initially only be spent in a way that allows the payment to be reversed by a trusted party for a specific period. After this period, only the intended recipient can spend the funds. This mechanism is useful for managing hot wallets, where the private key is stored on a server and vulnerable to compromise. The reversible address uses a two-stage protocol: the first stage ensures withdrawals adhere to specific rules, and the second stage allows either the intended recipient or the trusted party to spend the funds. If an unauthorized transaction is detected, the trusted party can use their private key to divert the funds to a secure address. These addresses can also be used for automated-release escrow payments in online shopping.",
  "qa_pairs": [
    {
      "question": "What is a reversible address?",
      "answer": "A reversible address is an example of a multi-stage contract designed with anti-theft features. Funds sent to this address can initially only be spent in a way that allows the payment to be reversed by a trusted party for a specific period, after which only the intended recipient can spend the funds."
    },
    {
      "question": "How does a reversible address function?",
      "answer": "The reversible address uses a two-stage protocol. The first stage ensures that withdrawals from the hot wallet adhere to specific rules, creating outputs protected by a second-stage script. The second stage allows either the intended recipient (after a delay) or the trusted party (before the delay) to spend the funds."
    },
    {
      "question": "What is the purpose of a reversible address?",
      "answer": "Reversible addresses are particularly useful for managing hot wallets (e.g., for exchanges or mining pools handling customer withdrawals) to recover funds in case of a private key compromise. They can also be used for automated-release escrow payments in online shopping."
    },
    {
      "question": "Who are the parties involved in a reversible address?",
      "answer": "In the example, `alice` represents the `SigmaProp` (public key) of the hot wallet, and `carol` represents the trusted party with a private key stored securely offline."
    },
    {
      "question": "What happens if an unauthorized transaction is detected from the hot wallet?",
      "answer": "If an unauthorized transaction is detected originating from the hot wallet (first stage), the trusted party can use their private key to trigger an abort procedure on the second-stage boxes, diverting the funds to a secure address."
    }
  ],
  "sections": [
    {
      "heading": "Reversible Addresses",
      "level": 1,
      "content": "A reversible address is an example of a multi-stage contract designed with anti-theft features. It functions as follows: funds sent to this address can initially only be spent in a way that allows the payment to be reversed by a trusted party for a specific period. After this period, only the intended recipient can spend the funds. This mechanism is particularly useful for managing hot wallets (e.g., for exchanges or mining pools handling customer withdrawals). A hot wallet's private key is typically stored on a server, making it vulnerable to compromise and theft. To recover funds in case of such a compromise, a trusted party (with a private key stored securely offline) can intervene.\n\nThe reversible address uses a two-stage protocol. The first stage ensures that withdrawals from the hot wallet adhere to specific rules, creating outputs protected by a second-stage script. The second stage allows either the intended recipient (after a delay) or the trusted party (before the delay) to spend the funds. If an unauthorized transaction is detected originating from the hot wallet (first stage), the trusted party can use their private key to trigger an abort procedure on the second-stage boxes, diverting the funds to a secure address. Besides securing hot wallets, these addresses can be used for automated-release escrow payments in online shopping.\n\nLet's assume:\n*   `alice` represents the `SigmaProp` (public key) of the hot wallet.\n*   `carol` represents the `SigmaProp` of the trusted party (whose private key is stored offline and used for reversals).\n*   `blocksIn24h` is a constant representing the estimated number of blocks in 24 hours (the reversal period).\n*   `bob` represents the `SigmaProp` of a customer wishing to withdraw funds.\n\nIn Ethereum, a similar outcome might be achieved by sending funds to an account with a contract (let's call it C<sub>b</sub>) that allows `carol` to withdraw funds for `blocksIn24h` blocks, after which only `bob` can withdraw. While the same contract instance could handle multiple withdrawals, creating a new instance for each withdrawal (emulating the UTXO model) might be preferable. The funds for these withdrawals would need to originate from another contract (C<sub>a</sub>) ensuring outputs are only created according to the structure of C<sub>b</sub>.\n\nIn Ergo, this is implemented as a two-stage protocol:\n1.  **Stage 1 (Hot Wallet Script - C<sub>a</sub>):** This script guards the main hot wallet funds. It ensures that any spending transaction creates outputs protected by the Stage 2 script (`withdrawScript`).\n2.  **Stage 2 (Withdrawal Script - C<sub>b</sub>):** This script guards the individual withdrawal boxes paid out to customers like Bob. It allows either Bob (after the delay) or Carol (before the delay) to spend the box.\n\nThe following script, named `withdrawScript`, implements the second stage (C<sub>b</sub>). This script protects the output box created when the hot wallet pays Bob.\n\n```scala\n// Get Bob's public key (the recipient) from register R4\nval bob = SELF.R4[SigmaProp].get \n\n// Get the deadline height (when Bob can spend) from register R5\nval bobDeadline = SELF.R5[Int].get \n\n// Check if either:\n// 1. Bob is spending AND the deadline has passed (HEIGHT > bobDeadline)\n// OR\n// 2. Carol (trusted party) is spending AND the deadline has NOT passed (HEIGHT <= bobDeadline)\nsigmaProp((bob && HEIGHT > bobDeadline) || (carol && HEIGHT <= bobDeadline))\n```\n\nThis `withdrawScript` is referenced (e.g., by its hash) in the first stage script (`hotWalletScript`) shown below. This script guards the main hot wallet funds.\n\n```scala\n// Define a function `isChange` that checks if an output box `b` is a change box \n// (i.e., returns funds to the hot wallet itself).\nval isChange = {(b: Box) => b.propositionBytes == SELF.propositionBytes} \n\n// Define a function `isWithdraw` that checks if an output box `b` is a valid withdrawal box:\n// - Its R5 register (deadline) must be at least the current height + delay.\n// - Its script must match the withdrawScript hash.\nval isWithdraw = {(b: Box) => \n  b.R5[Int].get >= HEIGHT + blocksIn24h && \n  blake2b256(b.propositionBytes) == withdrawScriptHash // Assuming withdrawScriptHash is a known constant\n}\n\n// The final condition requires:\n// 1. Alice's signature (the hot wallet owner).\n// 2. ALL outputs must satisfy EITHER the isChange condition OR the isWithdraw condition.\nsigmaProp(alice && OUTPUTS.forall({(b: Box) => isChange(b) || isWithdraw(b)}))\n```\n\nThe P2S address derived from the `hotWalletScript` acts as the reversible address. Funds sent to this address are subject to the defined withdrawal rules. Normally, Bob would spend his withdrawal box (protected by `withdrawScript`) after the `bobDeadline` (approximately `blocksIn24h` blocks later). However, if an unauthorized transaction attempts to spend from the hot wallet (violating the `isWithdraw` or `isChange` conditions), or if a legitimate withdrawal box needs to be reversed before `bobDeadline`, Carol can intervene using her private key to spend the second-stage box(es) and redirect the funds to a secure address.\n\nNote that the trusted party (`carol`) is effectively bound to this specific hot wallet setup. A different hot wallet or security policy would require a new contract and potentially a different trusted party.\n\nWhile designed for securing hot wallets, reversible addresses have other potential applications, such as automated-release escrow payments in online shopping, where `carol` could represent a mutually agreed-upon adjudicator."
    }
  ],
  "source": "https://github.com/ergoplatform/ergodocs",
  "file_path": "docs/dev/scs/tx/reversible-address.md",
  "processed_at": "2025-05-11T19:32:04.568699",
  "ai_processed": true
}